// Generated by scripts/protocol-gen-swift.ts â€” do not edit by hand
import Foundation

public let GATEWAY_PROTOCOL_VERSION = 1

public enum ErrorCode: String, Codable {
    case notLinked = "NOT_LINKED"
    case agentTimeout = "AGENT_TIMEOUT"
    case invalidRequest = "INVALID_REQUEST"
    case unavailable = "UNAVAILABLE"
}

public struct Hello: Codable {
    public let type: String
    public let minProtocol: Int
    public let maxProtocol: Int
    public let client: [String: AnyCodable]
    public let caps: [String]?
    public let auth: [String: AnyCodable]?
    public let locale: String?
    public let userAgent: String?

    public init(
        type: String,
        minProtocol: Int,
        maxProtocol: Int,
        client: [String: AnyCodable],
        caps: [String]?,
        auth: [String: AnyCodable]?,
        locale: String?,
        userAgent: String?
    ) {
        self.type = type
        self.minProtocol = minProtocol
        self.maxProtocol = maxProtocol
        self.client = client
        self.caps = caps
        self.auth = auth
        self.locale = locale
        self.userAgent = userAgent
    }
}

public struct HelloOk: Codable {
    public let type: String
    public let protocol: Int
    public let server: [String: AnyCodable]
    public let features: [String: AnyCodable]
    public let snapshot: [String: AnyCodable]
    public let policy: [String: AnyCodable]

    public init(
        type: String,
        protocol: Int,
        server: [String: AnyCodable],
        features: [String: AnyCodable],
        snapshot: [String: AnyCodable],
        policy: [String: AnyCodable]
    ) {
        self.type = type
        self.protocol = protocol
        self.server = server
        self.features = features
        self.snapshot = snapshot
        self.policy = policy
    }
}

public struct HelloError: Codable {
    public let type: String
    public let reason: String
    public let expectedProtocol: Int?
    public let minClient: String?

    public init(
        type: String,
        reason: String,
        expectedProtocol: Int?,
        minClient: String?
    ) {
        self.type = type
        self.reason = reason
        self.expectedProtocol = expectedProtocol
        self.minClient = minClient
    }
}

public struct RequestFrame: Codable {
    public let type: String
    public let id: String
    public let method: String
    public let params: AnyCodable?

    public init(
        type: String,
        id: String,
        method: String,
        params: AnyCodable?
    ) {
        self.type = type
        self.id = id
        self.method = method
        self.params = params
    }
}

public struct ResponseFrame: Codable {
    public let type: String
    public let id: String
    public let ok: Bool
    public let payload: AnyCodable?
    public let error: [String: AnyCodable]?

    public init(
        type: String,
        id: String,
        ok: Bool,
        payload: AnyCodable?,
        error: [String: AnyCodable]?
    ) {
        self.type = type
        self.id = id
        self.ok = ok
        self.payload = payload
        self.error = error
    }
}

public struct EventFrame: Codable {
    public let type: String
    public let event: String
    public let payload: AnyCodable?
    public let seq: Int?
    public let stateVersion: [String: AnyCodable]?

    public init(
        type: String,
        event: String,
        payload: AnyCodable?,
        seq: Int?,
        stateVersion: [String: AnyCodable]?
    ) {
        self.type = type
        self.event = event
        self.payload = payload
        self.seq = seq
        self.stateVersion = stateVersion
    }
}

public struct PresenceEntry: Codable {
    public let host: String?
    public let ip: String?
    public let version: String?
    public let mode: String?
    public let lastInputSeconds: Int?
    public let reason: String?
    public let tags: [String]?
    public let text: String?
    public let ts: Int
    public let instanceId: String?

    public init(
        host: String?,
        ip: String?,
        version: String?,
        mode: String?,
        lastInputSeconds: Int?,
        reason: String?,
        tags: [String]?,
        text: String?,
        ts: Int,
        instanceId: String?
    ) {
        self.host = host
        self.ip = ip
        self.version = version
        self.mode = mode
        self.lastInputSeconds = lastInputSeconds
        self.reason = reason
        self.tags = tags
        self.text = text
        self.ts = ts
        self.instanceId = instanceId
    }
}

public struct StateVersion: Codable {
    public let presence: Int
    public let health: Int

    public init(
        presence: Int,
        health: Int
    ) {
        self.presence = presence
        self.health = health
    }
}

public struct Snapshot: Codable {
    public let presence: [[String: AnyCodable]]
    public let health: AnyCodable
    public let stateVersion: [String: AnyCodable]
    public let uptimeMs: Int

    public init(
        presence: [[String: AnyCodable]],
        health: AnyCodable,
        stateVersion: [String: AnyCodable],
        uptimeMs: Int
    ) {
        self.presence = presence
        self.health = health
        self.stateVersion = stateVersion
        self.uptimeMs = uptimeMs
    }
}

public struct ErrorShape: Codable {
    public let code: String
    public let message: String
    public let details: AnyCodable?
    public let retryable: Bool?
    public let retryAfterMs: Int?

    public init(
        code: String,
        message: String,
        details: AnyCodable?,
        retryable: Bool?,
        retryAfterMs: Int?
    ) {
        self.code = code
        self.message = message
        self.details = details
        self.retryable = retryable
        self.retryAfterMs = retryAfterMs
    }
}

public struct AgentEvent: Codable {
    public let runId: String
    public let seq: Int
    public let stream: String
    public let ts: Int
    public let data: [String: AnyCodable]

    public init(
        runId: String,
        seq: Int,
        stream: String,
        ts: Int,
        data: [String: AnyCodable]
    ) {
        self.runId = runId
        self.seq = seq
        self.stream = stream
        self.ts = ts
        self.data = data
    }
}

public struct SendParams: Codable {
    public let to: String
    public let message: String
    public let mediaUrl: String?
    public let provider: String?
    public let idempotencyKey: String

    public init(
        to: String,
        message: String,
        mediaUrl: String?,
        provider: String?,
        idempotencyKey: String
    ) {
        self.to = to
        self.message = message
        self.mediaUrl = mediaUrl
        self.provider = provider
        self.idempotencyKey = idempotencyKey
    }
}

public struct AgentParams: Codable {
    public let message: String
    public let to: String?
    public let sessionId: String?
    public let thinking: String?
    public let deliver: Bool?
    public let timeout: Int?
    public let idempotencyKey: String

    public init(
        message: String,
        to: String?,
        sessionId: String?,
        thinking: String?,
        deliver: Bool?,
        timeout: Int?,
        idempotencyKey: String
    ) {
        self.message = message
        self.to = to
        self.sessionId = sessionId
        self.thinking = thinking
        self.deliver = deliver
        self.timeout = timeout
        self.idempotencyKey = idempotencyKey
    }
}

public struct TickEvent: Codable {
    public let ts: Int

    public init(
        ts: Int
    ) {
        self.ts = ts
    }
}

public struct ShutdownEvent: Codable {
    public let reason: String
    public let restartExpectedMs: Int?

    public init(
        reason: String,
        restartExpectedMs: Int?
    ) {
        self.reason = reason
        self.restartExpectedMs = restartExpectedMs
    }
}

public enum GatewayFrame: Codable {
    case hello(Hello)
    case hello-ok(HelloOk)
    case hello-error(HelloError)
    case req(RequestFrame)
    case res(ResponseFrame)
    case event(EventFrame)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let raw = try container.decode([String: AnyCodable].self)
        guard let type = raw["type"]?.value as? String else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "missing type")
        }
        switch type {
        case "hello":
            self = .hello(try decodePayload(Hello.self, from: raw))
        case "hello-ok":
            self = .helloOk(try decodePayload(HelloOk.self, from: raw))
        case "hello-error":
            self = .helloError(try decodePayload(HelloError.self, from: raw))
        case "req":
            self = .req(try decodePayload(RequestFrame.self, from: raw))
        case "res":
            self = .res(try decodePayload(ResponseFrame.self, from: raw))
        case "event":
            self = .event(try decodePayload(EventFrame.self, from: raw))
        default:
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "unknown type (type)")
        }
    }

    public func encode(to encoder: Encoder) throws {
        switch self {
        case .hello(let v): try v.encode(to: encoder)
        case .helloOk(let v): try v.encode(to: encoder)
        case .helloError(let v): try v.encode(to: encoder)
        case .req(let v): try v.encode(to: encoder)
        case .res(let v): try v.encode(to: encoder)
        case .event(let v): try v.encode(to: encoder)
        }
    }


    private func decodePayload<T: Decodable>(_ type: T.Type, from raw: [String: AnyCodable]) throws -> T {
        let data = try JSONSerialization.data(withJSONObject: raw)
        let decoder = JSONDecoder()
        return try decoder.decode(T.self, from: data)
    }

}
