{
  "generatedAt": "2026-02-19T02:52:59.229Z",
  "sourceZips": [
    "awesome-openclaw-usecases-main.zip",
    "openclaw-main.zip"
  ],
  "total": 31,
  "usecases": [
    {
      "id": "community-usecase-awesome-openclaw-usecases-multi-agent-team",
      "slug": "multi-agent-team",
      "title": "Multi-Agent Specialized Team (Solo Founder Setup)",
      "category": "agents",
      "tags": [
        "multi",
        "agent",
        "team"
      ],
      "rating": 97,
      "summary": "Solo founders wear every hat — strategy, development, marketing, sales, operations. Context-switching between these roles destroys deep work. Hiring is expensive and slow. What if you could spin up a small, specialized team of AI agents, each with a distinct r",
      "content": "<h3>Multi-Agent Specialized Team (Solo Founder Setup)</h3>\n<p>Solo founders wear every hat — strategy, development, marketing, sales, operations. Context-switching between these roles destroys deep work. Hiring is expensive and slow. What if you could spin up a small, specialized team of AI agents, each with a distinct role and personality, all controllable from a single chat interface?</p>\n<p>This use case sets up multiple OpenClaw agents as a coordinated team, each specialized in a domain, communicating through shared memory and controlled via Telegram.</p>\n<h4>Pain Point</h4>\n<ul><li>**One agent can&#39;t do everything well**: A single agent&#39;s context window fills up fast when juggling strategy, code, marketing research, and business analysis</li><li>**No specialization**: Generic prompts produce generic outputs — a coding agent shouldn&#39;t also be crafting marketing copy</li><li>**Solo founder burnout**: You need a team, not another tool to manage. The agents should work in the background and surface results, not require constant babysitting</li><li>**Knowledge silos**: Insights from marketing research don&#39;t automatically inform dev priorities unless you manually bridge them</li></ul>\n<h4>What It Does</h4>\n<ul><li>**Specialized agents**: Each agent has a distinct role, personality, and model optimized for its domain</li><li>**Shared memory**: Project docs, goals, and key decisions are accessible to all agents — nothing gets lost</li><li>**Private context**: Each agent also maintains its own conversation history and domain-specific notes</li><li>**Single control plane**: All agents are accessible through one Telegram group chat — tag the agent you need</li><li>**Scheduled daily tasks**: Agents proactively work without being asked — content prompts, competitor monitoring, metric tracking</li><li>**Parallel execution**: Multiple agents can work on independent tasks simultaneously</li></ul>\n<h4>Example Team Configuration</h4>\n<p>### Agent 1: Milo (Strategy Lead)</p>\n<p>```text</p>\n<h4>SOUL.md — Milo</h4>\n<p>You are Milo, the team lead. Confident, big-picture, charismatic.</p>\n<p>Responsibilities:</p>\n<ul><li>Strategic planning and prioritization</li><li>Coordinating the other agents</li><li>Weekly goal setting and OKR tracking</li><li>Synthesizing insights from all agents into actionable decisions</li></ul>\n<p>Model: Claude Opus</p>\n<p>Channel: Telegram (responds to @milo)</p>\n<p>Daily tasks:</p>\n<ul><li>8:00 AM: Review overnight agent activity, post morning standup summary</li><li>6:00 PM: End-of-day recap with progress toward weekly goals</li></ul>\n<p>```</p>\n<p>### Agent 2: Josh (Business &amp; Growth)</p>\n<p>```text</p>\n<h4>SOUL.md — Josh</h4>\n<p>You are Josh, the business analyst. Pragmatic, straight to the point, numbers-driven.</p>\n<p>Responsibilities:</p>\n<ul><li>Pricing strategy and competitive analysis</li><li>Growth metrics and KPI tracking</li><li>Revenue modeling and unit economics</li><li>Customer feedback analysis</li></ul>\n<p>Model: Claude Sonnet (fast, analytical)</p>\n<p>Channel: Telegram (responds to @josh)</p>\n<p>Daily tasks:</p>\n<ul><li>9:00 AM: Pull and summarize key metrics</li><li>Track competitor pricing changes weekly</li></ul>\n<p>```</p>\n<p>### Agent 3: Marketing Agent</p>\n<p>```text</p>\n<h4>SOUL.md — Marketing Agent</h4>\n<p>You are the marketing researcher. Creative, curious, trend-aware.</p>\n<p>Responsibilities:</p>\n<ul><li>Content ideation and drafting</li><li>Competitor social media monitoring</li><li>Reddit/HN/X trend tracking for relevant topics</li><li>SEO keyword research</li></ul>\n<p>Model: Gemini (strong at web research and long-context analysis)</p>\n<p>Channel: Telegram (responds to @marketing)</p>\n<p>Daily tasks:</p>\n<ul><li>10:00 AM: Surface 3 content ideas based on trending topics</li><li>Monitor competitor Reddit/X mentions daily</li><li>Weekly content calendar draft</li></ul>\n<p>```</p>\n<p>### Agent 4: Dev Agent</p>\n<p>```text</p>\n<h4>SOUL.md — Dev Agent</h4>\n<p>You are the dev agent. Precise, thorough, security-conscious.</p>\n<p>Responsibilities:</p>\n<ul><li>Coding and architecture decisions</li><li>Code review and quality checks</li><li>Bug investigation and fixing</li><li>Technical documentation</li></ul>\n<p>Model: Claude Opus / Codex (for implementation)</p>\n<p>Channel: Telegram (responds to @dev)</p>\n<p>Daily tasks:</p>\n<ul><li>Check CI/CD pipeline health</li><li>Review open PRs</li><li>Flag technical debt items</li></ul>\n<p>```</p>\n<h4>Skills You Need</h4>\n<ul><li>`telegram` skill for the shared control interface</li><li>`sessions_spawn` / `sessions_send` for multi-agent coordination</li><li>Shared file system or note-taking tool for team memory</li><li>Individual API keys for different model providers (if using mixed models)</li><li>A VPS or always-on machine to run the agents</li></ul>\n<h4>How to Set It Up</h4>\n<p>### 1. Shared Memory Structure</p>\n<p>```text</p>\n<p>team/</p>\n<p>├── GOALS.md           # Current OKRs and priorities (all agents read)</p>\n<p>├── DECISIONS.md       # Key decisions log (append-only)</p>\n<p>├── PROJECT_STATUS.md  # Current project state (updated by all)</p>\n<p>├── agents/</p>\n<p>│   ├── milo/          # Milo&#39;s private context and notes</p>\n<p>│   ├── josh/          # Josh&#39;s private context</p>\n<p>│   ├── marketing/     # Marketing agent&#39;s research</p>\n<p>│   └── dev/           # Dev agent&#39;s technical notes</p>\n<p>```</p>\n<p>### 2. Telegram Routing</p>\n<p>Configure a single Telegram group where all agents listen, but each responds only when tagged:</p>\n<p>```text</p>\n<h4>AGENTS.md — Telegram Routing</h4>\n<p>Telegram group: &quot;Team&quot;</p>\n<p>Routing:</p>\n<ul><li>@milo → Strategy agent (spawns/resumes milo session)</li><li>@josh → Business agent (spawns/resumes josh session)</li><li>@marketing → Marketing agent (spawns/resumes marketing session)</li><li>@dev → Dev agent (spawns/resumes dev session)</li><li>@all → Broadcast to all agents</li><li>No tag → Milo (team lead) handles by default</li></ul>\n<p>Each agent:</p>\n<p>1. Reads shared GOALS.md and PROJECT_STATUS.md for context</p>\n<p>2. Reads its own private notes</p>\n<p>3. Processes the message</p>\n<p>4. Responds in Telegram</p>\n<p>5. Updates shared files if the response involves a decision or status change</p>\n<p>```</p>\n<p>### 3. Scheduled Tasks</p>\n<p>```text</p>\n<h4>HEARTBEAT.md — Team Schedule</h4>\n<p>Daily:</p>\n<ul><li>8:00 AM: Milo posts morning standup (aggregates overnight agent activity)</li><li>9:00 AM: Josh pulls key metrics</li><li>10:00 AM: Marketing surfaces content ideas from trending topics</li><li>6:00 PM: Milo posts end-of-day recap</li></ul>\n<p>Ongoing:</p>\n<ul><li>Dev: Monitor CI/CD health, review PRs as they come in</li><li>Marketing: Reddit/X keyword monitoring (every 2 hours)</li><li>Josh: Competitor pricing checks (weekly)</li></ul>\n<p>Weekly:</p>\n<ul><li>Monday: Milo drafts weekly priorities (input from all agents)</li><li>Friday: Josh compiles weekly metrics report</li></ul>\n<p>```</p>\n<h4>Key Insights</h4>\n<ul><li>**Personality matters more than you&#39;d think**: Giving agents distinct names and communication styles makes it natural to &quot;talk to your team&quot; rather than wrestle with a generic AI</li><li>**Shared memory + private context**: The combination is critical — agents need common ground (goals, decisions) but also their own space to accumulate domain expertise</li><li>**Right model for the right job**: Don&#39;t use an expensive reasoning model for keyword monitoring. Match model capability to task complexity</li><li>**Scheduled tasks are the flywheel**: The real value emerges when agents proactively surface insights, not just when you ask</li><li>**Start with 2, not 4**: Begin with a lead + one specialist, then add agents as you identify bottlenecks</li></ul>\n<h4>Inspired By</h4>\n<p>This pattern was described by [Trebuh on X](https://x.com/iamtrebuh/status/2011260468975771862), a solo founder who set up 4 OpenClaw agents — Milo (strategy lead), Josh (business), a marketing agent, and a dev agent — all controlled through a single Telegram chat on a VPS. Each agent has its own personality, model, and scheduled tasks, while sharing project memory. He described it as &quot;a real small team available 24/7.&quot;</p>\n<p>The pattern was also confirmed on the [OpenClaw Showcase](https://openclaw.ai/showcase), where `@jdrhyne` reported running &quot;15+ agents, 3 machines, 1 Discord server — IT built most of this, just by chatting,&quot; and `@nateliason` described a multi-model pipeline (prototype → summarize → optimize → implement → repeat) using different models at each stage. Another user, `@danpeguine`, runs two different OpenClaw instances collaborating in the same WhatsApp group.</p>\n<h4>Related Links</h4>\n<ul><li>[OpenClaw Subagent Documentation](https://github.com/openclaw/openclaw)</li><li>[OpenClaw Telegram Skill](https://github.com/openclaw/openclaw)</li><li>[OpenClaw Showcase](https://openclaw.ai/showcase)</li><li>[Anthropic: Building Effective Agents](https://www.anthropic.com/research/building-effective-agents)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/multi-agent-team.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/multi-agent-team.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/multi-agent-team.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-n8n-workflow-orchestration",
      "slug": "n8n-workflow-orchestration",
      "title": "OpenClaw + n8n Workflow Orchestration",
      "category": "agents",
      "tags": [
        "n8n",
        "workflow",
        "orchestration"
      ],
      "rating": 97,
      "summary": "Letting your AI agent directly manage API keys and call external services is a recipe for security incidents. Every new integration means another credential in .env.local, another surface for the agent to accidentally leak or misuse.",
      "content": "<h3>OpenClaw + n8n Workflow Orchestration</h3>\n<p>Letting your AI agent directly manage API keys and call external services is a recipe for security incidents. Every new integration means another credential in `.env.local`, another surface for the agent to accidentally leak or misuse.</p>\n<p>This use case describes a pattern where OpenClaw delegates all external API interactions to n8n workflows via webhooks — the agent never touches credentials, and every integration is visually inspectable and lockable.</p>\n<h4>Pain Point</h4>\n<p>When OpenClaw handles everything directly, you get three compounding problems:</p>\n<ul><li>**No visibility**: It&#39;s hard to inspect what the agent actually built when it&#39;s buried in JavaScript skill files or shell scripts</li><li>**Credential sprawl**: Every API key lives in the agent&#39;s environment, one bad commit away from exposure</li><li>**Wasted tokens**: Deterministic sub-tasks (send an email, update a spreadsheet) burn LLM reasoning tokens when they could run as simple workflows</li></ul>\n<h4>What It Does</h4>\n<ul><li>**Proxy pattern**: OpenClaw writes n8n workflows with incoming webhooks, then calls those webhooks for all future API interactions</li><li>**Credential isolation**: API keys live in n8n&#39;s credential store — the agent only knows the webhook URL</li><li>**Visual debugging**: Every workflow is inspectable in n8n&#39;s drag-and-drop UI</li><li>**Lockable workflows**: Once a workflow is built and tested, you lock it so the agent can&#39;t modify how it interacts with the API</li><li>**Safeguard steps**: You can add validation, rate limiting, and approval gates in n8n before any external call executes</li></ul>\n<h4>How It Works</h4>\n<p>1. **Agent designs the workflow**: Tell OpenClaw what you need (e.g., &quot;create a workflow that sends a Slack message when a new GitHub issue is labeled `urgent`&quot;)</p>\n<p>2. **Agent builds it in n8n**: OpenClaw creates the workflow via n8n&#39;s API, including an incoming webhook trigger</p>\n<p>3. **You add credentials**: Open n8n&#39;s UI, add your Slack token / GitHub token manually</p>\n<p>4. **You lock the workflow**: Prevent further modifications by the agent</p>\n<p>5. **Agent calls the webhook**: From now on, OpenClaw calls `http://n8n:5678/webhook/my-workflow` with a JSON payload — it never sees the API key</p>\n<p>```text</p>\n<p>┌──────────────┐     webhook call      ┌─────────────────┐     API call     ┌──────────────┐</p>\n<p>│   OpenClaw   │ ───────────────────→  │   n8n Workflow   │ ─────────────→  │  External    │</p>\n<p>│   (agent)    │   (no credentials)    │  (locked, with   │  (credentials   │  Service     │</p>\n<p>│              │                       │   API keys)      │   stay here)    │  (Slack, etc)│</p>\n<p>└──────────────┘                       └─────────────────┘                  └──────────────┘</p>\n<p>```</p>\n<h4>Skills You Need</h4>\n<ul><li>`n8n` API access (for creating/triggering workflows)</li><li>`fetch` or `curl` for webhook calls</li><li>Docker (if using the pre-configured stack)</li><li>n8n credential management (manual, one-time setup per integration)</li></ul>\n<h4>How to Set It Up</h4>\n<p>### Option 1: Pre-configured Docker Stack</p>\n<p>A community-maintained Docker Compose setup ([openclaw-n8n-stack](https://github.com/caprihan/openclaw-n8n-stack)) pre-wires everything on a shared Docker network:</p>\n<p>```bash</p>\n<p>git clone https://github.com/caprihan/openclaw-n8n-stack.git</p>\n<p>cd openclaw-n8n-stack</p>\n<p>cp .env.template .env</p>\n<h3>Add your Anthropic API key to .env</h3>\n<p>docker-compose up -d</p>\n<p>```</p>\n<p>This gives you:</p>\n<ul><li>OpenClaw on port 3456</li><li>n8n on port 5678</li><li>Shared Docker network so OpenClaw can call `http://n8n:5678/webhook/...` directly</li><li>Pre-built workflow templates (multi-LLM fact-checking, email triage, social monitoring)</li></ul>\n<p>### Option 2: Manual Setup</p>\n<p>1. Install n8n (`npm install n8n -g` or run via Docker)</p>\n<p>2. Configure OpenClaw to know the n8n base URL</p>\n<p>3. Add this to your AGENTS.md:</p>\n<p>```text</p>\n<h4>n8n Integration Pattern</h4>\n<p>When I need to interact with external APIs:</p>\n<p>1. NEVER store API keys in my environment or skill files</p>\n<p>2. Check if an n8n workflow already exists for this integration</p>\n<p>3. If not, create one via n8n API with a webhook trigger</p>\n<p>4. Notify the user to add credentials and lock the workflow</p>\n<p>5. For all future calls, use the webhook URL with a JSON payload</p>\n<p>Workflow naming: openclaw-{service}-{action}</p>\n<p>Example: openclaw-slack-send-message</p>\n<p>Webhook call format:</p>\n<p>curl -X POST http://n8n:5678/webhook/{workflow-name} \\</p>\n<p>-H &quot;Content-Type: application/json&quot; \\</p>\n<p>-d &#39;{&quot;channel&quot;: &quot;#general&quot;, &quot;message&quot;: &quot;Hello from OpenClaw&quot;}&#39;</p>\n<p>```</p>\n<h4>Key Insights</h4>\n<ul><li>**Three wins in one**: Observability (visual UI), security (credential isolation), and performance (deterministic workflows don&#39;t burn tokens)</li><li>**Lock after testing**: The &quot;build → test → lock&quot; cycle is critical — without locking, the agent can silently modify workflows</li><li>**n8n has 400+ integrations**: Most external services you&#39;d want to connect already have n8n nodes, saving the agent from writing custom API calls</li><li>**Audit trail for free**: n8n logs every workflow execution with input/output data</li></ul>\n<h4>Inspired By</h4>\n<p>This pattern was described by [Simon Høiberg](https://x.com/SimonHoiberg/status/2020843874382487959), who outlined three reasons this approach beats letting OpenClaw handle API interactions directly: observability through n8n&#39;s visual UI, security through credential isolation, and performance by running deterministic sub-tasks as workflows instead of LLM calls. The [openclaw-n8n-stack](https://github.com/caprihan/openclaw-n8n-stack) repository provides a ready-to-run Docker Compose setup implementing this pattern.</p>\n<h4>Related Links</h4>\n<ul><li>[n8n Documentation](https://docs.n8n.io/)</li><li>[openclaw-n8n-stack (Docker setup)](https://github.com/caprihan/openclaw-n8n-stack)</li><li>[n8n Webhook Trigger Docs](https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.webhook/)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/n8n-workflow-orchestration.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/n8n-workflow-orchestration.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/n8n-workflow-orchestration.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-self-healing-home-server",
      "slug": "self-healing-home-server",
      "title": "Self-Healing Home Server & Infrastructure Management",
      "category": "deployment",
      "tags": [
        "self",
        "healing",
        "home",
        "server"
      ],
      "rating": 97,
      "summary": "Running a home server means being on-call 24/7 for your own infrastructure. Services go down at 3 AM, certificates expire silently, disk fills up, and pods crash-loop — all while you're asleep or away.",
      "content": "<h3>Self-Healing Home Server &amp; Infrastructure Management</h3>\n<p>Running a home server means being on-call 24/7 for your own infrastructure. Services go down at 3 AM, certificates expire silently, disk fills up, and pods crash-loop — all while you&#39;re asleep or away.</p>\n<p>This use case turns OpenClaw into a persistent infrastructure agent with SSH access, automated cron jobs, and the ability to detect, diagnose, and fix issues before you know there&#39;s a problem.</p>\n<h4>Pain Point</h4>\n<p>Home lab operators and self-hosters face a constant maintenance burden:</p>\n<ul><li>Health checks, log monitoring, and alerting require manual setup and attention</li><li>When something breaks, you have to SSH in, diagnose, and fix — often from your phone</li><li>Infrastructure-as-code (Terraform, Ansible, Kubernetes manifests) needs regular updates</li><li>Knowledge about your setup lives in your head, not in searchable documentation</li><li>Routine tasks (email triage, deployment checks, security audits) eat hours every week</li></ul>\n<h4>What It Does</h4>\n<ul><li>**Automated health monitoring**: Cron-based checks on services, deployments, and system resources</li><li>**Self-healing**: Detects issues via health checks and applies fixes autonomously (restart pods, scale resources, fix configs)</li><li>**Infrastructure management**: Writes and applies Terraform, Ansible, and Kubernetes manifests</li><li>**Morning briefings**: Daily summary of system health, calendar, weather, and task board status</li><li>**Email triage**: Scans inbox, labels actionable items, archives noise</li><li>**Knowledge extraction**: Processes notes and conversation exports into a structured, searchable knowledge base</li><li>**Blog publishing pipeline**: Draft → generate banner → publish to CMS → deploy to hosting — fully automated</li><li>**Security auditing**: Regular scans for hardcoded secrets, privileged containers, and overly permissive access</li></ul>\n<h4>Skills You Need</h4>\n<ul><li>`ssh` access to home network machines</li><li>`kubectl` for Kubernetes cluster management</li><li>`terraform` and `ansible` for infrastructure-as-code</li><li>`1password` CLI for secrets management</li><li>`gog` CLI for email access</li><li>Calendar API access</li><li>Obsidian vault or notes directory (for knowledge base)</li><li>`openclaw doctor` for self-diagnostics</li></ul>\n<h4>How to Set It Up</h4>\n<p>### 1. Core Agent Configuration</p>\n<p>Name your agent and define its access scope in AGENTS.md:</p>\n<p>```text</p>\n<h4>Infrastructure Agent</h4>\n<p>You are Reef, an infrastructure management agent.</p>\n<p>Access:</p>\n<ul><li>SSH to all machines on the home network (192.168.1.0/24)</li><li>kubectl for the K3s cluster</li><li>1Password vault (read-only for credentials, dedicated AI vault)</li><li>Gmail via gog CLI</li><li>Calendar (yours + partner&#39;s)</li><li>Obsidian vault at ~/Documents/Obsidian/</li></ul>\n<p>Rules:</p>\n<ul><li>NEVER hardcode secrets — always use 1Password CLI or environment variables</li><li>NEVER push directly to main — always create a PR</li><li>Run `openclaw doctor` as part of self-health checks</li><li>Log all infrastructure changes to ~/logs/infra-changes.md</li></ul>\n<p>```</p>\n<p>### 2. Automated Cron Job System</p>\n<p>The power of this setup is the scheduled job system. Configure in HEARTBEAT.md:</p>\n<p>```text</p>\n<h4>Cron Schedule</h4>\n<p>Every 15 minutes:</p>\n<ul><li>Check kanban board for in-progress tasks → continue work</li></ul>\n<p>Every hour:</p>\n<ul><li>Monitor health checks (Gatus, ArgoCD, service endpoints)</li><li>Triage Gmail (label actionable items, archive noise)</li><li>Check for unanswered alerts or notifications</li></ul>\n<p>Every 6 hours:</p>\n<ul><li>Knowledge base data entry (process new Obsidian notes)</li><li>Self health check (openclaw doctor, disk usage, memory, logs)</li></ul>\n<p>Every 12 hours:</p>\n<ul><li>Code quality and documentation audit</li><li>Log analysis via Loki/monitoring stack</li></ul>\n<p>Daily:</p>\n<ul><li>4:00 AM: Nightly brainstorm (explore connections between notes)</li><li>8:00 AM: Morning briefing (weather, calendars, system stats, task board)</li><li>1:00 AM: Velocity assessment (process improvements)</li></ul>\n<p>Weekly:</p>\n<ul><li>Knowledge base QA review</li><li>Infrastructure security audit</li></ul>\n<p>```</p>\n<p>### 3. Security Setup (Critical)</p>\n<p>This is non-negotiable. Before giving your agent SSH access:</p>\n<p>```text</p>\n<h4>Security Checklist</h4>\n<p>1. Pre-push hooks:</p>\n<ul><li>Install TruffleHog or similar secret scanner on ALL repositories</li><li>Block any commit containing hardcoded API keys, tokens, or passwords</li></ul>\n<p>2. Local-first Git workflow:</p>\n<ul><li>Use Gitea (self-hosted) for private code before pushing to public GitHub</li><li>CI scanning pipeline (Woodpecker or similar) runs before any public push</li><li>Human review required before main branch merges</li></ul>\n<p>3. Defense in depth:</p>\n<ul><li>Dedicated 1Password vault for AI agent (limited scope)</li><li>Network segmentation for sensitive services</li><li>Daily automated security audits checking for:</li><li>Privileged containers</li><li>Hardcoded secrets in code or configs</li><li>Overly permissive file/network access</li><li>Known vulnerabilities in deployed images</li></ul>\n<p>4. Agent constraints:</p>\n<ul><li>Branch protection: PR required for main, agent cannot override</li><li>Read-only access where write isn&#39;t needed</li><li>All changes logged and auditable via git</li></ul>\n<p>```</p>\n<p>### 4. Morning Briefing Template</p>\n<p>```text</p>\n<h4>Daily Briefing Format</h4>\n<p>Generate and deliver at 8:00 AM:</p>\n<p>### Weather</p>\n<ul><li>Current conditions and forecast for [your location]</li></ul>\n<p>### Calendars</p>\n<ul><li>Your events today</li><li>Partner&#39;s events today</li><li>Conflicts or overlaps flagged</li></ul>\n<p>### System Health</p>\n<ul><li>CPU / RAM / Storage across all machines</li><li>Services: UP/DOWN status</li><li>Recent deployments (ArgoCD)</li><li>Any alerts in last 24h</li></ul>\n<p>### Task Board</p>\n<ul><li>Cards completed yesterday</li><li>Cards in progress</li><li>Blocked items needing attention</li></ul>\n<p>### Highlights</p>\n<ul><li>Notable items from nightly brainstorm</li><li>Emails requiring action</li><li>Upcoming deadlines this week</li></ul>\n<p>```</p>\n<h4>Key Insights</h4>\n<ul><li>**&quot;I can&#39;t believe I have a self-healing server now&quot;**: The agent can run SSH, Terraform, Ansible, and kubectl commands to fix infrastructure issues before you even know there&#39;s a problem</li><li>**AI will hardcode secrets**: This is the #1 security risk. The agent will happily put an API key inline in code if you don&#39;t enforce guardrails. Pre-push hooks and secret scanning are mandatory</li><li>**Local-first Git is essential**: Never let the agent push directly to public repositories. Use a private Gitea instance as a staging area with CI scanning</li><li>**Cron jobs are the real product**: The scheduled automation (health checks, email triage, briefings) provides more daily value than ad-hoc commands</li><li>**Knowledge extraction compounds**: Processing notes, conversation exports, and emails into a structured knowledge base gets more valuable over time — one user extracted 49,079 atomic facts from their ChatGPT history alone</li></ul>\n<h4>Inspired By</h4>\n<p>This use case is based on Nathan&#39;s detailed writeup [&quot;Everything I&#39;ve Done with OpenClaw (So Far)&quot;](https://madebynathan.com/2026/02/03/everything-ive-done-with-openclaw-so-far/), where he describes his OpenClaw agent &quot;Reef&quot; running on a home server with SSH access to all machines, a Kubernetes cluster, 1Password integration, and an Obsidian vault with 5,000+ notes. Reef runs 15 active cron jobs, 24 custom scripts, and has autonomously built and deployed applications including a task management UI. Nathan&#39;s hard-won lesson after a Day 1 API key exposure: &quot;AI assistants will happily hardcode secrets. They sometimes don&#39;t have the same instincts humans do.&quot; His defense-in-depth security setup (TruffleHog pre-push hooks, local Gitea, CI scanning, daily audits) is essential reading for anyone attempting this pattern.</p>\n<p>Also referenced on the [OpenClaw Showcase](https://openclaw.ai/showcase), where `@georgedagg_` described a similar pattern: deployment monitoring, log review, configuration fixes, and PR submissions — all while walking the dog.</p>\n<h4>Related Links</h4>\n<ul><li>[Nathan&#39;s Full Writeup](https://madebynathan.com/2026/02/03/everything-ive-done-with-openclaw-so-far/)</li><li>[OpenClaw Documentation](https://github.com/openclaw/openclaw)</li><li>[TruffleHog (Secret Scanning)](https://github.com/trufflesecurity/trufflehog)</li><li>[K3s (Lightweight Kubernetes)](https://k3s.io/)</li><li>[Gitea (Self-hosted Git)](https://gitea.io/)</li><li>[n8n (Workflow Automation)](https://n8n.io/)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/self-healing-home-server.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/self-healing-home-server.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/self-healing-home-server.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-multi-source-tech-news-digest",
      "slug": "multi-source-tech-news-digest",
      "title": "Multi-Source Tech News Digest",
      "category": "productivity",
      "tags": [
        "multi",
        "source",
        "tech",
        "news",
        "digest"
      ],
      "rating": 95,
      "summary": "Automatically aggregate, score, and deliver tech news from 109+ sources across RSS, Twitter/X, GitHub releases, and web search — all managed through natural language.",
      "content": "<h3>Multi-Source Tech News Digest</h3>\n<p>Automatically aggregate, score, and deliver tech news from 109+ sources across RSS, Twitter/X, GitHub releases, and web search — all managed through natural language.</p>\n<h4>Pain Point</h4>\n<p>Staying updated across AI, open-source, and frontier tech requires checking dozens of RSS feeds, Twitter accounts, GitHub repos, and news sites daily. Manual curation is time-consuming, and most existing tools either lack quality filtering or require complex configuration.</p>\n<h4>What It Does</h4>\n<p>A four-layer data pipeline that runs on a schedule:</p>\n<p>1. **RSS Feeds** (46 sources) — OpenAI, Hacker News, MIT Tech Review, etc.</p>\n<p>2. **Twitter/X KOLs** (44 accounts) — @karpathy, @sama, @VitalikButerin, etc.</p>\n<p>3. **GitHub Releases** (19 repos) — vLLM, LangChain, Ollama, Dify, etc.</p>\n<p>4. **Web Search** (4 topic searches) — via Brave Search API</p>\n<p>All articles are merged, deduplicated by title similarity, and quality-scored (priority source +3, multi-source +5, recency +2, engagement +1). The final digest is delivered to Discord, email, or Telegram.</p>\n<p>The framework is fully customizable — add your own RSS feeds, Twitter handles, GitHub repos, or search queries in 30 seconds.</p>\n<h4>Prompts</h4>\n<p>**Install and set up daily digest:**</p>\n<p>```text</p>\n<p>Install tech-news-digest from ClawHub. Set up a daily tech digest at 9am to Discord #tech-news channel. Also send it to my email at myemail@example.com.</p>\n<p>```</p>\n<p>**Add custom sources:**</p>\n<p>```text</p>\n<p>Add these to my tech digest sources:</p>\n<ul><li>RSS: https://my-company-blog.com/feed</li><li>Twitter: @myFavResearcher</li><li>GitHub: my-org/my-framework</li></ul>\n<p>```</p>\n<p>**Generate on demand:**</p>\n<p>```text</p>\n<p>Generate a tech digest for the past 24 hours and send it here.</p>\n<p>```</p>\n<h4>Skills Needed</h4>\n<ul><li>[tech-news-digest](https://clawhub.ai/skills/tech-news-digest) — Install via `clawhub install tech-news-digest`</li><li>[gog](https://clawhub.ai/skills/gog) (optional) — For email delivery via Gmail</li></ul>\n<h4>Environment Variables (Optional)</h4>\n<ul><li>`X_BEARER_TOKEN` — Twitter/X API bearer token for KOL monitoring</li><li>`BRAVE_API_KEY` — Brave Search API key for web search layer</li><li>`GITHUB_TOKEN` — GitHub token for higher API rate limits</li></ul>\n<h4>Related Links</h4>\n<ul><li>[GitHub Repository](https://github.com/draco-agent/tech-news-digest)</li><li>[ClawHub Page](https://clawhub.ai/skills/tech-news-digest)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/multi-source-tech-news-digest.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/multi-source-tech-news-digest.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/multi-source-tech-news-digest.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-content-factory",
      "slug": "content-factory",
      "title": "Multi-Agent Content Factory",
      "category": "agents",
      "tags": [
        "content",
        "factory"
      ],
      "rating": 94,
      "summary": "You're a content creator juggling research, writing, and design across multiple platforms. Each step — finding trending topics, writing scripts, generating thumbnails — eats hours of your day. What if a team of specialized agents handled all of it overnight?",
      "content": "<h3>Multi-Agent Content Factory</h3>\n<p>You&#39;re a content creator juggling research, writing, and design across multiple platforms. Each step — finding trending topics, writing scripts, generating thumbnails — eats hours of your day. What if a team of specialized agents handled all of it overnight?</p>\n<p>This workflow sets up a multi-agent content factory inside Discord, where different agents handle research, writing, and visual assets in dedicated channels.</p>\n<h4>What It Does</h4>\n<ul><li>**Research Agent** scans trending stories, competitor content, and social media for the best content opportunities each morning</li><li>**Writing Agent** takes the top ideas and writes full scripts, threads, or newsletter drafts</li><li>**Thumbnail Agent** generates AI thumbnails or cover images for the content</li><li>Each agent works in its own Discord channel, keeping everything organized and reviewable</li><li>Runs automatically on a schedule (e.g., daily at 8 AM) so you wake up to finished content</li></ul>\n<h4>Pain Point</h4>\n<p>Content creation has three phases — research, writing, and design — and most creators are doing all three manually. Even with AI writing tools, you still have to prompt them one at a time. This system chains agents together in a pipeline where one agent&#39;s output feeds the next, completely hands-free.</p>\n<h4>Skills You Need</h4>\n<ul><li>Discord integration with multiple channels</li><li>`sessions_spawn` / `sessions_send` for multi-agent orchestration</li><li>[x-research-v2](https://clawhub.ai) or similar for social media research</li><li>Local image generation (e.g., Nano Banana) or an image generation API</li><li>[knowledge-base](https://clawhub.ai) skill (optional, for RAG-powered research)</li></ul>\n<h4>How to Set It Up</h4>\n<p>1. Set up a Discord server (or ask OpenClaw to do it for you — just say &quot;Set up a Discord for us&quot;).</p>\n<p>2. Create channels for each agent:</p>\n<ul><li>`#research` — trending topics and content opportunities</li><li>`#scripts` — written drafts and outlines</li><li>`#thumbnails` — generated images and cover art</li></ul>\n<p>3. Prompt OpenClaw:</p>\n<p>```text</p>\n<p>I want you to build me a content factory inside of Discord.</p>\n<p>Set up channels for different agents:</p>\n<p>1. Research Agent (#research): Every morning at 8 AM, research top trending</p>\n<p>stories, competitor content, and what&#39;s performing well on social media</p>\n<p>in my niche. Post the top 5 content opportunities with sources.</p>\n<p>2. Writing Agent (#scripts): Take the best idea from the research agent</p>\n<p>and write a full script/thread/newsletter draft. Post it in #scripts.</p>\n<p>3. Thumbnail Agent (#thumbnails): Generate AI thumbnails or cover images</p>\n<p>for the content. Post them in #thumbnails.</p>\n<p>Have all their work organized in different channels.</p>\n<p>Run this pipeline automatically every morning.</p>\n<p>```</p>\n<p>4. Customize for your platform:</p>\n<p>```text</p>\n<p>I focus on X/Twitter threads, not YouTube. Change the writing agent</p>\n<p>to produce tweet threads instead of video scripts.</p>\n<p>```</p>\n<h4>Key Insights</h4>\n<ul><li>The power is in the **chained agents** — research feeds writing, writing feeds thumbnails. You don&#39;t prompt each step individually.</li><li>Discord channels make it easy to review each agent&#39;s work separately and give feedback like &quot;scripts are too long&quot; or &quot;focus more on AI news.&quot;</li><li>You can adapt this for any content format: tweets, newsletters, LinkedIn posts, podcast outlines, blog articles.</li><li>Running a local model for image generation (like Nano Banana on a Mac Studio) keeps costs down and gives you more control.</li></ul>\n<h4>Based On</h4>\n<p>Inspired by [Alex Finn&#39;s video on life-changing OpenClaw use cases](https://www.youtube.com/watch?v=41_TNGDDnfQ).</p>\n<h4>Related Links</h4>\n<ul><li>[OpenClaw Subagent Docs](https://github.com/openclaw/openclaw)</li><li>[Discord Bot Setup](https://discord.com/developers/docs)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/content-factory.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/content-factory.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/content-factory.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-market-research-product-factory",
      "slug": "market-research-product-factory",
      "title": "Market Research & Product Factory",
      "category": "research",
      "tags": [
        "market",
        "research",
        "product",
        "factory"
      ],
      "rating": 94,
      "summary": "You want to build a product but don't know what to build. Or you have a business and need to understand what your customers are struggling with. This workflow uses the Last 30 Days skill to mine Reddit and X for real pain points, then has OpenClaw build soluti",
      "content": "<h3>Market Research &amp; Product Factory</h3>\n<p>You want to build a product but don&#39;t know what to build. Or you have a business and need to understand what your customers are struggling with. This workflow uses the Last 30 Days skill to mine Reddit and X for real pain points, then has OpenClaw build solutions to those problems.</p>\n<h4>What It Does</h4>\n<ul><li>Researches any topic across Reddit and X over the last 30 days using the [Last 30 Days](https://github.com/matvanhorde/last-30-days) skill</li><li>Surfaces real challenges, complaints, and feature requests people are posting about</li><li>Helps you identify product opportunities from genuine user pain points</li><li>Takes it a step further: ask OpenClaw to build an MVP that solves one of those challenges</li><li>Creates a full research-to-product pipeline with zero coding on your part</li></ul>\n<h4>Pain Point</h4>\n<p>Most aspiring entrepreneurs struggle with the &quot;what to build&quot; problem. Market research traditionally means hours of manual browsing through forums, social media, and review sites. This automates the entire discovery-to-prototype pipeline.</p>\n<h4>Skills You Need</h4>\n<ul><li>[Last 30 Days](https://github.com/matvanhorde/last-30-days) skill by Matt Van Horde</li><li>Telegram or Discord integration for receiving research reports</li></ul>\n<h4>How to Set It Up</h4>\n<p>1. Install the Last 30 Days skill:</p>\n<p>```text</p>\n<p>Install this skill: https://github.com/matvanhorde/last-30-days</p>\n<p>```</p>\n<p>2. Run research on any topic:</p>\n<p>```text</p>\n<p>Please use the Last 30 Days skill to research challenges people are</p>\n<p>having with [your topic here].</p>\n<p>Organize the findings into:</p>\n<ul><li>Top pain points (ranked by frequency)</li><li>Specific complaints and feature requests</li><li>Gaps in existing solutions</li><li>Opportunities for a new product</li></ul>\n<p>```</p>\n<p>3. Pick a pain point and have OpenClaw build a solution:</p>\n<p>```text</p>\n<p>Build me an MVP that solves [pain point from research].</p>\n<p>Keep it simple — just the core functionality.</p>\n<p>Ship it as a web app I can share with people.</p>\n<p>```</p>\n<p>4. For ongoing market intelligence, schedule regular research:</p>\n<p>```text</p>\n<p>Every Monday morning, use the Last 30 Days skill to research what</p>\n<p>people are saying about [your niche] on Reddit and X. Summarize the</p>\n<p>top opportunities and send them to my Telegram.</p>\n<p>```</p>\n<h4>Real World Example</h4>\n<p>```text</p>\n<p>&quot;Use the Last 30 Days skill to research challenges people are having with OpenClaw.&quot;</p>\n<p>Results:</p>\n<ul><li>Setup difficulty: Many users struggle with initial configuration</li><li>Skill discovery: People can&#39;t find skills that do what they need</li><li>Cost concerns: Users want cheaper model alternatives</li></ul>\n<p>→ &quot;Build me a simple web app that makes OpenClaw setup easier with a guided wizard.&quot;</p>\n<p>OpenClaw builds the app. You ship it. You have a product.</p>\n<p>```</p>\n<h4>Key Insights</h4>\n<ul><li>This is **entrepreneurship on autopilot**: find problems → validate demand → build solutions, all through text messages.</li><li>The Last 30 Days skill gives you real, unfiltered user sentiment — not sanitized survey data.</li><li>You don&#39;t need to be technical. OpenClaw does the research AND the building.</li><li>Schedule weekly research to stay on top of evolving pain points in your market.</li></ul>\n<h4>Based On</h4>\n<p>Inspired by [Alex Finn&#39;s video on life-changing OpenClaw use cases](https://www.youtube.com/watch?v=41_TNGDDnfQ) and the [Last 30 Days skill](https://github.com/matvanhorde/last-30-days) by Matt Van Horde.</p>\n<h4>Related Links</h4>\n<ul><li>[Last 30 Days Skill](https://github.com/matvanhorde/last-30-days)</li><li>[OpenClaw Skills Directory](https://github.com/openclaw/skills)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/market-research-product-factory.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/market-research-product-factory.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/market-research-product-factory.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-youtube-content-pipeline",
      "slug": "youtube-content-pipeline",
      "title": "YouTube Content Pipeline",
      "category": "workflow",
      "tags": [
        "youtube",
        "content",
        "pipeline"
      ],
      "rating": 94,
      "summary": "As a daily YouTube creator, finding fresh, timely video ideas across the web and X/Twitter is time-consuming. Tracking what you've already covered prevents duplicates and helps you stay ahead of trends.",
      "content": "<h3>YouTube Content Pipeline</h3>\n<p>As a daily YouTube creator, finding fresh, timely video ideas across the web and X/Twitter is time-consuming. Tracking what you&#39;ve already covered prevents duplicates and helps you stay ahead of trends.</p>\n<p>This workflow automates the entire content scouting and research pipeline:</p>\n<p>• Hourly cron job scans breaking AI news (web + X/Twitter) and pitches video ideas to Telegram</p>\n<p>• Maintains a 90-day video catalog with view counts and topic analysis to avoid re-covering topics</p>\n<p>• Stores all pitches in a SQLite database with vector embeddings for semantic dedup (so you never get pitched the same idea twice)</p>\n<p>• When you share a link in Slack, OpenClaw researches the topic, searches X for related posts, queries your knowledge base, and creates an Asana card with a full outline</p>\n<h4>Skills you Need</h4>\n<ul><li>`web_search` (built-in)</li><li>[x-research-v2](https://clawhub.ai) or custom X/Twitter search skill</li><li>[knowledge-base](https://clawhub.ai) skill for RAG</li><li>Asana integration (or Todoist)</li><li>`gog` CLI for YouTube Analytics</li><li>Telegram topic for receiving pitches</li></ul>\n<h4>How to Set it Up</h4>\n<p>1. Set up a Telegram topic for video ideas and configure it in OpenClaw.</p>\n<p>2. Install the knowledge-base skill and x-research skill.</p>\n<p>3. Create a SQLite database for pitch tracking:</p>\n<p>```sql</p>\n<p>CREATE TABLE pitches (</p>\n<p>id INTEGER PRIMARY KEY,</p>\n<p>timestamp TEXT,</p>\n<p>topic TEXT,</p>\n<p>embedding BLOB,</p>\n<p>sources TEXT</p>\n<p>);</p>\n<p>```</p>\n<p>4. Prompt OpenClaw:</p>\n<p>```text</p>\n<p>Run an hourly cron job to:</p>\n<p>1. Search web and X/Twitter for breaking AI news</p>\n<p>2. Check against my 90-day YouTube catalog (fetch from YouTube Analytics via gog)</p>\n<p>3. Check semantic similarity against all past pitches in the database</p>\n<p>4. If novel, pitch the idea to my Telegram &quot;video ideas&quot; topic with sources</p>\n<p>Also: when I share a link in Slack #ai_trends, automatically:</p>\n<p>1. Research the topic</p>\n<p>2. Search X for related posts</p>\n<p>3. Query my knowledge base</p>\n<p>4. Create an Asana card in Video Pipeline with a full outline</p>\n<p>```</p>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/youtube-content-pipeline.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/youtube-content-pipeline.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/youtube-content-pipeline.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-multi-channel-customer-service",
      "slug": "multi-channel-customer-service",
      "title": "Multi-Channel AI Customer Service Platform",
      "category": "productivity",
      "tags": [
        "multi",
        "channel",
        "customer",
        "service"
      ],
      "rating": 92,
      "summary": "Small businesses juggle WhatsApp, Instagram DMs, emails, and Google Reviews across multiple apps. Customers expect instant responses 24/7, but hiring staff for round-the-clock coverage is expensive.",
      "content": "<h3>Multi-Channel AI Customer Service Platform</h3>\n<p>Small businesses juggle WhatsApp, Instagram DMs, emails, and Google Reviews across multiple apps. Customers expect instant responses 24/7, but hiring staff for round-the-clock coverage is expensive.</p>\n<p>This use case consolidates all customer touchpoints into a single AI-powered inbox that responds intelligently on your behalf.</p>\n<h4>What It Does</h4>\n<ul><li>**Unified inbox**: WhatsApp Business, Instagram DMs, Gmail, and Google Reviews in one place</li><li>**AI auto-responses**: Handles FAQs, appointment requests, and common inquiries automatically</li><li>**Human handoff**: Escalates complex issues or flags them for review</li><li>**Test mode**: Demo the system to clients without affecting real customers</li><li>**Business context**: Trained on your services, pricing, and policies</li></ul>\n<h4>Real Business Example</h4>\n<p>At Futurist Systems, we deploy this for local service businesses (restaurants, clinics, salons). One restaurant reduced response time from 4+ hours to under 2 minutes, handling 80% of inquiries automatically.</p>\n<h4>Skills You Need</h4>\n<ul><li>WhatsApp Business API integration</li><li>Instagram Graph API (via Meta Business)</li><li>`gog` CLI for Gmail</li><li>Google Business Profile API for reviews</li><li>Message routing logic in AGENTS.md</li></ul>\n<h4>How to Set It Up</h4>\n<p>1. **Connect channels** via OpenClaw config:</p>\n<ul><li>WhatsApp Business API (through 360dialog or official API)</li><li>Instagram via Meta Business Suite</li><li>Gmail via `gog` OAuth</li><li>Google Business Profile API token</li></ul>\n<p>2. **Create business knowledge base**:</p>\n<ul><li>Services and pricing</li><li>Business hours and location</li><li>FAQ responses</li><li>Escalation triggers (e.g., complaints, refund requests)</li></ul>\n<p>3. **Configure AGENTS.md** with routing logic:</p>\n<p>```text</p>\n<h4>Customer Service Mode</h4>\n<p>When receiving customer messages:</p>\n<p>1. Identify channel (WhatsApp/Instagram/Email/Review)</p>\n<p>2. Check if test mode is enabled for this client</p>\n<p>3. Classify intent:</p>\n<ul><li>FAQ → respond from knowledge base</li><li>Appointment → check availability, confirm booking</li><li>Complaint → flag for human review, acknowledge receipt</li><li>Review → thank for feedback, address concerns</li></ul>\n<p>Response style:</p>\n<ul><li>Friendly, professional, concise</li><li>Match the customer&#39;s language (ES/EN/UA)</li><li>Never invent information not in knowledge base</li><li>Sign off with business name</li></ul>\n<p>Test mode:</p>\n<ul><li>Prefix responses with [TEST]</li><li>Log but don&#39;t send to real channels</li></ul>\n<p>```</p>\n<p>4. **Set up heartbeat checks** for response monitoring:</p>\n<p>```text</p>\n<h4>Heartbeat: Customer Service Check</h4>\n<p>Every 30 minutes:</p>\n<ul><li>Check for unanswered messages &gt; 5 min old</li><li>Alert if response queue is backing up</li><li>Log daily response metrics</li></ul>\n<p>```</p>\n<h4>Key Insights</h4>\n<ul><li>**Language detection matters**: Auto-detect and respond in customer&#39;s language</li><li>**Test mode is essential**: Clients need to see it work before going live</li><li>**Handoff rules**: Define clear escalation triggers to avoid AI overreach</li><li>**Response templates**: Pre-approved templates for sensitive topics (refunds, complaints)</li></ul>\n<h4>Related Links</h4>\n<ul><li>[WhatsApp Business API](https://developers.facebook.com/docs/whatsapp)</li><li>[Instagram Messaging API](https://developers.facebook.com/docs/instagram-api/guides/messaging)</li><li>[Google Business Profile API](https://developers.google.com/my-business)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/multi-channel-customer-service.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/multi-channel-customer-service.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/multi-channel-customer-service.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-knowledge-base-rag",
      "slug": "knowledge-base-rag",
      "title": "Personal Knowledge Base (RAG)",
      "category": "productivity",
      "tags": [
        "knowledge",
        "base",
        "rag"
      ],
      "rating": 91,
      "summary": "You read articles, tweets, and watch videos all day but can never find that one thing you saw last week. Bookmarks pile up and become useless.",
      "content": "<h3>Personal Knowledge Base (RAG)</h3>\n<p>You read articles, tweets, and watch videos all day but can never find that one thing you saw last week. Bookmarks pile up and become useless.</p>\n<p>This workflow builds a searchable knowledge base from everything you save:</p>\n<p>• Drop any URL into Telegram or Slack and it auto-ingests the content (articles, tweets, YouTube transcripts, PDFs)</p>\n<p>• Semantic search over everything you&#39;ve saved: &quot;What did I save about agent memory?&quot; returns ranked results with sources</p>\n<p>• Feeds into other workflows — e.g., the video idea pipeline queries the KB for relevant saved content when building research cards</p>\n<h4>Skills you Need</h4>\n<ul><li>[knowledge-base](https://clawhub.ai) skill (or build custom RAG with embeddings)</li><li>`web_fetch` (built-in)</li><li>Telegram topic or Slack channel for ingestion</li></ul>\n<h4>How to Set it Up</h4>\n<p>1. Install the knowledge-base skill from ClawdHub.</p>\n<p>2. Create a Telegram topic called &quot;knowledge-base&quot; (or use a Slack channel).</p>\n<p>3. Prompt OpenClaw:</p>\n<p>```text</p>\n<p>When I drop a URL in the &quot;knowledge-base&quot; topic:</p>\n<p>1. Fetch the content (article, tweet, YouTube transcript, PDF)</p>\n<p>2. Ingest it into the knowledge base with metadata (title, URL, date, type)</p>\n<p>3. Reply with confirmation: what was ingested and chunk count</p>\n<p>When I ask a question in this topic:</p>\n<p>1. Search the knowledge base semantically</p>\n<p>2. Return top results with sources and relevant excerpts</p>\n<p>3. If no good matches, tell me</p>\n<p>Also: when other workflows need research (e.g., video ideas, meeting prep), automatically query the knowledge base for relevant saved content.</p>\n<p>```</p>\n<p>4. Test it by dropping a few URLs and asking questions like &quot;What do I have about LLM memory?&quot;</p>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/knowledge-base-rag.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/knowledge-base-rag.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/knowledge-base-rag.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-multi-channel-assistant",
      "slug": "multi-channel-assistant",
      "title": "Multi-Channel Personal Assistant",
      "category": "workflow",
      "tags": [
        "multi",
        "channel",
        "assistant"
      ],
      "rating": 91,
      "summary": "Context-switching between apps to manage tasks, schedule events, send messages, and track work is exhausting. You want one interface that routes to all your tools.",
      "content": "<h3>Multi-Channel Personal Assistant</h3>\n<p>Context-switching between apps to manage tasks, schedule events, send messages, and track work is exhausting. You want one interface that routes to all your tools.</p>\n<p>This workflow consolidates everything into a single AI assistant:</p>\n<p>• Telegram as primary interface with topic-based routing (different topics for video ideas, CRM, earnings, config, etc.)</p>\n<p>• Slack integration for team collaboration (task assignment, knowledge base saves, video idea triggers)</p>\n<p>• Google Workspace: create calendar events, manage email, upload to Drive — all from chat</p>\n<p>• Todoist for quick task capture</p>\n<p>• Asana for project management</p>\n<p>• Automated reminders: trash day, weekly company letter, etc.</p>\n<h4>Skills you Need</h4>\n<ul><li>`gog` CLI (Google Workspace)</li><li>Slack integration (bot + user tokens)</li><li>Todoist API or skill</li><li>Asana API or skill</li><li>Telegram channel with multiple topics configured</li></ul>\n<h4>How to Set it Up</h4>\n<p>1. Set up Telegram topics for different contexts:</p>\n<ul><li>`config` — bot settings and debugging</li><li>`updates` — status and notifications</li><li>`video-ideas` — content pipeline</li><li>`personal-crm` — contact management</li><li>`earnings` — financial tracking</li><li>`knowledge-base` — RAG ingestion and queries</li></ul>\n<p>2. Connect all your tools via OpenClaw config:</p>\n<ul><li>Google OAuth (Gmail, Calendar, Drive)</li><li>Slack (app + user tokens)</li><li>Todoist API token</li><li>Asana API token</li></ul>\n<p>3. Prompt OpenClaw:</p>\n<p>```text</p>\n<p>You are my multi-channel assistant. Route requests based on context:</p>\n<p>Telegram topics:</p>\n<ul><li>&quot;config&quot; → system settings, debugging</li><li>&quot;updates&quot; → daily summaries, reminders, calendar</li><li>&quot;video-ideas&quot; → content pipeline and research</li><li>&quot;personal-crm&quot; → contact queries and meeting prep</li><li>&quot;earnings&quot; → financial tracking</li><li>&quot;knowledge-base&quot; → save and search content</li></ul>\n<p>When I ask you to:</p>\n<ul><li>&quot;Add [task] to my todo&quot; → use Todoist</li><li>&quot;Create a card for [topic]&quot; → use Asana Video Pipeline project</li><li>&quot;Schedule [event]&quot; → use gog calendar</li><li>&quot;Email [person] about [topic]&quot; → draft email via gog gmail</li><li>&quot;Upload [file] to Drive&quot; → use gog drive</li></ul>\n<p>Set up automated reminders:</p>\n<ul><li>Monday 6 PM: &quot;🗑️ Trash day tomorrow&quot;</li><li>Friday 3 PM: &quot;✍️ Time to write the weekly company update&quot;</li></ul>\n<p>```</p>\n<p>4. Test each integration individually, then test cross-workflow interactions (e.g., saving a Slack link to knowledge base, then using it in a video research card).</p>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/multi-channel-assistant.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/multi-channel-assistant.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/multi-channel-assistant.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-family-calendar-household-assistant",
      "slug": "family-calendar-household-assistant",
      "title": "Family Calendar Aggregation & Household Assistant",
      "category": "productivity",
      "tags": [
        "family",
        "calendar",
        "household",
        "assistant"
      ],
      "rating": 90,
      "summary": "Modern families juggle five or more calendars — work, personal, shared family, kids' school, extracurriculars — across different platforms and formats. Important events slip through the cracks because no single view exists. Meanwhile, household coordination (g",
      "content": "<h3>Family Calendar Aggregation &amp; Household Assistant</h3>\n<p>Modern families juggle five or more calendars — work, personal, shared family, kids&#39; school, extracurriculars — across different platforms and formats. Important events slip through the cracks because no single view exists. Meanwhile, household coordination (grocery lists, pantry inventory, appointment scheduling) happens through scattered text messages that get buried.</p>\n<p>This use case turns OpenClaw into an always-on household coordinator: aggregating calendars into a morning briefing, monitoring messages for actionable items, and managing household logistics through a shared chat interface.</p>\n<h4>Pain Point</h4>\n<ul><li>**Calendar fragmentation**: Work calendars have security restrictions preventing sharing. School calendars arrive as PDFs or hand-written websites. Camp schedules live in emails. Manually checking each one every morning is unsustainable — and &quot;copying events across calendars works well until I forget and one slips through the cracks.&quot;</li><li>**Household coordination overhead**: &quot;How much milk do we have?&quot; requires physically checking the fridge, then the basement pantry, then texting back. Multiply this across a week&#39;s worth of grocery runs.</li><li>**Missed appointments**: Appointment confirmations arrive via text message and sit there unacted upon — no calendar event, no driving time buffer, no reminder.</li></ul>\n<h4>What It Does</h4>\n<ul><li>**Morning briefing**: Aggregates all family calendars into a single daily summary delivered via your preferred channel</li><li>**Ambient message monitoring**: Watches iMessage/text conversations and automatically creates calendar events when it detects appointments (dentist confirmations, meeting plans, etc.)</li><li>**Driving time buffers**: Adds travel time blocks before and after detected appointments</li><li>**Household inventory**: Maintains a running inventory of pantry/fridge items that either partner can query from anywhere</li><li>**Grocery coordination**: Deduplicates ingredients across recipes, tracks what&#39;s running low, and generates shopping lists</li><li>**Photo-based input**: Snap a photo of a school calendar or freezer contents and the agent processes it into structured data</li></ul>\n<h4>Skills You Need</h4>\n<ul><li>Calendar API access (Google Calendar, Apple Calendar via `ical`)</li><li>`imessage` skill for message monitoring (macOS only)</li><li>Telegram or Slack for the shared family chat interface</li><li>File system access for inventory tracking</li><li>Camera/photo processing for OCR of physical calendars</li></ul>\n<h4>How to Set It Up</h4>\n<p>### 1. Calendar Aggregation</p>\n<p>Configure OpenClaw to pull from all family calendar sources:</p>\n<p>```text</p>\n<h4>Calendar Sources</h4>\n<p>On morning briefing (8:00 AM):</p>\n<p>1. Fetch my Google Work Calendar (read-only OAuth)</p>\n<p>2. Fetch shared Family Google Calendar</p>\n<p>3. Fetch partner&#39;s calendar (shared view)</p>\n<p>4. Check ~/Documents/school-calendars/ for any new PDFs → OCR and extract events</p>\n<p>5. Check recent emails for calendar attachments or event invitations</p>\n<p>Compile into a single briefing:</p>\n<ul><li>Today&#39;s events (all calendars, color-coded by source)</li><li>Upcoming 3-day lookahead for conflicts</li><li>Any new events added since yesterday</li><li>Weather context for outdoor events</li></ul>\n<p>Deliver via Telegram/Slack family channel.</p>\n<p>```</p>\n<p>### 2. Ambient Message Monitoring</p>\n<p>This is the key differentiator — the agent watches passively and acts when it recognizes something actionable:</p>\n<p>```text</p>\n<h4>Message Monitoring (HEARTBEAT.md)</h4>\n<p>Every 15 minutes:</p>\n<p>1. Check new iMessages across all conversations</p>\n<p>2. Detect appointment-like patterns:</p>\n<ul><li>&quot;Your appointment is confirmed for...&quot;</li><li>&quot;Can we meet on [date] at [time]?&quot;</li><li>&quot;Practice moved to Saturday at 3pm&quot;</li></ul>\n<p>3. When detected:</p>\n<ul><li>Create calendar event with details</li><li>Add 30-minute driving buffer before AND after</li><li>Send confirmation to family Telegram: &quot;Created: Dentist appointment, Tue 2pm. Added drive time 1:30-2:00 and 3:00-3:30.&quot;</li><li>If relevant to partner, add invite</li></ul>\n<p>4. Detect promise/commitment patterns:</p>\n<ul><li>&quot;I&#39;ll send that over by Friday&quot;</li><li>&quot;Let&#39;s do dinner next week&quot;</li></ul>\n<p>→ Create calendar hold or reminder</p>\n<p>```</p>\n<p>### 3. Household Inventory</p>\n<p>```text</p>\n<h4>Pantry Tracking</h4>\n<p>Maintain ~/household/inventory.json with:</p>\n<ul><li>Item name, quantity, location (fridge/pantry/basement)</li><li>Last updated timestamp</li><li>Low-stock threshold</li></ul>\n<p>Update methods:</p>\n<ul><li>Photo: User sends photo of fridge/pantry → vision model extracts items</li><li>Text: &quot;We&#39;re out of eggs&quot; / &quot;Bought 2 gallons of milk&quot;</li><li>Receipt: Photo of grocery receipt → update inventory</li></ul>\n<p>Query: Either partner can ask via Telegram:</p>\n<ul><li>&quot;Do we have butter?&quot; → Check inventory, respond with location and quantity</li><li>&quot;What&#39;s running low?&quot; → List items below threshold</li><li>&quot;Generate grocery list&quot; → Compile low-stock items + any recipe ingredients needed</li></ul>\n<p>```</p>\n<h4>Key Insights</h4>\n<ul><li>**Ambient &gt; active**: The biggest unlock is the agent acting without being asked. Detecting an appointment in a text message and creating a calendar event with driving buffers — &quot;I didn&#39;t ask it to do that. It just knew that&#39;s what I&#39;d want.&quot;</li><li>**Mac Mini is the sweet spot**: This use case benefits heavily from running on a home Mac Mini — iMessage integration, Apple Calendar, and always-on availability</li><li>**Start read-only**: Begin with calendar reading and message monitoring before enabling write actions (creating events, sending messages)</li><li>**Shared Telegram channel**: Gives both partners visibility into what the agent is doing — builds trust and catches errors early</li><li>**Photo input is underrated**: Snapping a photo of a school calendar PDF or freezer contents is faster than typing — and the vision model handles it well</li></ul>\n<h4>Inspired By</h4>\n<p>This use case combines several community patterns:</p>\n<ul><li>**Calendar aggregation**: Described by HN user `angiolillo` in [a Hacker News discussion](https://news.ycombinator.com/item?id=46872465), who detailed the pain of checking work, personal, family, and kids&#39; school calendars separately each morning.</li><li>**Ambient message monitoring**: Documented by [Sparkry AI](https://sparkryai.substack.com/p/24-hours-with-openclaw-the-ai-setup) — when a wife received a dental appointment text, OpenClaw automatically created a calendar event with 30-minute driving buffers, without being asked. Also confirmed on the [OpenClaw Showcase](https://openclaw.ai/showcase) where `@theaaron` called chat-based calendar management &quot;one of the best uses of an LLM I&#39;ve ever experienced.&quot;</li><li>**Household coordination**: Brandon Wang&#39;s [Clawdbot &quot;Linguini&quot;](https://brandon.wang/2026/clawdbot) running on a Mac Mini at home — handling text message follow-ups, creating calendar events from photos, tracking Airbnb prices, processing freezer inventory photos, and coordinating household logistics via iMessage and Slack.</li><li>**Pantry tracking**: Multiple HN users discussed the value (and challenge) of maintaining household inventory, with `dns_snek` noting: &quot;I forget where I put things down 5 seconds ago... It&#39;s genuinely a big problem for me because I let things expire.&quot;</li></ul>\n<h4>Related Links</h4>\n<ul><li>[OpenClaw iMessage Skill](https://github.com/openclaw/openclaw)</li><li>[Google Calendar API](https://developers.google.com/calendar)</li><li>[Apple Calendar (EventKit)](https://developer.apple.com/documentation/eventkit)</li><li>[OpenClaw Showcase — Calendar Testimonials](https://openclaw.ai/showcase)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/family-calendar-household-assistant.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/family-calendar-household-assistant.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/family-calendar-household-assistant.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-polymarket-autopilot",
      "slug": "polymarket-autopilot",
      "title": "Polymarket Autopilot: Automated Paper Trading",
      "category": "productivity",
      "tags": [
        "polymarket",
        "autopilot"
      ],
      "rating": 90,
      "summary": "Manually monitoring prediction markets for arbitrage opportunities and executing trades is time-consuming and requires constant attention. You want to test and refine trading strategies without risking real capital.",
      "content": "<h3>Polymarket Autopilot: Automated Paper Trading</h3>\n<p>Manually monitoring prediction markets for arbitrage opportunities and executing trades is time-consuming and requires constant attention. You want to test and refine trading strategies without risking real capital.</p>\n<p>This workflow automates paper trading on Polymarket with custom strategies:</p>\n<p>• Monitors market data via API (prices, volume, spreads)</p>\n<p>• Executes paper trades using TAIL (trend-following) and BONDING (contrarian) strategies</p>\n<p>• Tracks portfolio performance, P&amp;L, and win rate</p>\n<p>• Delivers daily summaries to Discord with trade logs and insights</p>\n<p>• Learns from patterns: adjusts strategy parameters based on backtesting results</p>\n<h4>Pain Point</h4>\n<p>Prediction markets move fast. Manual trading means missing opportunities, emotional decisions, and difficulty tracking what works. Testing strategies with real money risks losses before you understand market behavior.</p>\n<h4>What It Does</h4>\n<p>The autopilot continuously scans Polymarket for opportunities, simulates trades using configurable strategies, and logs everything for analysis. You wake up to a summary of what it &quot;traded&quot; overnight, what worked, and what didn&#39;t.</p>\n<p>Example strategies:</p>\n<ul><li>**TAIL**: Follow trends when volume spikes and momentum is clear</li><li>**BONDING**: Buy contrarian positions when markets overreact to news</li><li>**SPREAD**: Identify mispriced markets with arbitrage potential</li></ul>\n<h4>Skills Needed</h4>\n<ul><li>`web_search` or `web_fetch` (for Polymarket API data)</li><li>`postgres` or SQLite for trade logs and portfolio tracking</li><li>Discord integration for daily reports</li><li>Cron jobs for continuous monitoring</li><li>Sub-agent spawning for parallel market analysis</li></ul>\n<h4>How to Set it Up</h4>\n<p>1. Set up a database for paper trading:</p>\n<p>```sql</p>\n<p>CREATE TABLE paper_trades (</p>\n<p>id SERIAL PRIMARY KEY,</p>\n<p>market_id TEXT,</p>\n<p>market_name TEXT,</p>\n<p>strategy TEXT,</p>\n<p>direction TEXT,</p>\n<p>entry_price DECIMAL,</p>\n<p>exit_price DECIMAL,</p>\n<p>quantity DECIMAL,</p>\n<p>pnl DECIMAL,</p>\n<p>timestamp TIMESTAMPTZ DEFAULT NOW()</p>\n<p>);</p>\n<p>CREATE TABLE portfolio (</p>\n<p>id SERIAL PRIMARY KEY,</p>\n<p>total_value DECIMAL,</p>\n<p>cash DECIMAL,</p>\n<p>positions JSONB,</p>\n<p>updated_at TIMESTAMPTZ DEFAULT NOW()</p>\n<p>);</p>\n<p>```</p>\n<p>2. Create a Discord channel for updates (e.g., #polymarket-autopilot).</p>\n<p>3. Prompt OpenClaw:</p>\n<p>```text</p>\n<p>You are a Polymarket paper trading autopilot. Run continuously (via cron every 15 minutes):</p>\n<p>1. Fetch current market data from Polymarket API</p>\n<p>2. Analyze opportunities using these strategies:</p>\n<ul><li>TAIL: Follow strong trends (&gt;60% probability + volume spike)</li><li>BONDING: Contrarian plays on overreactions (sudden drops &gt;10% on news)</li><li>SPREAD: Arbitrage when YES+NO &gt; 1.05</li></ul>\n<p>3. Execute paper trades in the database (starting capital: $10,000)</p>\n<p>4. Track portfolio state and update positions</p>\n<p>Every morning at 8 AM, post a summary to Discord #polymarket-autopilot:</p>\n<ul><li>Yesterday&#39;s trades (entry/exit prices, P&amp;L)</li><li>Current portfolio value and open positions</li><li>Win rate and strategy performance</li><li>Market insights and recommendations</li></ul>\n<p>Use sub-agents to analyze multiple markets in parallel during high-volume periods.</p>\n<p>Never use real money. This is paper trading only.</p>\n<p>```</p>\n<p>4. Iterate on strategies based on performance. Adjust thresholds, add new strategies, backtest historical data.</p>\n<h4>Related Links</h4>\n<ul><li>[Polymarket API](https://docs.polymarket.com/)</li><li>[Paper Trading Best Practices](https://www.investopedia.com/articles/trading/11/paper-trading.asp)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/polymarket-autopilot.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/polymarket-autopilot.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/polymarket-autopilot.md"
    },
    {
      "id": "community-usecase-openclaw-main-update-clawdbot",
      "slug": "update-clawdbot",
      "title": "Clawdbot Upstream Sync Workflow",
      "category": "workflow",
      "tags": [
        "update",
        "clawdbot"
      ],
      "rating": 90,
      "summary": "Update Clawdbot from upstream when branch has diverged (ahead/behind)",
      "content": "<h3>Clawdbot Upstream Sync Workflow</h3>\n<p>Use this workflow when your fork has diverged from upstream (e.g., &quot;18 commits ahead, 29 commits behind&quot;).</p>\n<h4>Quick Reference</h4>\n<p>```bash</p>\n<h3>Check divergence status</h3>\n<p>git fetch upstream &amp;&amp; git rev-list --left-right --count main...upstream/main</p>\n<h3>Full sync (rebase preferred)</h3>\n<p>git fetch upstream &amp;&amp; git rebase upstream/main &amp;&amp; pnpm install &amp;&amp; pnpm build &amp;&amp; ./scripts/restart-mac.sh</p>\n<h3>Check for Swift 6.2 issues after sync</h3>\n<p>grep -r &quot;FileManager\\.default\\|Thread\\.isMainThread&quot; src/ apps/ --include=&quot;*.swift&quot;</p>\n<p>```</p>\n<p>---</p>\n<h4>Step 1: Assess Divergence</h4>\n<p>```bash</p>\n<p>git fetch upstream</p>\n<p>git log --oneline --left-right main...upstream/main | head -20</p>\n<p>```</p>\n<p>This shows:</p>\n<ul><li>`&lt;` = your local commits (ahead)</li><li>`&gt;` = upstream commits you&#39;re missing (behind)</li></ul>\n<p>**Decision point:**</p>\n<ul><li>Few local commits, many upstream → **Rebase** (cleaner history)</li><li>Many local commits or shared branch → **Merge** (preserves history)</li></ul>\n<p>---</p>\n<h4>Step 2A: Rebase Strategy (Preferred)</h4>\n<p>Replays your commits on top of upstream. Results in linear history.</p>\n<p>```bash</p>\n<h3>Ensure working tree is clean</h3>\n<p>git status</p>\n<h3>Rebase onto upstream</h3>\n<p>git rebase upstream/main</p>\n<p>```</p>\n<p>### Handling Rebase Conflicts</p>\n<p>```bash</p>\n<h3>When conflicts occur:</h3>\n<h3>1. Fix conflicts in the listed files</h3>\n<h3>2. Stage resolved files</h3>\n<p>git add &lt;resolved-files&gt;</p>\n<h3>3. Continue rebase</h3>\n<p>git rebase --continue</p>\n<h3>If a commit is no longer needed (already in upstream):</h3>\n<p>git rebase --skip</p>\n<h3>To abort and return to original state:</h3>\n<p>git rebase --abort</p>\n<p>```</p>\n<p>### Common Conflict Patterns</p>\n<p>| File             | Resolution                                       |</p>\n<p>| ---------------- | ------------------------------------------------ |</p>\n<p>| `package.json`   | Take upstream deps, keep local scripts if needed |</p>\n<p>| `pnpm-lock.yaml` | Accept upstream, regenerate with `pnpm install`  |</p>\n<p>| `*.patch` files  | Usually take upstream version                    |</p>\n<p>| Source files     | Merge logic carefully, prefer upstream structure |</p>\n<p>---</p>\n<h4>Step 2B: Merge Strategy (Alternative)</h4>\n<p>Preserves all history with a merge commit.</p>\n<p>```bash</p>\n<p>git merge upstream/main --no-edit</p>\n<p>```</p>\n<p>Resolve conflicts same as rebase, then:</p>\n<p>```bash</p>\n<p>git add &lt;resolved-files&gt;</p>\n<p>git commit</p>\n<p>```</p>\n<p>---</p>\n<h4>Step 3: Rebuild Everything</h4>\n<p>After sync completes:</p>\n<p>```bash</p>\n<h3>Install dependencies (regenerates lock if needed)</h3>\n<p>pnpm install</p>\n<h3>Build TypeScript</h3>\n<p>pnpm build</p>\n<h3>Build UI assets</h3>\n<p>pnpm ui:build</p>\n<h3>Run diagnostics</h3>\n<p>pnpm clawdbot doctor</p>\n<p>```</p>\n<p>---</p>\n<h4>Step 4: Rebuild macOS App</h4>\n<p>```bash</p>\n<h3>Full rebuild, sign, and launch</h3>\n<p>./scripts/restart-mac.sh</p>\n<h3>Or just package without restart</h3>\n<p>pnpm mac:package</p>\n<p>```</p>\n<p>### Install to /Applications</p>\n<p>```bash</p>\n<h3>Kill running app</h3>\n<p>pkill -x &quot;Clawdbot&quot; || true</p>\n<h3>Move old version</h3>\n<p>mv /Applications/Clawdbot.app /tmp/Clawdbot-backup.app</p>\n<h3>Install new build</h3>\n<p>cp -R dist/Clawdbot.app /Applications/</p>\n<h3>Launch</h3>\n<p>open /Applications/Clawdbot.app</p>\n<p>```</p>\n<p>---</p>\n<h4>Step 4A: Verify macOS App &amp; Agent</h4>\n<p>After rebuilding the macOS app, always verify it works correctly:</p>\n<p>```bash</p>\n<h3>Check gateway health</h3>\n<p>pnpm clawdbot health</p>\n<h3>Verify no zombie processes</h3>\n<p>ps aux | grep -E &quot;(clawdbot|gateway)&quot; | grep -v grep</p>\n<h3>Test agent functionality by sending a verification message</h3>\n<p>pnpm clawdbot agent --message &quot;Verification: macOS app rebuild successful - agent is responding.&quot; --session-id YOUR_TELEGRAM_SESSION_ID</p>\n<h3>Confirm the message was received on Telegram</h3>\n<h3>(Check your Telegram chat with the bot)</h3>\n<p>```</p>\n<p>**Important:** Always wait for the Telegram verification message before proceeding. If the agent doesn&#39;t respond, troubleshoot the gateway or model configuration before pushing.</p>\n<p>---</p>\n<h4>Step 5: Handle Swift/macOS Build Issues (Common After Upstream Sync)</h4>\n<p>Upstream updates may introduce Swift 6.2 / macOS 26 SDK incompatibilities. Use analyze-mode for systematic debugging:</p>\n<p>### Analyze-Mode Investigation</p>\n<p>```bash</p>\n<h3>Gather context with parallel agents</h3>\n<p>morph-mcp_warpgrep_codebase_search search_string=&quot;Find deprecated FileManager.default and Thread.isMainThread usages in Swift files&quot; repo_path=&quot;/Volumes/Main SSD/Developer/clawdis&quot;</p>\n<p>morph-mcp_warpgrep_codebase_search search_string=&quot;Locate Peekaboo submodule and macOS app Swift files with concurrency issues&quot; repo_path=&quot;/Volumes/Main SSD/Developer/clawdis&quot;</p>\n<p>```</p>\n<p>### Common Swift 6.2 Fixes</p>\n<p>**FileManager.default Deprecation:**</p>\n<p>```bash</p>\n<h3>Search for deprecated usage</h3>\n<p>grep -r &quot;FileManager\\.default&quot; src/ apps/ --include=&quot;*.swift&quot;</p>\n<h3>Replace with proper initialization</h3>\n<h3>OLD: FileManager.default</h3>\n<h3>NEW: FileManager()</h3>\n<p>```</p>\n<p>**Thread.isMainThread Deprecation:**</p>\n<p>```bash</p>\n<h3>Search for deprecated usage</h3>\n<p>grep -r &quot;Thread\\.isMainThread&quot; src/ apps/ --include=&quot;*.swift&quot;</p>\n<h3>Replace with modern concurrency check</h3>\n<h3>OLD: Thread.isMainThread</h3>\n<h3>NEW: await MainActor.run { ... } or DispatchQueue.main.sync { ... }</h3>\n<p>```</p>\n<p>### Peekaboo Submodule Fixes</p>\n<p>```bash</p>\n<h3>Check Peekaboo for concurrency issues</h3>\n<p>cd src/canvas-host/a2ui</p>\n<p>grep -r &quot;Thread\\.isMainThread\\|FileManager\\.default&quot; . --include=&quot;*.swift&quot;</p>\n<h3>Fix and rebuild submodule</h3>\n<p>cd /Volumes/Main SSD/Developer/clawdis</p>\n<p>pnpm canvas:a2ui:bundle</p>\n<p>```</p>\n<p>### macOS App Concurrency Fixes</p>\n<p>```bash</p>\n<h3>Check macOS app for issues</h3>\n<p>grep -r &quot;Thread\\.isMainThread\\|FileManager\\.default&quot; apps/macos/ --include=&quot;*.swift&quot;</p>\n<h3>Clean and rebuild after fixes</h3>\n<p>cd apps/macos &amp;&amp; rm -rf .build .swiftpm</p>\n<p>./scripts/restart-mac.sh</p>\n<p>```</p>\n<p>### Model Configuration Updates</p>\n<p>If upstream introduced new model configurations:</p>\n<p>```bash</p>\n<h3>Check for OpenRouter API key requirements</h3>\n<p>grep -r &quot;openrouter\\|OPENROUTER&quot; src/ --include=&quot;*.ts&quot; --include=&quot;*.js&quot;</p>\n<h3>Update clawdbot.json with fallback chains</h3>\n<h3>Add model fallback configurations as needed</h3>\n<p>```</p>\n<p>---</p>\n<h4>Step 6: Verify &amp; Push</h4>\n<p>```bash</p>\n<h3>Verify everything works</h3>\n<p>pnpm clawdbot health</p>\n<p>pnpm test</p>\n<h3>Push (force required after rebase)</h3>\n<p>git push origin main --force-with-lease</p>\n<h3>Or regular push after merge</h3>\n<p>git push origin main</p>\n<p>```</p>\n<p>---</p>\n<h4>Troubleshooting</h4>\n<p>### Build Fails After Sync</p>\n<p>```bash</p>\n<h3>Clean and rebuild</h3>\n<p>rm -rf node_modules dist</p>\n<p>pnpm install</p>\n<p>pnpm build</p>\n<p>```</p>\n<p>### Type Errors (Bun/Node Incompatibility)</p>\n<p>Common issue: `fetch.preconnect` type mismatch. Fix by using `FetchLike` type instead of `typeof fetch`.</p>\n<p>### macOS App Crashes on Launch</p>\n<p>Usually resource bundle mismatch. Full rebuild required:</p>\n<p>```bash</p>\n<p>cd apps/macos &amp;&amp; rm -rf .build .swiftpm</p>\n<p>./scripts/restart-mac.sh</p>\n<p>```</p>\n<p>### Patch Failures</p>\n<p>```bash</p>\n<h3>Check patch status</h3>\n<p>pnpm install 2&gt;&amp;1 | grep -i patch</p>\n<h3>If patches fail, they may need updating for new dep versions</h3>\n<h3>Check patches/ directory against package.json patchedDependencies</h3>\n<p>```</p>\n<p>### Swift 6.2 / macOS 26 SDK Build Failures</p>\n<p>**Symptoms:** Build fails with deprecation warnings about `FileManager.default` or `Thread.isMainThread`</p>\n<p>**Search-Mode Investigation:**</p>\n<p>```bash</p>\n<h3>Exhaustive search for deprecated APIs</h3>\n<p>morph-mcp_warpgrep_codebase_search search_string=&quot;Find all Swift files using deprecated FileManager.default or Thread.isMainThread&quot; repo_path=&quot;/Volumes/Main SSD/Developer/clawdis&quot;</p>\n<p>```</p>\n<p>**Quick Fix Commands:**</p>\n<p>```bash</p>\n<h3>Find all affected files</h3>\n<p>find . -name &quot;*.swift&quot; -exec grep -l &quot;FileManager\\.default\\|Thread\\.isMainThread&quot; {} \\;</p>\n<h3>Replace FileManager.default with FileManager()</h3>\n<p>find . -name &quot;*.swift&quot; -exec sed -i &#39;&#39; &#39;s/FileManager\\.default/FileManager()/g&#39; {} \\;</p>\n<h3>For Thread.isMainThread, need manual review of each usage</h3>\n<p>grep -rn &quot;Thread\\.isMainThread&quot; --include=&quot;*.swift&quot; .</p>\n<p>```</p>\n<p>**Rebuild After Fixes:**</p>\n<p>```bash</p>\n<h3>Clean all build artifacts</h3>\n<p>rm -rf apps/macos/.build apps/macos/.swiftpm</p>\n<p>rm -rf src/canvas-host/a2ui/.build</p>\n<h3>Rebuild Peekaboo bundle</h3>\n<p>pnpm canvas:a2ui:bundle</p>\n<h3>Full macOS rebuild</h3>\n<p>./scripts/restart-mac.sh</p>\n<p>```</p>\n<p>---</p>\n<h4>Automation Script</h4>\n<p>Save as `scripts/sync-upstream.sh`:</p>\n<p>```bash</p>\n<p>#!/usr/bin/env bash</p>\n<p>set -euo pipefail</p>\n<p>echo &quot;==&gt; Fetching upstream...&quot;</p>\n<p>git fetch upstream</p>\n<p>echo &quot;==&gt; Current divergence:&quot;</p>\n<p>git rev-list --left-right --count main...upstream/main</p>\n<p>echo &quot;==&gt; Rebasing onto upstream/main...&quot;</p>\n<p>git rebase upstream/main</p>\n<p>echo &quot;==&gt; Installing dependencies...&quot;</p>\n<p>pnpm install</p>\n<p>echo &quot;==&gt; Building...&quot;</p>\n<p>pnpm build</p>\n<p>pnpm ui:build</p>\n<p>echo &quot;==&gt; Running doctor...&quot;</p>\n<p>pnpm clawdbot doctor</p>\n<p>echo &quot;==&gt; Rebuilding macOS app...&quot;</p>\n<p>./scripts/restart-mac.sh</p>\n<p>echo &quot;==&gt; Verifying gateway health...&quot;</p>\n<p>pnpm clawdbot health</p>\n<p>echo &quot;==&gt; Checking for Swift 6.2 compatibility issues...&quot;</p>\n<p>if grep -r &quot;FileManager\\.default\\|Thread\\.isMainThread&quot; src/ apps/ --include=&quot;*.swift&quot; --quiet; then</p>\n<p>echo &quot;⚠️  Found potential Swift 6.2 deprecated API usage&quot;</p>\n<p>echo &quot;   Run manual fixes or use analyze-mode investigation&quot;</p>\n<p>else</p>\n<p>echo &quot;✅ No obvious Swift deprecation issues found&quot;</p>\n<p>fi</p>\n<p>echo &quot;==&gt; Testing agent functionality...&quot;</p>\n<h3>Note: Update YOUR_TELEGRAM_SESSION_ID with actual session ID</h3>\n<p>pnpm clawdbot agent --message &quot;Verification: Upstream sync and macOS rebuild completed successfully.&quot; --session-id YOUR_TELEGRAM_SESSION_ID || echo &quot;Warning: Agent test failed - check Telegram for verification message&quot;</p>\n<p>echo &quot;==&gt; Done! Check Telegram for verification message, then run &#39;git push --force-with-lease&#39; when ready.&quot;</p>\n<p>```</p>",
      "source": "openclaw-main",
      "sourceDetail": "community/playbooks/update_clawdbot.md",
      "sourcePath": "openclaw-main/.agent/workflows/update_clawdbot.md",
      "url": "https://github.com/openclaw/openclaw/blob/main/.agent/workflows/update_clawdbot.md"
    },
    {
      "id": "community-usecase-openclaw-main-pr-workflow",
      "slug": "pr-workflow",
      "title": "PR Workflow for Maintainers",
      "category": "workflow",
      "tags": [
        "workflow"
      ],
      "rating": 90,
      "summary": "Please read this in full and do not skip sections.",
      "content": "<h3>PR Workflow for Maintainers</h3>\n<p>Please read this in full and do not skip sections.</p>\n<p>This is the single source of truth for the maintainer PR workflow.</p>\n<h4>Triage order</h4>\n<p>Process PRs **oldest to newest**. Older PRs are more likely to have merge conflicts and stale dependencies; resolving them first keeps the queue healthy and avoids snowballing rebase pain.</p>\n<h4>Working rule</h4>\n<p>Skills execute workflow. Maintainers provide judgment.</p>\n<p>Always pause between skills to evaluate technical direction, not just command success.</p>\n<p>These three skills must be used in order:</p>\n<p>1. `review-pr` — review only, produce findings</p>\n<p>2. `prepare-pr` — rebase, fix, gate, push to PR head branch</p>\n<p>3. `merge-pr` — squash-merge, verify MERGED state, clean up</p>\n<p>They are necessary, but not sufficient. Maintainers must steer between steps and understand the code before moving forward.</p>\n<p>Treat PRs as reports first, code second.</p>\n<p>If submitted code is low quality, ignore it and implement the best solution for the problem.</p>\n<p>Do not continue if you cannot verify the problem is real or test the fix.</p>\n<h4>Script-first contract</h4>\n<p>Skill runs should invoke these wrappers automatically. You only need to run them manually when debugging or doing an explicit script-only run:</p>\n<ul><li>`scripts/pr-review &lt;PR&gt;`</li><li>`scripts/pr review-checkout-main &lt;PR&gt;` or `scripts/pr review-checkout-pr &lt;PR&gt;` while reviewing</li><li>`scripts/pr review-guard &lt;PR&gt;` before writing review outputs</li><li>`scripts/pr review-validate-artifacts &lt;PR&gt;` after writing outputs</li><li>`scripts/pr-prepare init &lt;PR&gt;`</li><li>`scripts/pr-prepare validate-commit &lt;PR&gt;`</li><li>`scripts/pr-prepare gates &lt;PR&gt;`</li><li>`scripts/pr-prepare push &lt;PR&gt;`</li><li>Optional one-shot prepare: `scripts/pr-prepare run &lt;PR&gt;`</li><li>`scripts/pr-merge &lt;PR&gt;` (verify-only; short form remains backward compatible)</li><li>`scripts/pr-merge verify &lt;PR&gt;` (verify-only)</li><li>Optional one-shot merge: `scripts/pr-merge run &lt;PR&gt;`</li></ul>\n<p>These wrappers run shared preflight checks and generate deterministic artifacts. They are designed to work from repo root or PR worktree cwd.</p>\n<h4>Required artifacts</h4>\n<ul><li>`.local/pr-meta.json` and `.local/pr-meta.env` from review init.</li><li>`.local/review.md` and `.local/review.json` from review output.</li><li>`.local/prep-context.env` and `.local/prep.md` from prepare.</li><li>`.local/prep.env` from prepare completion.</li></ul>\n<h4>Structured review handoff</h4>\n<p>`review-pr` must write `.local/review.json`.</p>\n<p>In normal skill runs this is handled automatically. Use `scripts/pr review-artifacts-init &lt;PR&gt;` and `scripts/pr review-tests &lt;PR&gt; ...` manually only for debugging or explicit script-only runs.</p>\n<p>Minimum schema:</p>\n<p>```json</p>\n<p>{</p>\n<p>&quot;recommendation&quot;: &quot;READY FOR /prepare-pr&quot;,</p>\n<p>&quot;findings&quot;: [</p>\n<p>{</p>\n<p>&quot;id&quot;: &quot;F1&quot;,</p>\n<p>&quot;severity&quot;: &quot;IMPORTANT&quot;,</p>\n<p>&quot;title&quot;: &quot;Missing changelog entry&quot;,</p>\n<p>&quot;area&quot;: &quot;CHANGELOG.md&quot;,</p>\n<p>&quot;fix&quot;: &quot;Add a Fixes entry for PR #&lt;PR&gt;&quot;</p>\n<p>}</p>\n<p>],</p>\n<p>&quot;tests&quot;: {</p>\n<p>&quot;ran&quot;: [&quot;pnpm test -- ...&quot;],</p>\n<p>&quot;gaps&quot;: [&quot;...&quot;],</p>\n<p>&quot;result&quot;: &quot;pass&quot;</p>\n<p>}</p>\n<p>}</p>\n<p>```</p>\n<p>`prepare-pr` resolves all `BLOCKER` and `IMPORTANT` findings from this file.</p>\n<h4>Coding Agent</h4>\n<p>Use ChatGPT 5.3 Codex High. Fall back to 5.2 Codex High or 5.3 Codex Medium if necessary.</p>\n<h4>PR quality bar</h4>\n<ul><li>Do not trust PR code by default.</li><li>Do not merge changes you cannot validate with a reproducible problem and a tested fix.</li><li>Keep types strict. Do not use `any` in implementation code.</li><li>Keep external-input boundaries typed and validated, including CLI input, environment variables, network payloads, and tool output.</li><li>Keep implementations properly scoped. Fix root causes, not local symptoms.</li><li>Identify and reuse canonical sources of truth so behavior does not drift across the codebase.</li><li>Harden changes. Always evaluate security impact and abuse paths.</li><li>Understand the system before changing it. Never make the codebase messier just to clear a PR queue.</li></ul>\n<h4>Rebase and conflict resolution</h4>\n<p>Before any substantive review or prep work, **always rebase the PR branch onto current `main` and resolve merge conflicts first**. A PR that cannot cleanly rebase is not ready for review — fix conflicts before evaluating correctness.</p>\n<ul><li>During `prepare-pr`: rebase onto `main` as the first step, before fixing findings or running gates.</li><li>If conflicts are complex or touch areas you do not understand, stop and escalate.</li><li>Prefer **rebase** for linear history; **squash** when commit history is messy or unhelpful.</li></ul>\n<h4>Commit and changelog rules</h4>\n<ul><li>In normal `prepare-pr` runs, commits are created via `scripts/committer &quot;&lt;msg&gt;&quot; &lt;file...&gt;`. Use it manually only when operating outside the skill flow; avoid manual `git add`/`git commit` so staging stays scoped.</li><li>Follow concise, action-oriented commit messages (e.g., `CLI: add verbose flag to send`).</li><li>During `prepare-pr`, use concise, action-oriented subjects **without** PR numbers or thanks; reserve `(#&lt;PR&gt;) thanks @&lt;pr-author&gt;` for the final merge/squash commit.</li><li>Group related changes; avoid bundling unrelated refactors.</li><li>Changelog workflow: keep the latest released version at the top (no `Unreleased`); after publishing, bump the version and start a new top section.</li><li>When working on a PR: add a changelog entry with the PR number and thank the contributor (mandatory in this workflow).</li><li>When working on an issue: reference the issue in the changelog entry.</li><li>In this workflow, changelog is always required even for internal/test-only changes.</li></ul>\n<h4>Gate policy</h4>\n<p>In fresh worktrees, dependency bootstrap is handled by wrappers before local gates. Manual equivalent:</p>\n<p>```sh</p>\n<p>pnpm install --frozen-lockfile</p>\n<p>```</p>\n<p>Gate set:</p>\n<ul><li>Always: `pnpm build`, `pnpm check`</li><li>`pnpm test` required unless high-confidence docs-only criteria pass.</li></ul>\n<h4>Co-contributor and clawtributors</h4>\n<ul><li>If we squash, add the PR author as a co-contributor in the commit body using a `Co-authored-by:` trailer.</li><li>When maintainer prepares and merges the PR, add the maintainer as an additional `Co-authored-by:` trailer too.</li><li>Avoid `--auto` merges for maintainer landings. Merge only after checks are green so the maintainer account is the actor and attribution is deterministic.</li><li>For squash merges, set `--author-email` to a reviewer-owned email with fallback candidates; if merge fails due to author-email validation, retry once with the next candidate.</li><li>If you review a PR and later do work on it, land via merge/squash (no direct-main commits) and always add the PR author as a co-contributor.</li><li>When merging a PR: leave a PR comment that explains exactly what we did, include the SHA hashes, and record the comment URL in the final report.</li><li>Manual post-merge step for new contributors: run `bun scripts/update-clawtributors.ts` to add their avatar to the README &quot;Thanks to all clawtributors&quot; list, then commit the regenerated README.</li></ul>\n<h4>Review mode vs landing mode</h4>\n<ul><li>**Review mode (PR link only):** read `gh pr view`/`gh pr diff`; **do not** switch branches; **do not** change code.</li><li>**Landing mode (exception path):** use only when normal `review-pr -&gt; prepare-pr -&gt; merge-pr` flow cannot safely preserve attribution or cannot satisfy branch protection. Create an integration branch from `main`, bring in PR commits (**prefer rebase** for linear history; **merge allowed** when complexity/conflicts make it safer), apply fixes, add changelog (+ thanks + PR #), run full gate **locally before committing** (`pnpm build &amp;&amp; pnpm check &amp;&amp; pnpm test`), commit, merge back to `main`, then `git switch main` (never stay on a topic branch after landing). Important: the contributor needs to be in the git graph after this!</li></ul>\n<h4>Pre-review safety checks</h4>\n<ul><li>Before starting a review when a GH Issue/PR is pasted: `review-pr`/`scripts/pr-review` should create and use an isolated `.worktrees/pr-&lt;PR&gt;` checkout from `origin/main` automatically. Do not require a clean main checkout, and do not run `git pull` in a dirty main checkout.</li><li>PR review calls: prefer a single `gh pr view --json ...` to batch metadata/comments; run `gh pr diff` only when needed.</li><li>PRs should summarize scope, note testing performed, and mention any user-facing changes or new flags.</li><li>Read `docs/help/submitting-a-pr.md` ([Submitting a PR](https://docs.openclaw.ai/help/submitting-a-pr)) for what we expect from contributors.</li></ul>\n<h4>Unified workflow</h4>\n<p>Entry criteria:</p>\n<ul><li>PR URL/number is known.</li><li>Problem statement is clear enough to attempt reproduction.</li><li>A realistic verification path exists (tests, integration checks, or explicit manual validation).</li></ul>\n<p>### 1) `review-pr`</p>\n<p>Purpose:</p>\n<ul><li>Review only: correctness, value, security risk, tests, docs, and changelog impact.</li><li>Produce structured findings and a recommendation.</li></ul>\n<p>Expected output:</p>\n<ul><li>Recommendation: ready, needs work, needs discussion, or close.</li><li>`.local/review.md` with actionable findings.</li></ul>\n<p>Maintainer checkpoint before `prepare-pr`:</p>\n<p>```</p>\n<p>What problem are they trying to solve?</p>\n<p>What is the most optimal implementation?</p>\n<p>Can we fix up everything?</p>\n<p>Do we have any questions?</p>\n<p>```</p>\n<p>Stop and escalate instead of continuing if:</p>\n<ul><li>The problem cannot be reproduced or confirmed.</li><li>The proposed PR scope does not match the stated problem.</li><li>The design introduces unresolved security or trust-boundary concerns.</li></ul>\n<p>### 2) `prepare-pr`</p>\n<p>Purpose:</p>\n<ul><li>Make the PR merge-ready on its head branch.</li><li>Rebase onto current `main` first, then fix blocker/important findings, then run gates.</li><li>In fresh worktrees, bootstrap dependencies before local gates (`pnpm install --frozen-lockfile`).</li></ul>\n<p>Expected output:</p>\n<ul><li>Updated code and tests on the PR head branch.</li><li>`.local/prep.md` with changes, verification, and current HEAD SHA.</li><li>Final status: `PR is ready for /merge-pr`.</li></ul>\n<p>Maintainer checkpoint before `merge-pr`:</p>\n<p>```</p>\n<p>Is this the most optimal implementation?</p>\n<p>Is the code properly scoped?</p>\n<p>Is the code properly reusing existing logic in the codebase?</p>\n<p>Is the code properly typed?</p>\n<p>Is the code hardened?</p>\n<p>Do we have enough tests?</p>\n<p>Do we need regression tests?</p>\n<p>Are tests using fake timers where appropriate? (e.g., debounce/throttle, retry backoff, timeout branches, delayed callbacks, polling loops)</p>\n<p>Do not add performative tests, ensure tests are real and there are no regressions.</p>\n<p>Do you see any follow-up refactors we should do?</p>\n<p>Did any changes introduce any potential security vulnerabilities?</p>\n<p>Take your time, fix it properly, refactor if necessary.</p>\n<p>```</p>\n<p>Stop and escalate instead of continuing if:</p>\n<ul><li>You cannot verify behavior changes with meaningful tests or validation.</li><li>Fixing findings requires broad architecture changes outside safe PR scope.</li><li>Security hardening requirements remain unresolved.</li></ul>\n<p>### 3) `merge-pr`</p>\n<p>Purpose:</p>\n<ul><li>Merge only after review and prep artifacts are present and checks are green.</li><li>Use deterministic squash merge flow (`--match-head-commit` + explicit subject/body with co-author trailer), then verify the PR ends in `MERGED` state.</li><li>If no required checks are configured on the PR, treat that as acceptable and continue after branch-up-to-date validation.</li></ul>\n<p>Go or no-go checklist before merge:</p>\n<ul><li>All BLOCKER and IMPORTANT findings are resolved.</li><li>Verification is meaningful and regression risk is acceptably low.</li><li>Changelog is updated (mandatory) and docs are updated when required.</li><li>Required CI checks are green and the branch is not behind `main`.</li></ul>\n<p>Expected output:</p>\n<ul><li>Successful merge commit and recorded merge SHA.</li><li>Worktree cleanup after successful merge.</li><li>Comment on PR indicating merge was successful.</li></ul>\n<p>Maintainer checkpoint after merge:</p>\n<ul><li>Were any refactors intentionally deferred and now need follow-up issue(s)?</li><li>Did this reveal broader architecture or test gaps we should address?</li><li>Run `bun scripts/update-clawtributors.ts` if the contributor is new.</li></ul>",
      "source": "openclaw-main",
      "sourceDetail": "community/playbooks/PR_WORKFLOW.md",
      "sourcePath": "openclaw-main/.agents/skills/PR_WORKFLOW.md",
      "url": "https://github.com/openclaw/openclaw/blob/main/.agents/skills/PR_WORKFLOW.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-autonomous-project-management",
      "slug": "autonomous-project-management",
      "title": "Autonomous Project Management with Subagents",
      "category": "agents",
      "tags": [
        "autonomous",
        "project",
        "management"
      ],
      "rating": 89,
      "summary": "Managing complex projects with multiple parallel workstreams is exhausting. You end up context-switching constantly, tracking status across tools, and manually coordinating handoffs.",
      "content": "<h3>Autonomous Project Management with Subagents</h3>\n<p>Managing complex projects with multiple parallel workstreams is exhausting. You end up context-switching constantly, tracking status across tools, and manually coordinating handoffs.</p>\n<p>This use case implements a decentralized project management pattern where subagents work autonomously on tasks, coordinating through shared state files rather than a central orchestrator.</p>\n<h4>Pain Point</h4>\n<p>Traditional orchestrator patterns create bottlenecks—the main agent becomes a traffic cop. For complex projects (multi-repo refactors, research sprints, content pipelines), you need agents that can work in parallel without constant supervision.</p>\n<h4>What It Does</h4>\n<ul><li>**Decentralized coordination**: Agents read/write to a shared `STATE.yaml` file</li><li>**Parallel execution**: Multiple subagents work on independent tasks simultaneously</li><li>**No orchestrator overhead**: Main session stays thin (CEO pattern—strategy only)</li><li>**Self-documenting**: All task state persists in version-controlled files</li></ul>\n<h4>Core Pattern: STATE.yaml</h4>\n<p>Each project maintains a `STATE.yaml` file that serves as the single source of truth:</p>\n<p>```yaml</p>\n<h3>STATE.yaml - Project coordination file</h3>\n<p>project: website-redesign</p>\n<p>updated: 2026-02-10T14:30:00Z</p>\n<p>tasks:</p>\n<ul><li>id: homepage-hero</li></ul>\n<p>status: in_progress</p>\n<p>owner: pm-frontend</p>\n<p>started: 2026-02-10T12:00:00Z</p>\n<p>notes: &quot;Working on responsive layout&quot;</p>\n<ul><li>id: api-auth</li></ul>\n<p>status: done</p>\n<p>owner: pm-backend</p>\n<p>completed: 2026-02-10T14:00:00Z</p>\n<p>output: &quot;src/api/auth.ts&quot;</p>\n<ul><li>id: content-migration</li></ul>\n<p>status: blocked</p>\n<p>owner: pm-content</p>\n<p>blocked_by: api-auth</p>\n<p>notes: &quot;Waiting for new endpoint schema&quot;</p>\n<p>next_actions:</p>\n<ul><li>&quot;pm-content: Resume migration now that api-auth is done&quot;</li><li>&quot;pm-frontend: Review hero with design team&quot;</li></ul>\n<p>```</p>\n<h4>How It Works</h4>\n<p>1. **Main agent receives task** → spawns subagent with specific scope</p>\n<p>2. **Subagent reads STATE.yaml** → finds its assigned tasks</p>\n<p>3. **Subagent works autonomously** → updates STATE.yaml on progress</p>\n<p>4. **Other agents poll STATE.yaml** → pick up unblocked work</p>\n<p>5. **Main agent checks in periodically** → reviews state, adjusts priorities</p>\n<h4>Skills You Need</h4>\n<ul><li>`sessions_spawn` / `sessions_send` for subagent management</li><li>File system access for STATE.yaml</li><li>Git for state versioning (optional but recommended)</li></ul>\n<h4>Setup: AGENTS.md Configuration</h4>\n<p>```text</p>\n<h4>PM Delegation Pattern</h4>\n<p>Main session = coordinator ONLY. All execution goes to subagents.</p>\n<p>Workflow:</p>\n<p>1. New task arrives</p>\n<p>2. Check PROJECT_REGISTRY.md for existing PM</p>\n<p>3. If PM exists → sessions_send(label=&quot;pm-xxx&quot;, message=&quot;[task]&quot;)</p>\n<p>4. If new project → sessions_spawn(label=&quot;pm-xxx&quot;, task=&quot;[task]&quot;)</p>\n<p>5. PM executes, updates STATE.yaml, reports back</p>\n<p>6. Main agent summarizes to user</p>\n<p>Rules:</p>\n<ul><li>Main session: 0-2 tool calls max (spawn/send only)</li><li>PMs own their STATE.yaml files</li><li>PMs can spawn sub-subagents for parallel subtasks</li><li>All state changes committed to git</li></ul>\n<p>```</p>\n<h4>Example: Spawning a PM</h4>\n<p>```text</p>\n<p>User: &quot;Refactor the auth module and update the docs&quot;</p>\n<p>Main agent:</p>\n<p>1. Checks registry → no active pm-auth</p>\n<p>2. Spawns: sessions_spawn(</p>\n<p>label=&quot;pm-auth-refactor&quot;,</p>\n<p>task=&quot;Refactor auth module, update docs. Track in STATE.yaml&quot;</p>\n<p>)</p>\n<p>3. Responds: &quot;Spawned pm-auth-refactor. I&#39;ll report back when done.&quot;</p>\n<p>PM subagent:</p>\n<p>1. Creates STATE.yaml with task breakdown</p>\n<p>2. Works through tasks, updating status</p>\n<p>3. Commits changes</p>\n<p>4. Reports completion to main</p>\n<p>```</p>\n<h4>Key Insights</h4>\n<ul><li>**STATE.yaml &gt; orchestrator**: File-based coordination scales better than message-passing</li><li>**Git as audit log**: Commit STATE.yaml changes for full history</li><li>**Label conventions matter**: Use `pm-{project}-{scope}` for easy tracking</li><li>**Thin main session**: The less the main agent does, the faster it responds</li></ul>\n<h4>Based On</h4>\n<p>This pattern is inspired by [Nicholas Carlini&#39;s approach](https://nicholas.carlini.com/) to autonomous coding agents—let agents self-organize rather than micromanaging them.</p>\n<h4>Related Links</h4>\n<ul><li>[OpenClaw Subagent Docs](https://github.com/openclaw/openclaw)</li><li>[Anthropic: Building Effective Agents](https://www.anthropic.com/research/building-effective-agents)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/autonomous-project-management.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/autonomous-project-management.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/autonomous-project-management.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-custom-morning-brief",
      "slug": "custom-morning-brief",
      "title": "Custom Morning Brief",
      "category": "productivity",
      "tags": [
        "custom",
        "morning",
        "brief"
      ],
      "rating": 87,
      "summary": "You wake up and spend the first 30 minutes of your day catching up — scrolling news, checking your calendar, reviewing your to-do list, trying to figure out what matters today. What if all of that was already done and waiting for you as a text message?",
      "content": "<h3>Custom Morning Brief</h3>\n<p>You wake up and spend the first 30 minutes of your day catching up — scrolling news, checking your calendar, reviewing your to-do list, trying to figure out what matters today. What if all of that was already done and waiting for you as a text message?</p>\n<p>This workflow has OpenClaw send you a fully customized morning briefing every day at a scheduled time, covering news, tasks, ideas, and proactive recommendations.</p>\n<h4>What It Does</h4>\n<ul><li>Sends a structured morning report to Telegram, Discord, or iMessage at the same time every day (e.g., 8:00 AM)</li><li>Researches overnight news relevant to your interests by browsing the web</li><li>Reviews your to-do list and surfaces tasks for the day</li><li>Generates creative output (full scripts, email drafts, business proposals — not just ideas) while you sleep</li><li>Recommends tasks the AI can complete autonomously to help you that day</li></ul>\n<h4>Pain Point</h4>\n<p>You&#39;re spending your most productive morning hours just getting oriented. Meanwhile, your AI agent sits idle all night. The morning brief turns idle overnight hours into productive prep time — you wake up to work already done.</p>\n<h4>Skills You Need</h4>\n<ul><li>Telegram, Discord, or iMessage integration</li><li>Todoist / Apple Reminders / Asana integration (whichever you use for tasks)</li><li>[x-research-v2](https://clawhub.ai) for social media trend research (optional)</li></ul>\n<h4>How to Set It Up</h4>\n<p>1. Connect OpenClaw to your messaging platform and task manager.</p>\n<p>2. Prompt OpenClaw:</p>\n<p>```text</p>\n<p>I want to set up a regular morning brief. Every morning at 8:00 AM,</p>\n<p>send me a report through Telegram.</p>\n<p>I want this report to include:</p>\n<p>1. News stories relevant to my interests (AI, startups, tech)</p>\n<p>2. Ideas for content I can create today</p>\n<p>3. Tasks I need to complete today (pull from my to-do list)</p>\n<p>4. Recommendations for tasks you can complete for me today</p>\n<p>For the content ideas, write full draft scripts/outlines — not just titles.</p>\n<p>```</p>\n<p>3. OpenClaw will schedule this automatically. Verify it&#39;s working by checking your messages the next morning.</p>\n<p>4. Customize over time — just text your bot:</p>\n<p>```text</p>\n<p>Add weather forecast to my morning brief.</p>\n<p>Stop including general news, focus only on AI.</p>\n<p>Include a motivational quote each morning.</p>\n<p>```</p>\n<p>5. If you can&#39;t think of what to include, you don&#39;t have to — just say:</p>\n<p>```text</p>\n<p>I want this report to include things relevant to me.</p>\n<p>Think of what would be most helpful to put in this report.</p>\n<p>```</p>\n<h4>Key Insights</h4>\n<ul><li>The AI-recommended tasks section is the most powerful part — it has the agent proactively think of ways to help you, rather than waiting for instructions.</li><li>You can customize the brief just by texting. Say &quot;Add stock prices to my morning brief&quot; and it updates.</li><li>Full drafts (not just ideas) are the key to saving time. Wake up to scripts, not suggestions.</li><li>It doesn&#39;t matter what industry you&#39;re in — a morning brief with tasks, news, and proactive suggestions is universally useful.</li></ul>\n<h4>Based On</h4>\n<p>Inspired by [Alex Finn&#39;s video on life-changing OpenClaw use cases](https://www.youtube.com/watch?v=41_TNGDDnfQ).</p>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/custom-morning-brief.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/custom-morning-brief.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/custom-morning-brief.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-daily-youtube-digest",
      "slug": "daily-youtube-digest",
      "title": "Daily YouTube Digest",
      "category": "content",
      "tags": [
        "daily",
        "youtube",
        "digest"
      ],
      "rating": 87,
      "summary": "Start your day with a personalized summary of new videos from your favorite YouTube channels — no more missing content from creators you actually want to follow.",
      "content": "<h3>Daily YouTube Digest</h3>\n<p>Start your day with a personalized summary of new videos from your favorite YouTube channels — no more missing content from creators you actually want to follow.</p>\n<h4>Pain Point</h4>\n<p>YouTube notifications are unreliable. You subscribe to channels, but their new videos never show up in your home feed. They&#39;re not in notifications. They just... disappear. This doesn&#39;t mean you don&#39;t want to see them — it means YouTube&#39;s algorithm buried them.</p>\n<p>Plus: it&#39;s fun to start the day with curated content insights instead of doom-scrolling a recommendation feed.</p>\n<h4>What It Does</h4>\n<ul><li>Fetches the latest videos from a list of your favorite channels</li><li>Summarizes or extracts key insights from each video&#39;s transcript</li><li>Delivers a digest to you daily (or on demand)</li></ul>\n<h4>Skills You Need</h4>\n<p>Install the [youtube-full](https://clawhub.ai/therohitdas/youtube-full) skill.</p>\n<p>Just tell your OpenClaw:</p>\n<p>```text</p>\n<p>&quot;Install the youtube-full skill and set it up for me&quot;</p>\n<p>```</p>\n<p>or</p>\n<p>```bash</p>\n<p>npx clawhub@latest install youtube-full</p>\n<p>```</p>\n<p>That&#39;s it. The agent handles the rest — including account creation and API key setup. You get **100 free credits on signup**, no credit card required.</p>\n<p>&gt; Note: After creating the account, the skill auto-stores the API key securely in correct locations based on the OS, so the API will work in all contexts.</p>\n<p>![youtube-full skill installation](https://pub-15904f15a44a4ea69350737e87660b92.r2.dev/media/1770620159490-e41e7baa.png)</p>\n<p>### Why TranscriptAPI.com over yt-dlp?</p>\n<p>| CLI tools (yt-dlp, etc.) | TranscriptAPI |</p>\n<p>|--------------------------|---------------|</p>\n<p>| Verbose logs flood agent context | Clean JSON responses |</p>\n<p>| Doesn&#39;t work on GCP/cloud OpenClaw | Works everywhere, fast |</p>\n<p>| Gets blocked randomly by YouTube | Powers [YouTubeToTranscript.com](https://youtubetotranscript.com) serving millions. Cached and reliable. |</p>\n<p>| Requires binary installation | No binaries, just HTTP |</p>\n<h4>How to Set It Up</h4>\n<p>### Option 1: Channel-based digest</p>\n<p>Prompt OpenClaw:</p>\n<p>```text</p>\n<p>Every morning at 8am, fetch the latest videos from these YouTube channels and give me a digest with key insights from each:</p>\n<ul><li>@TED</li><li>@Fireship</li><li>@ThePrimeTimeagen</li><li>@lexfridman</li></ul>\n<p>For each new video (uploaded in the last 24-48 hours):</p>\n<p>1. Get the transcript</p>\n<p>2. Summarize the main points in 2-3 bullets</p>\n<p>3. Include the video title, channel name, and link</p>\n<p>If a channel handle doesn&#39;t resolve, search for it and find the correct one.</p>\n<p>Save my channel list to memory so I can add/remove channels later.</p>\n<p>```</p>\n<p>### Option 2: Keyword-based digest</p>\n<p>Track new videos about a specific topic:</p>\n<p>```text</p>\n<p>Every day, search YouTube for new videos about &quot;OpenClaw&quot; (or &quot;Claude Code&quot;, &quot;AI agents&quot;, etc).</p>\n<p>Maintain a file called seen-videos.txt with video IDs you&#39;ve already processed.</p>\n<p>Only fetch transcripts for videos NOT in that file.</p>\n<p>After processing, add the video ID to seen-videos.txt.</p>\n<p>For each new video:</p>\n<p>1. Get the transcript</p>\n<p>2. Give me a 3-bullet summary</p>\n<p>3. Note anything relevant to my work</p>\n<p>Run this every morning at 9am.</p>\n<p>```</p>\n<p>This way you never waste credits re-fetching videos you&#39;ve already seen.</p>\n<h4>Tips</h4>\n<ul><li>`channel/latest` and `channel/resolve` are **free** (0 credits) — checking for new uploads costs nothing</li><li>Only transcripts cost 1 credit each</li><li>Ask for different digest styles: key takeaways, notable quotes, timestamps of interesting moments</li><li>This already exists as a product - [Recapio - Daily YouTube Recap](https://recapio.com/features/daily-recaps)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/daily-youtube-digest.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/daily-youtube-digest.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/daily-youtube-digest.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-dynamic-dashboard",
      "slug": "dynamic-dashboard",
      "title": "Dynamic Dashboard with Sub-agent Spawning",
      "category": "agents",
      "tags": [
        "dynamic",
        "dashboard"
      ],
      "rating": 86,
      "summary": "Static dashboards show stale data and require constant manual updates. You want real-time visibility across multiple data sources without building a custom frontend or hitting API rate limits.",
      "content": "<h3>Dynamic Dashboard with Sub-agent Spawning</h3>\n<p>Static dashboards show stale data and require constant manual updates. You want real-time visibility across multiple data sources without building a custom frontend or hitting API rate limits.</p>\n<p>This workflow creates a live dashboard that spawns sub-agents to fetch and process data in parallel:</p>\n<p>• Monitors multiple data sources simultaneously (APIs, databases, GitHub, social media)</p>\n<p>• Spawns sub-agents for each data source to avoid blocking and distribute API load</p>\n<p>• Aggregates results into a unified dashboard (text, HTML, or Canvas)</p>\n<p>• Updates every N minutes with fresh data</p>\n<p>• Sends alerts when metrics cross thresholds</p>\n<p>• Maintains historical trends in a database for visualization</p>\n<h4>Pain Point</h4>\n<p>Building a custom dashboard takes weeks. By the time it&#39;s done, requirements have changed. Polling multiple APIs sequentially is slow and hits rate limits. You need insight now, not after a weekend of coding.</p>\n<h4>What It Does</h4>\n<p>You define what you want to monitor conversationally: &quot;Track GitHub stars, Twitter mentions, Polymarket volume, and system health.&quot; OpenClaw spawns sub-agents to fetch each data source in parallel, aggregates the results, and delivers a formatted dashboard to Discord or as an HTML file. Updates run automatically on a cron schedule.</p>\n<p>Example dashboard sections:</p>\n<ul><li>**GitHub**: stars, forks, open issues, recent commits</li><li>**Social Media**: Twitter mentions, Reddit discussions, Discord activity</li><li>**Markets**: Polymarket volume, prediction trends</li><li>**System Health**: CPU, memory, disk usage, service status</li></ul>\n<h4>Skills Needed</h4>\n<ul><li>Sub-agent spawning for parallel execution</li><li>`github` (gh CLI) for GitHub metrics</li><li>`bird` (Twitter) for social data</li><li>`web_search` or `web_fetch` for external APIs</li><li>`postgres` for storing historical metrics</li><li>Discord or Canvas for rendering the dashboard</li><li>Cron jobs for scheduled updates</li></ul>\n<h4>How to Set it Up</h4>\n<p>1. Set up a metrics database:</p>\n<p>```sql</p>\n<p>CREATE TABLE metrics (</p>\n<p>id SERIAL PRIMARY KEY,</p>\n<p>source TEXT, -- e.g., &quot;github&quot;, &quot;twitter&quot;, &quot;polymarket&quot;</p>\n<p>metric_name TEXT,</p>\n<p>metric_value NUMERIC,</p>\n<p>timestamp TIMESTAMPTZ DEFAULT NOW()</p>\n<p>);</p>\n<p>CREATE TABLE alerts (</p>\n<p>id SERIAL PRIMARY KEY,</p>\n<p>source TEXT,</p>\n<p>condition TEXT,</p>\n<p>threshold NUMERIC,</p>\n<p>last_triggered TIMESTAMPTZ</p>\n<p>);</p>\n<p>```</p>\n<p>2. Create a Discord channel for dashboard updates (e.g., #dashboard).</p>\n<p>3. Prompt OpenClaw:</p>\n<p>```text</p>\n<p>You are my dynamic dashboard manager. Every 15 minutes, run a cron job to:</p>\n<p>1. Spawn sub-agents in parallel to fetch data from:</p>\n<ul><li>GitHub: stars, forks, open issues, commits (past 24h)</li><li>Twitter: mentions of &quot;@username&quot;, sentiment analysis</li><li>Polymarket: volume for tracked markets</li><li>System: CPU, memory, disk usage via shell commands</li></ul>\n<p>2. Each sub-agent writes results to the metrics database.</p>\n<p>3. Aggregate all results and format a dashboard:</p>\n<p>📊 **Dashboard Update** — [timestamp]</p>\n<p>**GitHub**</p>\n<ul><li>⭐ Stars: [count] (+[change])</li><li>🍴 Forks: [count]</li><li>🐛 Open Issues: [count]</li><li>💻 Commits (24h): [count]</li></ul>\n<p>**Social Media**</p>\n<ul><li>🐦 Twitter Mentions: [count]</li><li>📈 Sentiment: [positive/negative/neutral]</li></ul>\n<p>**Markets**</p>\n<ul><li>📊 Polymarket Volume: $[amount]</li><li>🔥 Trending: [market names]</li></ul>\n<p>**System Health**</p>\n<ul><li>💻 CPU: [usage]%</li><li>🧠 Memory: [usage]%</li><li>💾 Disk: [usage]%</li></ul>\n<p>4. Post to Discord #dashboard.</p>\n<p>5. Check alert conditions:</p>\n<ul><li>If GitHub stars change &gt; 50 in 1 hour → ping me</li><li>If system CPU &gt; 90% → alert</li><li>If negative sentiment spike on Twitter → notify</li></ul>\n<p>Store all metrics in the database for historical analysis.</p>\n<p>```</p>\n<p>4. Optional: Use Canvas to render an HTML dashboard with charts and graphs.</p>\n<p>5. Query historical data: &quot;Show me GitHub star growth over the past 30 days.&quot;</p>\n<h4>Related Links</h4>\n<ul><li>[Parallel Processing with Sub-agents](https://docs.openclaw.ai/subagents)</li><li>[Dashboard Design Principles](https://www.nngroup.com/articles/dashboard-design/)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/dynamic-dashboard.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/dynamic-dashboard.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/dynamic-dashboard.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-event-guest-confirmation",
      "slug": "event-guest-confirmation",
      "title": "Event Guest Confirmation",
      "category": "deployment",
      "tags": [
        "event",
        "guest",
        "confirmation"
      ],
      "rating": 86,
      "summary": "You're hosting an event — a dinner party, a wedding, a company offsite — and you need to confirm attendance from a list of guests. Manually calling 20+ people is tedious: you play phone tag, forget who said what, and lose track of dietary restrictions or plus-",
      "content": "<h3>Event Guest Confirmation</h3>\n<p>You&#39;re hosting an event — a dinner party, a wedding, a company offsite — and you need to confirm attendance from a list of guests. Manually calling 20+ people is tedious: you play phone tag, forget who said what, and lose track of dietary restrictions or plus-ones. Texting works sometimes, but people ignore messages. A real phone call gets a much higher response rate.</p>\n<p>This use case has OpenClaw call each guest on your list using the [SuperCall](https://clawhub.ai/xonder/supercall) plugin, confirm whether they&#39;re attending, collect any notes, and compile everything into a summary for you.</p>\n<h4>What It Does</h4>\n<ul><li>Iterates through a guest list (names + phone numbers) and calls each one</li><li>The AI introduces itself as your event coordinator with a friendly persona</li><li>Confirms the event date, time, and location with the guest</li><li>Asks if they&#39;re attending, and collects any notes (dietary needs, plus-ones, arrival time, etc.)</li><li>After all calls are complete, compiles a summary: who confirmed, who declined, who didn&#39;t pick up, and any notes</li></ul>\n<h4>Why SuperCall</h4>\n<p>This use case works with the [SuperCall](https://clawhub.ai/xonder/supercall) plugin specifically — not the built-in `voice_call` plugin. The key difference: SuperCall is a fully standalone voice agent. The AI persona on the call **only has access to the context you provide** (the persona name, the goal, and the opening line). It cannot access your gateway agent, your files, your other tools, or anything else.</p>\n<p>This matters for guest confirmation because:</p>\n<ul><li>**Safety**: The person on the other end of the call can&#39;t manipulate or access your agent through the conversation. There&#39;s no risk of prompt injection or data leakage.</li><li>**Better conversations**: Because the AI is scoped to a single focused task (confirm attendance), it stays on-topic and handles the call more naturally than a general-purpose voice agent would.</li><li>**Batch-friendly**: You&#39;re making many calls to different people. A sandboxed persona that resets per call is exactly what you want — no bleed-over between conversations.</li></ul>\n<h4>Skills You Need</h4>\n<ul><li>[SuperCall](https://clawhub.ai/xonder/supercall) — install via `openclaw plugins install @xonder/supercall`</li><li>A Twilio account with a phone number (for making outbound calls)</li><li>An OpenAI API key (for the GPT-4o Realtime voice AI)</li><li>ngrok (for webhook tunneling — free tier works)</li></ul>\n<p>See the [SuperCall README](https://github.com/xonder/supercall) for full configuration instructions.</p>\n<h4>How to Set It Up</h4>\n<p>1. Install and configure SuperCall following the [setup guide](https://github.com/xonder/supercall#configuration). Make sure hooks are enabled in your OpenClaw config.</p>\n<p>2. Prepare your guest list. You can paste it directly in chat or keep it in a file:</p>\n<p>```text</p>\n<p>Guest List — Summer BBQ, Saturday June 14th, 4 PM, 23 Oak Street</p>\n<ul><li>Sarah Johnson: +15551234567</li><li>Mike Chen: +15559876543</li><li>Rachel Torres: +15555551234</li><li>David Kim: +15558887777</li></ul>\n<p>```</p>\n<p>3. Prompt OpenClaw:</p>\n<p>```text</p>\n<p>I need you to confirm attendance for my event. Here are the details:</p>\n<p>Event: Summer BBQ</p>\n<p>Date: Saturday, June 14th at 4 PM</p>\n<p>Location: 23 Oak Street</p>\n<p>Here is my guest list:</p>\n<p>&lt;paste your guest list here&gt;</p>\n<p>For each guest, use supercall to call them. Use the persona &quot;Jamie, event coordinator</p>\n<p>for [your name]&quot;. The goal for each call is to confirm whether they&#39;re attending,</p>\n<p>and note any dietary restrictions, plus-ones, or other comments.</p>\n<p>After each call, log the result. Once all calls are done, give me a full summary:</p>\n<ul><li>Who confirmed</li><li>Who declined</li><li>Who didn&#39;t answer</li><li>Any notes or special requests from each guest</li></ul>\n<p>```</p>\n<p>4. OpenClaw will call each guest one by one using SuperCall, then compile the results. You can check in on progress at any time by asking for a status update.</p>\n<h4>Key Insights</h4>\n<ul><li>**Start with a small test**: Try it with 2-3 guests first to make sure the persona and opening line sound right. You can adjust the tone before calling the full list.</li><li>**Be mindful of calling hours**: Don&#39;t schedule calls too early or too late. You can tell OpenClaw to only call between certain hours.</li><li>**Review transcripts**: SuperCall logs transcripts to `~/clawd/supercall-logs`. Skim through them after the first batch to see how conversations went.</li><li>**No-answer handling**: If someone doesn&#39;t pick up, OpenClaw can note it and you can decide whether to retry later or follow up by text.</li><li>**Real phone calls cost money**: Each call uses Twilio minutes. Set appropriate limits in your Twilio account, especially for large guest lists.</li></ul>\n<h4>Related Links</h4>\n<ul><li>[SuperCall on ClawHub](https://clawhub.ai/xonder/supercall)</li><li>[SuperCall on GitHub](https://github.com/xonder/supercall)</li><li>[Twilio Console](https://console.twilio.com)</li><li>[OpenAI Realtime API](https://platform.openai.com/docs/guides/realtime)</li><li>[ngrok](https://ngrok.com)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/event-guest-confirmation.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/event-guest-confirmation.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/event-guest-confirmation.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-overnight-mini-app-builder",
      "slug": "overnight-mini-app-builder",
      "title": "Goal-Driven Autonomous Tasks",
      "category": "agents",
      "tags": [
        "overnight",
        "mini",
        "app",
        "builder"
      ],
      "rating": 86,
      "summary": "Your AI agent is powerful but reactive — it only works when you tell it what to do. What if it knew your goals and proactively came up with tasks to move you closer to them every single day, without being asked?",
      "content": "<h3>Goal-Driven Autonomous Tasks</h3>\n<p>Your AI agent is powerful but reactive — it only works when you tell it what to do. What if it knew your goals and proactively came up with tasks to move you closer to them every single day, without being asked?</p>\n<p>This workflow turns OpenClaw into a self-directed employee. You brain dump your goals once, and the agent autonomously generates, schedules, and completes tasks that advance those goals — including building you surprise mini-apps overnight.</p>\n<h4>What It Does</h4>\n<ul><li>You brain dump all your goals, missions, and objectives into OpenClaw (personal and professional)</li><li>Every morning, the agent generates 4-5 tasks it can complete autonomously on your computer</li><li>Tasks go beyond app building: research, writing scripts, building features, creating content, analyzing competitors</li><li>The agent executes the tasks itself and tracks them on a custom Kanban board it builds for you</li><li>You can also have it build you a surprise mini-app every night — a new SaaS idea, a tool that automates a boring part of your life, shipped as an MVP</li></ul>\n<h4>Pain Point</h4>\n<p>Most people have big goals but struggle to break them into daily actionable steps. And even when they do, execution takes all their time. This system offloads both the planning AND the execution to your AI agent. You define the destination; the agent figures out the daily steps and walks them.</p>\n<h4>Skills You Need</h4>\n<ul><li>Telegram or Discord integration</li><li>`sessions_spawn` / `sessions_send` for autonomous task execution</li><li>Next.js or similar (for the Kanban board — OpenClaw builds it for you)</li></ul>\n<h4>How to Set It Up</h4>\n<p>### Step 1: Brain Dump Your Goals</p>\n<p>This is the most important step. Text your OpenClaw everything you&#39;re trying to accomplish:</p>\n<p>```text</p>\n<p>Here are my goals and missions. Remember all of this:</p>\n<p>Career:</p>\n<ul><li>Grow my YouTube channel to 100k subscribers</li><li>Launch my SaaS product by Q3</li><li>Build a community around AI education</li></ul>\n<p>Personal:</p>\n<ul><li>Read 2 books per month</li><li>Learn Spanish</li></ul>\n<p>Business:</p>\n<ul><li>Scale revenue to $10k/month</li><li>Build partnerships with 5 companies in my space</li><li>Automate as much of my workflow as possible</li></ul>\n<p>Use this context for everything you do going forward.</p>\n<p>```</p>\n<p>### Step 2: Set Up Autonomous Daily Tasks</p>\n<p>```text</p>\n<p>Every morning at 8:00 AM, come up with 4-5 tasks that you can complete</p>\n<p>on my computer today that bring me closer to my goals.</p>\n<p>Then schedule and complete those tasks yourself. Examples:</p>\n<ul><li>Research competitors and write analysis reports</li><li>Draft video scripts based on trending topics</li><li>Build new features for my apps</li><li>Write and schedule social media content</li><li>Research potential business partnerships</li><li>Build me a surprise mini-app MVP that gets me closer to one of my goals</li></ul>\n<p>Track all tasks on a Kanban board. Update the board as you complete them.</p>\n<p>```</p>\n<p>### Step 3: Build the Kanban Board (Optional)</p>\n<p>```text</p>\n<p>Build me a Kanban board in Next.js where I can see all the tasks you&#39;re</p>\n<p>working on. Show columns for To Do, In Progress, and Done. Update it</p>\n<p>in real-time as you complete tasks.</p>\n<p>```</p>\n<h4>Key Insights</h4>\n<ul><li>The **brain dump is everything**. The more context you give about your goals, the better the agent&#39;s daily tasks will be. Don&#39;t hold back.</li><li>The agent discovers tasks you wouldn&#39;t have thought of. It connects dots across your goals and finds opportunities you&#39;d miss.</li><li>The Kanban board turns your agent into a trackable employee. You can see exactly what it&#39;s been doing and course-correct.</li><li>For overnight app building specifically: explicitly tell it to build MVPs and not to overcomplicate. You&#39;ll wake up every morning with a new surprise.</li><li>This compounds over time — the agent learns what kinds of tasks are most helpful and adjusts.</li></ul>\n<h4>Based On</h4>\n<p>Inspired by [Alex Finn](https://www.youtube.com/watch?v=UTCi_q6iuCM&amp;t=414s) and his [video on life-changing OpenClaw use cases](https://www.youtube.com/watch?v=41_TNGDDnfQ).</p>\n<h4>Related Links</h4>\n<ul><li>[OpenClaw Memory System](https://github.com/openclaw/openclaw)</li><li>[OpenClaw Subagent Docs](https://github.com/openclaw/openclaw)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/overnight-mini-app-builder.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/overnight-mini-app-builder.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/overnight-mini-app-builder.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-project-state-management",
      "slug": "project-state-management",
      "title": "Project State Management System: Event-Driven Alternative to Kanban",
      "category": "productivity",
      "tags": [
        "project",
        "state",
        "management"
      ],
      "rating": 86,
      "summary": "Traditional Kanban boards are static and require manual updates. You forget to move cards, lose context between sessions, and can't track the \"why\" behind state changes. Projects drift without clear visibility.",
      "content": "<h3>Project State Management System: Event-Driven Alternative to Kanban</h3>\n<p>Traditional Kanban boards are static and require manual updates. You forget to move cards, lose context between sessions, and can&#39;t track the &quot;why&quot; behind state changes. Projects drift without clear visibility.</p>\n<p>This workflow replaces Kanban with an event-driven system that tracks project state automatically:</p>\n<p>• Stores project state in a database with full history</p>\n<p>• Captures context: decisions, blockers, next steps, key insights</p>\n<p>• Event-driven updates: &quot;Just finished X, blocked on Y&quot; → automatic state transition</p>\n<p>• Natural language queries: &quot;What&#39;s the status of [project]?&quot;, &quot;Why did we pivot on [feature]?&quot;</p>\n<p>• Daily standup summaries: What happened yesterday, what&#39;s planned today, what&#39;s blocked</p>\n<p>• Git integration: links commits to project events for traceability</p>\n<h4>Pain Point</h4>\n<p>Kanban boards become stale. You waste time updating cards instead of doing work. Context gets lost—three months later, you can&#39;t remember why you made a key decision. There&#39;s no automatic link between code changes and project progress.</p>\n<h4>What It Does</h4>\n<p>Instead of dragging cards, you chat with your assistant: &quot;Finished the auth flow, starting on the dashboard.&quot; The system logs the event, updates project state, and preserves context. When you ask &quot;Where are we on the dashboard?&quot; it gives you the full story: what&#39;s done, what&#39;s next, what&#39;s blocking you, and why.</p>\n<p>Git commits are automatically scanned and linked to projects. Your daily standup summary writes itself.</p>\n<h4>Skills Needed</h4>\n<ul><li>`postgres` or SQLite for project state database</li><li>`github` (gh CLI) for commit tracking</li><li>Discord or Telegram for updates and queries</li><li>Cron jobs for daily summaries</li><li>Sub-agents for parallel project analysis</li></ul>\n<h4>How to Set it Up</h4>\n<p>1. Set up a project state database:</p>\n<p>```sql</p>\n<p>CREATE TABLE projects (</p>\n<p>id SERIAL PRIMARY KEY,</p>\n<p>name TEXT UNIQUE,</p>\n<p>status TEXT, -- e.g., &quot;active&quot;, &quot;blocked&quot;, &quot;completed&quot;</p>\n<p>current_phase TEXT,</p>\n<p>last_update TIMESTAMPTZ DEFAULT NOW()</p>\n<p>);</p>\n<p>CREATE TABLE events (</p>\n<p>id SERIAL PRIMARY KEY,</p>\n<p>project_id INTEGER REFERENCES projects(id),</p>\n<p>event_type TEXT, -- e.g., &quot;progress&quot;, &quot;blocker&quot;, &quot;decision&quot;, &quot;pivot&quot;</p>\n<p>description TEXT,</p>\n<p>context TEXT,</p>\n<p>timestamp TIMESTAMPTZ DEFAULT NOW()</p>\n<p>);</p>\n<p>CREATE TABLE blockers (</p>\n<p>id SERIAL PRIMARY KEY,</p>\n<p>project_id INTEGER REFERENCES projects(id),</p>\n<p>blocker_text TEXT,</p>\n<p>status TEXT DEFAULT &#39;open&#39;, -- &quot;open&quot;, &quot;resolved&quot;</p>\n<p>created_at TIMESTAMPTZ DEFAULT NOW(),</p>\n<p>resolved_at TIMESTAMPTZ</p>\n<p>);</p>\n<p>```</p>\n<p>2. Create a Discord channel for project updates (e.g., #project-state).</p>\n<p>3. Prompt OpenClaw:</p>\n<p>```text</p>\n<p>You are my project state manager. Instead of Kanban, I&#39;ll tell you what I&#39;m working on conversationally.</p>\n<p>When I say things like:</p>\n<ul><li>&quot;Finished [task]&quot; → log a &quot;progress&quot; event, update project state</li><li>&quot;Blocked on [issue]&quot; → create a blocker entry, update project status to &quot;blocked&quot;</li><li>&quot;Starting [new task]&quot; → log a &quot;progress&quot; event, update current phase</li><li>&quot;Decided to [decision]&quot; → log a &quot;decision&quot; event with full context</li><li>&quot;Pivoting to [new approach]&quot; → log a &quot;pivot&quot; event with reasoning</li></ul>\n<p>When I ask:</p>\n<ul><li>&quot;What&#39;s the status of [project]?&quot; → fetch latest events, blockers, and current phase</li><li>&quot;Why did we decide [X]?&quot; → search events for decision context</li><li>&quot;What&#39;s blocking us?&quot; → list all open blockers across projects</li></ul>\n<p>Every morning at 9 AM, run a cron job to:</p>\n<p>1. Scan git commits from the past 24 hours (via gh CLI)</p>\n<p>2. Link commits to projects based on branch names or commit messages</p>\n<p>3. Post a daily standup summary to Discord #project-state:</p>\n<ul><li>What happened yesterday (events + commits)</li><li>What&#39;s planned today (based on current phase and recent conversations)</li><li>What&#39;s blocked (open blockers)</li></ul>\n<p>When I&#39;m planning a sprint, spawn a sub-agent to analyze each project&#39;s state and suggest priorities.</p>\n<p>```</p>\n<p>4. Integrate with your workflow: Just talk to your assistant naturally about what you&#39;re doing. The system captures everything.</p>\n<h4>Related Links</h4>\n<ul><li>[Event Sourcing Pattern](https://martinfowler.com/eaaDev/EventSourcing.html)</li><li>[Why Kanban Fails for Solo Developers](https://blog.nuclino.com/why-kanban-doesnt-work-for-me)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/project-state-management.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/project-state-management.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/project-state-management.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-second-brain",
      "slug": "second-brain",
      "title": "Second Brain",
      "category": "productivity",
      "tags": [
        "second",
        "brain"
      ],
      "rating": 86,
      "summary": "You come up with ideas, find interesting links, hear about books to read — but you never have a good system for capturing them. Notion gets complex, Apple Notes becomes a graveyard of 10,000 unread entries. You need something as simple as texting a friend.",
      "content": "<h3>Second Brain</h3>\n<p>You come up with ideas, find interesting links, hear about books to read — but you never have a good system for capturing them. Notion gets complex, Apple Notes becomes a graveyard of 10,000 unread entries. You need something as simple as texting a friend.</p>\n<p>This workflow turns OpenClaw into a memory-capture system you interact with via text message, backed by a custom searchable UI you can browse anytime.</p>\n<h4>What It Does</h4>\n<ul><li>Text anything to your OpenClaw via Telegram, iMessage, or Discord — &quot;Remind me to read a book about local LLMs&quot; — and it remembers it instantly</li><li>OpenClaw&#39;s built-in memory system stores everything you tell it permanently</li><li>A custom Next.js dashboard lets you search through every memory, conversation, and note</li><li>Global search (Cmd+K) across all memories, documents, and tasks</li><li>No folders, no tags, no complex organization — just text and search</li></ul>\n<h4>Pain Point</h4>\n<p>Every note-taking app eventually becomes a chore. You stop using it because the friction of organizing is higher than the friction of forgetting. The key insight is: **capture should be as easy as texting, and retrieval should be as easy as searching**.</p>\n<h4>Skills You Need</h4>\n<ul><li>Telegram, iMessage, or Discord integration (for text-based capture)</li><li>Next.js (OpenClaw builds this for you — no coding needed)</li></ul>\n<h4>How to Set It Up</h4>\n<p>1. Make sure your OpenClaw is connected to your preferred messaging platform (Telegram, Discord, etc.).</p>\n<p>2. Start using it immediately — just text your bot anything you want to remember:</p>\n<p>```text</p>\n<p>Hey, remind me to read &quot;Designing Data-Intensive Applications&quot;</p>\n<p>Save this link: https://example.com/interesting-article</p>\n<p>Remember: John recommended the restaurant on 5th street</p>\n<p>```</p>\n<p>3. Build the searchable UI by prompting OpenClaw:</p>\n<p>```text</p>\n<p>I want to build a second brain system where I can review all our notes,</p>\n<p>conversations, and memories. Please build that out with Next.js.</p>\n<p>Include:</p>\n<ul><li>A searchable list of all memories and conversations</li><li>Global search (Cmd+K) across everything</li><li>Ability to filter by date and type</li><li>Clean, minimal UI</li></ul>\n<p>```</p>\n<p>4. OpenClaw will build and deploy the entire Next.js app for you. Navigate to the URL it provides and you have your second brain dashboard.</p>\n<p>5. From now on, whenever you think of something — on the road, in a meeting, before bed — just text your bot. Come back to the dashboard whenever you need to find something.</p>\n<h4>Key Insights</h4>\n<ul><li>The power is in the **zero-friction capture**. You don&#39;t need to open an app, pick a folder, or add tags. Just text.</li><li>OpenClaw&#39;s memory system is cumulative — it remembers *everything* you&#39;ve ever told it, making it more powerful over time.</li><li>You can text your bot from your phone and it builds things on your computer. The interface is the conversation.</li></ul>\n<h4>Based On</h4>\n<p>Inspired by [Alex Finn&#39;s video on life-changing OpenClaw use cases](https://www.youtube.com/watch?v=41_TNGDDnfQ).</p>\n<h4>Related Links</h4>\n<ul><li>[OpenClaw Memory System](https://github.com/openclaw/openclaw)</li><li>[Building a Second Brain (Tiago Forte)](https://www.buildingasecondbrain.com/)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/second-brain.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/second-brain.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/second-brain.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-semantic-memory-search",
      "slug": "semantic-memory-search",
      "title": "Semantic Memory Search",
      "category": "productivity",
      "tags": [
        "semantic",
        "memory",
        "search"
      ],
      "rating": 86,
      "summary": "OpenClaw's built-in memory system stores everything as markdown files — but as memories grow over weeks and months, finding that one decision from last Tuesday becomes impossible. There is no search, just scrolling through files.",
      "content": "<h3>Semantic Memory Search</h3>\n<p>OpenClaw&#39;s built-in memory system stores everything as markdown files — but as memories grow over weeks and months, finding that one decision from last Tuesday becomes impossible. There is no search, just scrolling through files.</p>\n<p>This use case adds **vector-powered semantic search** on top of OpenClaw&#39;s existing markdown memory files using [memsearch](https://github.com/zilliztech/memsearch), so you can instantly find any past memory by meaning, not just keywords.</p>\n<h4>What It Does</h4>\n<ul><li>Index all your OpenClaw markdown memory files into a vector database (Milvus) with a single command</li><li>Search by meaning: &quot;what caching solution did we pick?&quot; finds the relevant memory even if the word &quot;caching&quot; does not appear</li><li>Hybrid search (dense vectors + BM25 full-text) with RRF reranking for best results</li><li>SHA-256 content hashing means unchanged files are never re-embedded — zero wasted API calls</li><li>File watcher auto-reindexes when memory files change, so the index is always up to date</li><li>Works with any embedding provider: OpenAI, Google, Voyage, Ollama, or fully local (no API key needed)</li></ul>\n<h4>Pain Point</h4>\n<p>OpenClaw&#39;s memory is stored as plain markdown files. This is great for portability and human readability, but it has no search. As your memory grows, you either have to grep through files (keyword-only, misses semantic matches) or load entire files into context (wastes tokens on irrelevant content). You need a way to ask &quot;what did I decide about X?&quot; and get the exact relevant chunk, regardless of phrasing.</p>\n<h4>Skills You Need</h4>\n<ul><li>No OpenClaw skills required — memsearch is a standalone Python CLI/library</li><li>Python 3.10+ with pip or uv</li></ul>\n<h4>How to Set It Up</h4>\n<p>1. Install memsearch:</p>\n<p>```bash</p>\n<p>pip install memsearch</p>\n<p>```</p>\n<p>2. Run the interactive config wizard:</p>\n<p>```bash</p>\n<p>memsearch config init</p>\n<p>```</p>\n<p>3. Index your OpenClaw memory directory:</p>\n<p>```bash</p>\n<p>memsearch index ~/path/to/your/memory/</p>\n<p>```</p>\n<p>4. Search your memories by meaning:</p>\n<p>```bash</p>\n<p>memsearch search &quot;what caching solution did we pick?&quot;</p>\n<p>```</p>\n<p>5. For live sync, start the file watcher — it auto-indexes on every file change:</p>\n<p>```bash</p>\n<p>memsearch watch ~/path/to/your/memory/</p>\n<p>```</p>\n<p>6. For a fully local setup (no API keys), install the local embedding provider:</p>\n<p>```bash</p>\n<p>pip install &quot;memsearch[local]&quot;</p>\n<p>memsearch config set embedding.provider local</p>\n<p>memsearch index ~/path/to/your/memory/</p>\n<p>```</p>\n<h4>Key Insights</h4>\n<ul><li>**Markdown stays the source of truth.** The vector index is just a derived cache — you can rebuild it anytime with `memsearch index`. Your memory files are never modified.</li><li>**Smart dedup saves money.** Each chunk is identified by a SHA-256 content hash. Re-running `index` only embeds new or changed content, so you can run it as often as you like without wasting embedding API calls.</li><li>**Hybrid search beats pure vector search.** Combining semantic similarity (dense vectors) with keyword matching (BM25) via Reciprocal Rank Fusion catches both meaning-based and exact-match queries.</li></ul>\n<h4>Related Links</h4>\n<ul><li>[memsearch GitHub](https://github.com/zilliztech/memsearch) — the library powering this use case</li><li>[memsearch Documentation](https://zilliztech.github.io/memsearch/) — full CLI reference, Python API, and architecture</li><li>[OpenClaw](https://github.com/openclaw/openclaw) — the memory architecture that inspired memsearch</li><li>[Milvus](https://milvus.io/) — the vector database backend</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/semantic-memory-search.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/semantic-memory-search.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/semantic-memory-search.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-x-account-analysis",
      "slug": "x-account-analysis",
      "title": "X Account Analysis",
      "category": "research",
      "tags": [
        "account",
        "analysis"
      ],
      "rating": 85,
      "summary": "There are many websites designed to give you a qualitative analysis of your X account. While X already gives you an **analytics** section, it's more focused to show your numbers on your performance.",
      "content": "<h3>X Account Analysis</h3>\n<p>There are many websites designed to give you a qualitative analysis of your X account. While X already gives you an **analytics** section, it&#39;s more focused to show your numbers on your performance.</p>\n<p>But a qualitative analysis focuses on the quality of your posts, not the performance stats. Some insights you can get from this type of analysis:</p>\n<ul><li>What are the patterns that make my posts go viral?</li><li>What topics I talk about get me most engagement?</li><li>Why do I get posts with 1000+ likes but sometimes posts with &lt;5 likes? What am I doing wrong?</li></ul>\n<p>There are many websites and apps designed to give you X analytics, but they focus on the statistics. There are probably 1-2 websites that let you talk with an AI to understand your performance.</p>\n<p>But now you can use OpenClaw to do this analysis for you, without needing to pay $10-$50 for subscriptions on these websites.</p>\n<h4>Skills you Need</h4>\n<p>Bird Skill. `clawhub install bird` (it comes pre-bundled)</p>\n<h4>How to Set it Up</h4>\n<p>Here&#39;s the flow:</p>\n<p>1. Make sure Bird skill is working.</p>\n<p>2. For security and isolation, you better create a new account for your ClawdBot.</p>\n<p>3. Auth with your X account. log into x.com in Chrome/Brave, and provide the right cookie information (`auth-token`, `ct0`) so OpenClaw can access your account.</p>\n<p>4. Ask OpenClaw to take a look at your real account, fetch the last N tweets, and ask it any questions you like. Alternatively, you can ask it to write you specific scripts.</p>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/x-account-analysis.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/x-account-analysis.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/x-account-analysis.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-earnings-tracker",
      "slug": "earnings-tracker",
      "title": "AI-Powered Earnings Tracker",
      "category": "research",
      "tags": [
        "earnings",
        "tracker"
      ],
      "rating": 83,
      "summary": "Following earnings season across dozens of tech companies means checking multiple sources and remembering report dates. You want to stay on top of AI/tech earnings without manually tracking every company.",
      "content": "<h3>AI-Powered Earnings Tracker</h3>\n<p>Following earnings season across dozens of tech companies means checking multiple sources and remembering report dates. You want to stay on top of AI/tech earnings without manually tracking every company.</p>\n<p>This workflow automates earnings tracking and delivery:</p>\n<p>• Weekly Sunday preview: scans the upcoming earnings calendar and posts relevant tech/AI companies to Telegram</p>\n<p>• You pick which companies you care about, and OpenClaw schedules one-shot cron jobs for each earnings date</p>\n<p>• After each report drops, OpenClaw searches for results, formats a detailed summary (beat/miss, key metrics, AI highlights), and delivers it</p>\n<h4>Skills you Need</h4>\n<ul><li>`web_search` (built-in)</li><li>Cron job support in OpenClaw</li><li>Telegram topic for earnings updates</li></ul>\n<h4>How to Set it Up</h4>\n<p>1. Create a Telegram topic called &quot;earnings&quot; for updates.</p>\n<p>2. Prompt OpenClaw:</p>\n<p>```text</p>\n<p>Every Sunday at 6 PM, run a cron job to:</p>\n<p>1. Search for the upcoming week&#39;s earnings calendar for tech and AI companies</p>\n<p>2. Filter for companies I care about (NVDA, MSFT, GOOGL, META, AMZN, TSLA, AMD, etc.)</p>\n<p>3. Post the list to my Telegram &quot;earnings&quot; topic</p>\n<p>4. Wait for me to confirm which ones I want to track</p>\n<p>When I reply with which companies to track:</p>\n<p>1. Schedule one-shot cron jobs for each earnings date/time</p>\n<p>2. After each report drops, search for earnings results</p>\n<p>3. Format a summary including: beat/miss, revenue, EPS, key metrics, AI-related highlights, guidance</p>\n<p>4. Post to Telegram &quot;earnings&quot; topic</p>\n<p>Keep a memory of which companies I typically track so you can auto-suggest them each week.</p>\n<p>```</p>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/earnings-tracker.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/earnings-tracker.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/earnings-tracker.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-health-symptom-tracker",
      "slug": "health-symptom-tracker",
      "title": "Health & Symptom Tracker",
      "category": "research",
      "tags": [
        "health",
        "symptom",
        "tracker"
      ],
      "rating": 83,
      "summary": "Identifying food sensitivities requires consistent logging over time, which is tedious to maintain. You need reminders to log and analysis to spot patterns.",
      "content": "<h3>Health &amp; Symptom Tracker</h3>\n<p>Identifying food sensitivities requires consistent logging over time, which is tedious to maintain. You need reminders to log and analysis to spot patterns.</p>\n<p>This workflow tracks food and symptoms automatically:</p>\n<p>• Message your food and symptoms in a dedicated Telegram topic and OpenClaw logs everything with timestamps</p>\n<p>• 3x daily reminders (morning, midday, evening) prompt you to log meals</p>\n<p>• Over time, analyzes patterns to identify potential triggers</p>\n<h4>Skills you Need</h4>\n<ul><li>Cron jobs for reminders</li><li>Telegram topic for logging</li><li>File storage (markdown log file)</li></ul>\n<h4>How to Set it Up</h4>\n<p>1. Create a Telegram topic called &quot;health-tracker&quot; (or similar).</p>\n<p>2. Create a log file: `~/clawd/memory/health-log.md`</p>\n<p>3. Prompt OpenClaw:</p>\n<p>```text</p>\n<p>When I message in the &quot;health-tracker&quot; topic:</p>\n<p>1. Parse the message for food items and symptoms</p>\n<p>2. Log to ~/clawd/memory/health-log.md with timestamp</p>\n<p>3. Confirm what was logged</p>\n<p>Set up 3 daily reminders:</p>\n<ul><li>8 AM: &quot;🍳 Log your breakfast&quot;</li><li>1 PM: &quot;🥗 Log your lunch&quot;</li><li>7 PM: &quot;🍽️ Log your dinner and any symptoms&quot;</li></ul>\n<p>Every Sunday, analyze the past week&#39;s log and identify patterns:</p>\n<ul><li>Which foods correlate with symptoms?</li><li>Are there time-of-day patterns?</li><li>Any clear triggers?</li></ul>\n<p>Post the analysis to the health-tracker topic.</p>\n<p>```</p>\n<p>4. Optional: Add a memory file for OpenClaw to track known triggers and update it as patterns emerge.</p>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/health-symptom-tracker.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/health-symptom-tracker.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/health-symptom-tracker.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-personal-crm",
      "slug": "personal-crm",
      "title": "Personal CRM with Automatic Contact Discovery",
      "category": "productivity",
      "tags": [
        "personal",
        "crm"
      ],
      "rating": 83,
      "summary": "Keeping track of who you've met, when, and what you discussed is impossible to do manually. Important follow-ups slip through the cracks, and you forget context before important meetings.",
      "content": "<h3>Personal CRM with Automatic Contact Discovery</h3>\n<p>Keeping track of who you&#39;ve met, when, and what you discussed is impossible to do manually. Important follow-ups slip through the cracks, and you forget context before important meetings.</p>\n<p>This workflow builds and maintains a personal CRM automatically:</p>\n<p>• Daily cron job scans email and calendar for new contacts and interactions</p>\n<p>• Stores contacts in a structured database with relationship context</p>\n<p>• Natural language queries: &quot;What do I know about [person]?&quot;, &quot;Who needs follow-up?&quot;, &quot;When did I last talk to [person]?&quot;</p>\n<p>• Daily meeting prep briefing: before each day&#39;s meetings, researches external attendees via CRM + email history and delivers a briefing</p>\n<h4>Skills you Need</h4>\n<ul><li>`gog` CLI (for Gmail and Google Calendar)</li><li>Custom CRM database (SQLite or similar) or use the [crm-query](https://clawhub.ai) skill if available</li><li>Telegram topic for CRM queries</li></ul>\n<h4>How to Set it Up</h4>\n<p>1. Create a CRM database:</p>\n<p>```sql</p>\n<p>CREATE TABLE contacts (</p>\n<p>id INTEGER PRIMARY KEY,</p>\n<p>name TEXT,</p>\n<p>email TEXT,</p>\n<p>first_seen TEXT,</p>\n<p>last_contact TEXT,</p>\n<p>interaction_count INTEGER,</p>\n<p>notes TEXT</p>\n<p>);</p>\n<p>```</p>\n<p>2. Set up a Telegram topic called &quot;personal-crm&quot; for queries.</p>\n<p>3. Prompt OpenClaw:</p>\n<p>```text</p>\n<p>Run a daily cron job at 6 AM to:</p>\n<p>1. Scan my Gmail and Calendar for the past 24 hours</p>\n<p>2. Extract new contacts and update existing ones</p>\n<p>3. Log interactions (meetings, emails) with timestamps and context</p>\n<p>Also, every morning at 7 AM:</p>\n<p>1. Check my calendar for today&#39;s meetings</p>\n<p>2. For each external attendee, search my CRM and email history</p>\n<p>3. Deliver a briefing to Telegram with: who they are, when we last spoke, what we discussed, and any follow-up items</p>\n<p>When I ask about a contact in the personal-crm topic, search the database and give me everything you know.</p>\n<p>```</p>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/personal-crm.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/personal-crm.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/personal-crm.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-phone-based-personal-assistant",
      "slug": "phone-based-personal-assistant",
      "title": "Phone-Based Personal Assistant",
      "category": "agents",
      "tags": [
        "phone",
        "based",
        "personal",
        "assistant"
      ],
      "rating": 83,
      "summary": "You want to access your AI agent from any phone without needing a smartphone app or internet browser. You need hands-free voice assistance while driving, walking, or when your hands are occupied.",
      "content": "<h3>Phone-Based Personal Assistant</h3>\n<h4>Pain Point</h4>\n<p>You want to access your AI agent from any phone without needing a smartphone app or internet browser. You need hands-free voice assistance while driving, walking, or when your hands are occupied.</p>\n<h4>What It Does</h4>\n<p>ClawdTalk enables OpenClaw to receive and make phone calls, turning any phone into a gateway to your AI assistant. You can:</p>\n<ul><li>Call a phone number to speak with your AI agent via voice</li><li>Get calendar reminders, Jira updates, and web search results via voice</li><li>Integrate with Telnyx for reliable phone connectivity</li></ul>\n<p>SMS support is coming soon.</p>\n<h4>Prompts</h4>\n<p>```</p>\n<p>You are available via phone. When I call, greet me and ask how I can help.</p>\n<p>For calendar queries: &quot;What&#39;s on my calendar today?&quot;</p>\n<p>For Jira updates: &quot;Show me my open tickets&quot;</p>\n<p>For web search: &quot;Search for latest news on AI agents&quot;</p>\n<p>```</p>\n<h4>Skills Needed</h4>\n<ul><li>[ClawdTalk](https://github.com/team-telnyx/clawdtalk-client)</li><li>Calendar skill (Google Calendar or Outlook)</li><li>Jira skill</li><li>Web search skill</li></ul>\n<h4>Related Links</h4>\n<ul><li>[ClawdTalk Website](https://clawdtalk.com)</li><li>[ClawdTalk GitHub](https://github.com/team-telnyx/clawdtalk-client)</li><li>[Telnyx API](https://telnyx.com/)</li><li>[OpenClaw Skills](https://github.com/openclaw/skills)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/phone-based-personal-assistant.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/phone-based-personal-assistant.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/phone-based-personal-assistant.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-todoist-task-manager",
      "slug": "todoist-task-manager",
      "title": "Todoist Task Manager: Agent Task Visibility",
      "category": "agents",
      "tags": [
        "todoist",
        "task",
        "manager"
      ],
      "rating": 83,
      "summary": "Maximize transparency for long-running agentic workflows by syncing internal reasoning and progress logs directly to Todoist.",
      "content": "<h3>Todoist Task Manager: Agent Task Visibility</h3>\n<p>Maximize transparency for long-running agentic workflows by syncing internal reasoning and progress logs directly to Todoist.</p>\n<h4>Pain Point</h4>\n<p>When agents run complex, multi-step tasks (like building a full-stack app or performing deep research), the user often loses track of what the agent is currently doing, what steps have been completed, and where the agent might be stuck. Checking chat logs manually is tedious for background tasks.</p>\n<h4>What It Does</h4>\n<p>This use case uses the `todoist-task-manager` skill to:</p>\n<p>1.  **Visualize State**: Create tasks in specific sections like `🟡 In Progress` or `🟠 Waiting`.</p>\n<p>2.  **Externalize Reasoning**: Post the agent&#39;s internal &quot;Plan&quot; into the task description.</p>\n<p>3.  **Stream Logs**: Add sub-step completions as comments to the task in real-time.</p>\n<p>4.  **Auto-Reconcile**: A heartbeat script checks for stalled tasks and notifies the user.</p>\n<h4>Skills you Need</h4>\n<p>You don&#39;t need a pre-built skill. Simply prompt your OpenClaw agent to create the bash scripts described in the **Setup Guide** below. Since OpenClaw can manage its own filesystem and execute shell commands, it will effectively &quot;build&quot; the skill for you upon request.</p>\n<h4>Detailed Setup Guide</h4>\n<p>### 1. Configure Todoist</p>\n<p>Create a project (e.g., &quot;OpenClaw Workspace&quot;) and get its ID. Create sections for different states:</p>\n<ul><li>`🟡 In Progress`</li><li>`🟠 Waiting`</li><li>`🟢 Done`</li></ul>\n<p>### 2. Implementation: The &quot;Agent-Built&quot; Skill</p>\n<p>Instead of installing a skill, you can ask OpenClaw to create these scripts for you. Each script handles a different part of the communication with the Todoist API.</p>\n<p>**`scripts/todoist_api.sh`** (The Core Wrapper):</p>\n<p>```bash</p>\n<p>#!/bin/bash</p>\n<h3>Usage: ./todoist_api.sh &lt;endpoint&gt; &lt;method&gt; [data_json]</h3>\n<p>ENDPOINT=$1</p>\n<p>METHOD=$2</p>\n<p>DATA=$3</p>\n<p>TOKEN=&quot;YOUR_TODOIST_API_TOKEN&quot;</p>\n<p>if [ -z &quot;$DATA&quot; ]; then</p>\n<p>curl -s -X &quot;$METHOD&quot; &quot;https://api.todoist.com/rest/v2/$ENDPOINT&quot; \\</p>\n<p>-H &quot;Authorization: Bearer $TOKEN&quot;</p>\n<p>else</p>\n<p>curl -s -X &quot;$METHOD&quot; &quot;https://api.todoist.com/rest/v2/$ENDPOINT&quot; \\</p>\n<p>-H &quot;Authorization: Bearer $TOKEN&quot; \\</p>\n<p>-H &quot;Content-Type: application/json&quot; \\</p>\n<p>-d &quot;$DATA&quot;</p>\n<p>fi</p>\n<p>```</p>\n<p>**`scripts/sync_task.sh`** (Task &amp; Status Management):</p>\n<p>```bash</p>\n<p>#!/bin/bash</p>\n<h3>Usage: ./sync_task.sh &lt;task_content&gt; &lt;status&gt; [task_id] [description] [labels_json_array]</h3>\n<p>CONTENT=$1</p>\n<p>STATUS=$2</p>\n<p>TASK_ID=$3</p>\n<p>DESCRIPTION=$4</p>\n<p>LABELS=$5</p>\n<p>PROJECT_ID=&quot;YOUR_PROJECT_ID&quot;</p>\n<p>case $STATUS in</p>\n<p>&quot;In Progress&quot;) SECTION_ID=&quot;SECTION_ID_PROGRESS&quot; ;;</p>\n<p>&quot;Waiting&quot;)     SECTION_ID=&quot;SECTION_ID_WAITING&quot; ;;</p>\n<p>&quot;Done&quot;)        SECTION_ID=&quot;SECTION_ID_DONE&quot; ;;</p>\n<p>*)             SECTION_ID=&quot;&quot; ;;</p>\n<p>esac</p>\n<p>PAYLOAD=&quot;{\\&quot;content\\&quot;: \\&quot;$CONTENT\\&quot;&quot;</p>\n<p>[ -n &quot;$SECTION_ID&quot; ] &amp;&amp; PAYLOAD=&quot;$PAYLOAD, \\&quot;section_id\\&quot;: \\&quot;$SECTION_ID\\&quot;&quot;</p>\n<p>[ -n &quot;$PROJECT_ID&quot; ] &amp;&amp; [ -z &quot;$TASK_ID&quot; ] &amp;&amp; PAYLOAD=&quot;$PAYLOAD, \\&quot;project_id\\&quot;: \\&quot;$PROJECT_ID\\&quot;&quot;</p>\n<p>if [ -n &quot;$DESCRIPTION&quot; ]; then</p>\n<p>ESC_DESC=$(echo &quot;$DESCRIPTION&quot; | sed &#39;:a;N;$!ba;s/\\n/\\\\n/g&#39; | sed &#39;s/&quot;/\\\\&quot;/g&#39;)</p>\n<p>PAYLOAD=&quot;$PAYLOAD, \\&quot;description\\&quot;: \\&quot;$ESC_DESC\\&quot;&quot;</p>\n<p>fi</p>\n<p>[ -n &quot;$LABELS&quot; ] &amp;&amp; PAYLOAD=&quot;$PAYLOAD, \\&quot;labels\\&quot;: $LABELS&quot;</p>\n<p>PAYLOAD=&quot;$PAYLOAD}&quot;</p>\n<p>if [ -n &quot;$TASK_ID&quot; ]; then</p>\n<p>./scripts/todoist_api.sh &quot;tasks/$TASK_ID&quot; POST &quot;$PAYLOAD&quot;</p>\n<p>else</p>\n<p>./scripts/todoist_api.sh &quot;tasks&quot; POST &quot;$PAYLOAD&quot;</p>\n<p>fi</p>\n<p>```</p>\n<p>**`scripts/add_comment.sh`** (Progress Logging):</p>\n<p>```bash</p>\n<p>#!/bin/bash</p>\n<h3>Usage: ./add_comment.sh &lt;task_id&gt; &lt;comment_text&gt;</h3>\n<p>TASK_ID=$1</p>\n<p>TEXT=$2</p>\n<p>ESC_TEXT=$(echo &quot;$TEXT&quot; | sed &#39;:a;N;$!ba;s/\\n/\\\\n/g&#39; | sed &#39;s/&quot;/\\\\&quot;/g&#39;)</p>\n<p>PAYLOAD=&quot;{\\&quot;task_id\\&quot;: \\&quot;$TASK_ID\\&quot;, \\&quot;content\\&quot;: \\&quot;$ESC_TEXT\\&quot;}&quot;</p>\n<p>./scripts/todoist_api.sh &quot;comments&quot; POST &quot;$PAYLOAD&quot;</p>\n<p>```</p>\n<p>### 3. Usage Prompt</p>\n<p>You can give this prompt to your agent to both **setup** and **use** the visibility system:</p>\n<p>```text</p>\n<p>I want you to build a Todoist-based task visibility system for your own runs.</p>\n<p>First, create three bash scripts in a &#39;scripts/&#39; folder:</p>\n<p>1. todoist_api.sh (a curl wrapper for Todoist REST API)</p>\n<p>2. sync_task.sh (to create or update tasks with specific section_ids for In Progress, Waiting, and Done)</p>\n<p>3. add_comment.sh (to post progress logs as comments)</p>\n<p>Use these variables for the setup:</p>\n<ul><li>Token: [Your Todoist API Token]</li><li>Project ID: [Your Project ID]</li><li>Section IDs: [In Progress ID, Waiting ID, Done ID]</li></ul>\n<p>Once created, for every complex task I give you:</p>\n<p>1. Create a task in &#39;In Progress&#39; with your full PLAN in the description.</p>\n<p>2. For every sub-step completion, call add_comment.sh with a log of what you did.</p>\n<p>3. Move the task to &#39;Done&#39; when finished.</p>\n<p>```</p>\n<h4>Related Links</h4>\n<ul><li>[Todoist REST API Documentation](https://developer.todoist.com/rest/v2/)</li></ul>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/todoist-task-manager.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/todoist-task-manager.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/todoist-task-manager.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-daily-reddit-digest",
      "slug": "daily-reddit-digest",
      "title": "Daily Reddit Digest",
      "category": "productivity",
      "tags": [
        "daily",
        "reddit",
        "digest"
      ],
      "rating": 79,
      "summary": "Run a daily digest everyday to give you the top performing posts from your favourite subreddits.",
      "content": "<h3>Daily Reddit Digest</h3>\n<p>Run a daily digest everyday to give you the top performing posts from your favourite subreddits.</p>\n<p>What to use it for:</p>\n<p>• Browsing subreddits (hot/new/top posts)</p>\n<p>• Searching posts by topic</p>\n<p>• Pulling comment threads for context</p>\n<p>• Building shortlists of posts to manually review/reply to later</p>\n<p>&gt; It&#39;s read-only. No posting, voting, or commenting.</p>\n<h4>Skills you Need</h4>\n<p>[reddit-readonly](https://clawhub.ai/buksan1950/reddit-readonly) skill. It doesn&#39;t need auth.</p>\n<h4>How to Set it Up</h4>\n<p>After installing the skill, prompt your OpenClaw:</p>\n<p>```text</p>\n<p>I want you to give me the top performing posts from the following subreddits.</p>\n<p>&lt;paste the list here&gt;</p>\n<p>Create a separate memory for the reddit processes, about the type of posts I like to see and every day ask me if I liked the list you provided. Save my preference as rules in the memory to use for a better digest curation. (e.g. do not include memes.)</p>\n<p>Every day at 5pm, run this process and give me the digest.</p>\n<p>```</p>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/daily-reddit-digest.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/daily-reddit-digest.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/daily-reddit-digest.md"
    },
    {
      "id": "community-usecase-awesome-openclaw-usecases-inbox-declutter",
      "slug": "inbox-declutter",
      "title": "Inbox De-clutter",
      "category": "productivity",
      "tags": [
        "inbox",
        "declutter"
      ],
      "rating": 78,
      "summary": "Newsletters can take up the inbox like nothing else. Often times they pile-up without being opened at all.",
      "content": "<h3>Inbox De-clutter</h3>\n<p>Newsletters can take up the inbox like nothing else. Often times they pile-up without being opened at all.</p>\n<h4>Skills you Need</h4>\n<p>[Gmail OAuth Setup](https://clawhub.ai/kai-jar/gmail-oauth).</p>\n<h4>How to Set it Up</h4>\n<p>1. [optional] Create a new gmail specifically for OpenClaw.</p>\n<p>2. [optional] Unsubscribe from all newsletters from your main email and subscribe to them using the OpenClaw email.</p>\n<p>3. Install the skill and make sure it works.</p>\n<p>4. Instruct OpenClaw:</p>\n<p>```txt</p>\n<p>I want you to run a cron job everyday at 8 p.m. to read all the newsletter emails of the past 24 hours and give me a digest of the most important bits along with links to read more. Then ask for my feedback on whether you picked good bits, and update your memory based on my preferences for better digests in the future jobs.</p>\n<p>```</p>",
      "source": "awesome-openclaw-usecases",
      "sourceDetail": "community/usecases/inbox-declutter.md",
      "sourcePath": "awesome-openclaw-usecases-main/usecases/inbox-declutter.md",
      "url": "https://github.com/openclaw/awesome-openclaw-usecases/blob/main/usecases/inbox-declutter.md"
    }
  ]
}
