# Mux Runtime Auth Design (Shared Register Key + Per-Instance JWT)

## Status

Implemented.

## TL;DR

- Keep transport as HTTP.
- All OpenClaw instances use one shared mux register key for register only.
- Each OpenClaw instance has a stable `openclawId` generated locally by OpenClaw.
- mux issues a long-lived runtime JWT at register time (minimum 24 hours).
- mux uses a separate short-lived inbound JWT (per delivery) for mux -> OpenClaw inbound calls.
- Every runtime request carries `openclawId` in both header and body.
- No invite flow, no max claim flow, no per-instance secrets generated by control plane.

## Why This Design

### What we want

- Very simple operator setup: only mux URL + shared register key.
- Strong per-instance runtime auth.
- No persisted mux-issued identity that can be lost.
- No WebSocket complexity or stuck-connection risks.

### Why not use `openclawId` as token

- `openclawId` is sent often and is not treated as secret.
- If identity equals token, identity leak becomes auth leak.
- Rotation is harder because identity and auth are tied together.

### Why JWT is a good fit here

- mux can mint scoped per-instance auth tokens with controlled expiry and easy rotation.
- OpenClaw can verify inbound requests from mux via JWKS at `${baseUrl}/.well-known/jwks.json`.
- If a long-lived runtime JWT leaks, it must not allow injecting inbound messages into OpenClaw.

## Core Model

### Keys

1. `registerKey` (shared by all OpenClaw instances)

- Configured on mux and OpenClaw.
- Used only for `POST /v1/instances/register`.

2. JWT signing key (mux only)

- Private key on mux (Ed25519).
- Public key exposed via JWKS at `GET /.well-known/jwks.json`.

### Identity

- `openclawId` is generated by OpenClaw, not mux-issued.
- OpenClaw uses its existing device identity `deviceId` as `openclawId`.
- If OpenClaw state is lost, a new `openclawId` will be generated and the instance must re-register.

## Config

### OpenClaw config

```json
{
  "gateway": {
    "http": {
      "endpoints": {
        "mux": {
          "enabled": true,
          "baseUrl": "https://mux.example.com",
          "registerKey": "mux-register-shared-key",
          "inboundUrl": "https://openclaw-host.example.com/v1/mux/inbound"
        }
      }
    }
  }
}
```

Runtime cache/state (local):

- `runtimeToken` (refreshable; minimum 24h lifetime)
- `runtimeTokenExpiresAtMs`

### mux env

- `MUX_REGISTER_KEY=<shared-register-key>` (required to enable `POST /v1/instances/register`)
- `MUX_JWT_PRIVATE_KEY=<ed25519-private-key-pem>` (optional; if unset, mux generates a new key on boot)

## API Design

## 1) Register endpoint

### `POST /v1/instances/register`

Auth:

- `Authorization: Bearer <registerKey>`

Request:

```json
{
  "openclawId": "oc_abcd1234...",
  "inboundUrl": "https://openclaw-host.example.com/v1/mux/inbound",
  "inboundTimeoutMs": 15000,
  "instanceMeta": {
    "version": "v2026.2.12",
    "region": "phala-us-1"
  }
}
```

Response:

```json
{
  "ok": true,
  "openclawId": "oc_abcd1234...",
  "runtimeToken": "<jwt>",
  "expiresAtMs": 1770900000000,
  "tokenType": "Bearer"
}
```

Behavior:

- Upsert instance by `openclawId`.
- Update inbound target and timeout.
- Mint runtime JWT with per-instance claims and >=24h expiry.
- Return token + expiry.

## 1.5) JWKS endpoint

### `GET /.well-known/jwks.json`

Auth:

- none

Response:

- Standard JWKS document with active signing keys.
- Each key must include `kid` used in runtime JWT headers.

Behavior:

- OpenClaw uses this endpoint to validate mux-issued JWT signatures.
- During rotation, mux serves old + new keys until overlap window ends.

## 2) Runtime outbound endpoint

### `POST /v1/mux/outbound/send`

Auth:

- `Authorization: Bearer <runtimeJwt>`

Headers:

- `X-OpenClaw-Id: <openclawId>`
- `Idempotency-Key: <requestId>` (existing behavior)

Body:

- Existing mux outbound body plus `openclawId`.

Validation:

- JWT signature valid.
- `aud` equals `mux-server`.
- not expired.
- `sub` equals header `X-OpenClaw-Id`.
- `sub` equals body `openclawId`.
- scope allows outbound (for example `mux:outbound`).

## 3) Runtime inbound to OpenClaw

### mux -> OpenClaw `POST /v1/mux/inbound`

Auth:

- `Authorization: Bearer <inboundJwt>`

Headers:

- `X-OpenClaw-Id: <openclawId>`

Body:

- Existing inbound envelope plus `openclawId`.

OpenClaw validation:

- JWT signature valid (JWKS).
- `aud` equals `openclaw-mux-inbound`.
- not expired.
- `sub` equals local computed `openclawId`.
- header/body `openclawId` both equal local id.
- scope allows inbound (for example `mux:inbound`).

## JWT Claims

Recommended claims:

```json
{
  "iss": "https://mux.example.com",
  "sub": "oc_abcd1234...",
  "aud": ["mux-server", "openclaw-mux-inbound"],
  "scope": "mux:outbound mux:inbound",
  "jti": "uuid",
  "iat": 1770899100,
  "nbf": 1770899100,
  "exp": 1770900000
}
```

## Storage Model (mux)

Replace tenant-centric auth routing with instance-centric auth routing.

### `instances` table

- `openclaw_id TEXT PRIMARY KEY`
- `runtime_token_hash TEXT NULL` (optional cache/introspection)
- `inbound_url TEXT NOT NULL`
- `inbound_timeout_ms INTEGER NOT NULL`
- `status TEXT NOT NULL DEFAULT 'active'`
- `last_seen_at_ms INTEGER NOT NULL`
- `created_at_ms INTEGER NOT NULL`
- `updated_at_ms INTEGER NOT NULL`

### routing data

Bindings/session routes must reference `openclaw_id` so inbound forwarding selects the right instance target.

## Token Lifecycle

### Refresh strategy (OpenClaw)

- Refresh when token is near expiry (for example less than 6 hours left, or less than 10% TTL remaining).
- If runtime request gets `401`, re-register and retry once.
- If re-register fails, keep exponential backoff and surface clear error.

### Key rotation (mux signing key)

- Prefer JWKS with `kid`.
- Serve old + new keys during rotation overlap window.
- New tokens use new `kid`; old tokens remain valid until expiry.

## Security Rules

- Register endpoint protected only by shared `registerKey`.
- Runtime endpoints accept only mux-issued JWT, never register key.
- Strict algorithm allowlist (for example `EdDSA` or `ES256` only).
- Reject tokens without expected `kid`/`iss`/`aud`/`sub`/`exp`.
- Keep JWT TTL at least 24 hours per product requirement.
- For longer TTLs, support emergency revoke by `jti` denylist or signing-key rotation.
- Redact tokens from logs.
- Validate `inboundUrl`:
- scheme rules (`https` in production)
- block loopback/link-local/private ranges unless explicitly allowed
- canonicalize and trim trailing slash rules

## Reliability

- Transport remains HTTP, so no persistent socket health issues.
- Keep existing ack/retry behavior in mux inbound loops.
- Registration is idempotent by `openclawId`.
- If mux DB resets, OpenClaw re-registers and self-heals.
- If OpenClaw loses runtime token cache, it re-registers.

## Scalability

- No per-instance always-on socket in mux.
- Cost scales with message traffic, not idle connection count.
- Register calls are low-frequency.
- Fits current MVP posture better than WS transport.

## Failure Modes and Recovery

1. OpenClaw restart

- Recompute `openclawId`.
- Reuse valid runtime token if present, else re-register.

2. mux restart

- No client-side reconnect storm for sockets (HTTP model).
- Existing retry/idempotency handles transient failures.

3. Token expiry mid-flight

- First request fails with `401`.
- OpenClaw re-registers and retries once.

4. Clock skew

- Allow small leeway for `nbf`/`exp` checks (for example 60 seconds).

## Backward Compatibility

Not required for pre-launch mode.

Design assumes:

- no legacy invite endpoints
- no legacy admin bootstrap endpoint in final shape

## Implementation Outline

1. Config/schema changes (OpenClaw)

- Add `gateway.http.endpoints.mux.registerKey`.
- Add runtime token cache handling.

2. mux server changes

- Add register endpoint.
- Add JWT signer + JWKS endpoint.
- Add instance registry table.
- Rewire routing lookup to `openclawId`.
- Enforce JWT auth on runtime endpoints.

3. OpenClaw runtime changes

- Add register client call.
- Attach `openclawId` header/body on outbound.
- Verify JWT on inbound mux endpoint.
- Replace static shared token check for mux inbound.

4. tests

- register auth success/failure
- outbound JWT validation
- inbound JWT validation on OpenClaw
- refresh/retry on expiry
- routing by `openclawId`

## Open Questions

1. Should OpenClaw pin mux public key in config, or rely on JWKS URL only?
2. Exact allowed `inboundUrl` policy in self-hosted non-prod.
3. Preferred JWT algorithm (`EdDSA` recommended for simple key handling).
