/**
 * Session start memory hook handler
 *
 * Loads workspace memory files into session context at agent bootstrap
 * Enforces memory continuity by making memory loading structural, not optional
 */

import fs from "node:fs/promises";
import path from "node:path";
import type { AgentBootstrapHookEvent } from "../../internal-hooks.js";
import { resolveHookConfig } from "../../config.js";

interface SessionStartMemoryConfig {
  enabled?: boolean;
  /** Paths to always load (relative to workspace) */
  paths?: string[];
  /** Number of recent days to load from memory/ directory */
  recentDays?: number;
}

/**
 * Validate that a path stays within workspace bounds
 */
function isPathWithinWorkspace(workspaceDir: string, targetPath: string): boolean {
  const resolved = path.resolve(workspaceDir, targetPath);
  const normalized = path.normalize(resolved);
  return normalized.startsWith(path.normalize(workspaceDir));
}

/**
 * Get recent memory files from memory/ directory
 */
async function getRecentMemoryFiles(
  workspaceDir: string,
  recentDays: number,
): Promise<Array<{ path: string; content: string }>> {
  const memoryDir = path.join(workspaceDir, "memory");
  
  try {
    const entries = await fs.readdir(memoryDir);
    // Use UTC for consistent date comparison
    const now = new Date();
    const cutoffDate = new Date(Date.UTC(
      now.getUTCFullYear(),
      now.getUTCMonth(),
      now.getUTCDate() - recentDays
    ));
    
    const recentFiles: Array<{ path: string; content: string }> = [];
    
    for (const entry of entries) {
      // Match YYYY-MM-DD*.md pattern
      const match = entry.match(/^(\d{4}-\d{2}-\d{2}).*\.md$/);
      if (!match) continue;
      
      // Parse as UTC to match cutoff date basis
      const fileDate = new Date(match[1] + "T00:00:00Z");
      if (fileDate >= cutoffDate) {
        const filePath = path.join(memoryDir, entry);
        try {
          const content = await fs.readFile(filePath, "utf-8");
          recentFiles.push({
            path: `memory/${entry}`,
            content,
          });
        } catch {
          // Skip files that can't be read
          continue;
        }
      }
    }
    
    // Sort by date descending (newest first)
    recentFiles.sort((a, b) => b.path.localeCompare(a.path));
    return recentFiles;
    
  } catch {
    // memory/ directory doesn't exist or can't be read
    return [];
  }
}

/**
 * Load workspace memory into session context at agent bootstrap
 */
const handler = async (event: AgentBootstrapHookEvent) => {
  // Only run on agent:bootstrap
  if (event.type !== "agent" || event.action !== "bootstrap") {
    return;
  }

  const workspaceDir = event.context.workspaceDir;
  if (!workspaceDir) {
    return;
  }

  try {
    const config = resolveHookConfig<SessionStartMemoryConfig>(
      "session-start-memory",
      event.context.cfg,
    );

    // Respect enabled flag
    if (config.enabled === false) {
      return;
    }

    const paths = config.paths || ["MEMORY.md", "memory/continuity-test.md"];
    const recentDays = config.recentDays ?? 2;

    const sections: string[] = [];

    // Load configured paths
    for (const relPath of paths) {
      // Validate path stays within workspace
      if (!isPathWithinWorkspace(workspaceDir, relPath)) {
        console.error(`[session-start-memory] Skipping path outside workspace: ${relPath}`);
        continue;
      }
      
      const fullPath = path.join(workspaceDir, relPath);
      try {
        const content = await fs.readFile(fullPath, "utf-8");
        const filename = path.basename(relPath);
        sections.push(`## ${filename}\n\n${content}`);
      } catch {
        // File doesn't exist or can't be read - skip silently
        continue;
      }
    }

    // Load recent memory files
    const recentFiles = await getRecentMemoryFiles(workspaceDir, recentDays);
    if (recentFiles.length > 0) {
      sections.push(
        `## Recent Memory (Last ${recentDays} Days)\n\n` +
        recentFiles.map(f => `### ${f.path}\n\n${f.content}`).join("\n\n")
      );
    }

    // Only inject if we found any content
    if (sections.length === 0) {
      return;
    }

    const now = new Date().toISOString();
    const content = `# Current Session Memory
*Auto-generated at ${now}*

${sections.join("\n\n---\n\n")}

---

**Note:** This file is automatically generated at session start to load workspace memory into context.
`;

    // Inject into bootstrap files
    if (event.context.bootstrapFiles) {
      event.context.bootstrapFiles.push({
        path: "CURRENT_SESSION_MEMORY.md",
        content,
        source: "hook:session-start-memory",
      });
    }
    
  } catch (err) {
    console.error(
      "[session-start-memory] Failed to load memory:",
      err instanceof Error ? err.message : String(err)
    );
  }
};

export default handler;
