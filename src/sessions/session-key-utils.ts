/**
 * Pattern matching delegate/subagent spawn session IDs.
 *
 * These IDs are generated by:
 *   - scripts/lib/delegate.mjs  →  `delegate-${Date.now()}-${rand}`
 *   - dispatch-from-config.ts   →  `routed-${Date.now()}-${rand}`
 *   - (future)                  →  `subagent-${Date.now()}-${rand}`
 *
 * If you add a new spawn ID prefix, update this regex.
 * Used by the session contamination guard to detect when a non-subagent
 * session key (e.g. "agent:voice:main") has been corrupted with a
 * delegate's session ID.
 */
export const SPAWN_SESSION_ID_PATTERN = /^(delegate|routed|subagent)-\d{10,}/;

/**
 * Returns true if `sessionId` looks like a delegate/subagent spawn ID
 * AND the `sessionKey` is NOT a subagent key — meaning the ID is contamination,
 * not a legitimate subagent session.
 */
export function isContaminatedSessionId(
  sessionKey: string | undefined,
  sessionId: string | undefined,
): boolean {
  if (!sessionKey || !sessionId) {
    return false;
  }
  if (isSubagentSessionKey(sessionKey)) {
    return false;
  }
  return SPAWN_SESSION_ID_PATTERN.test(sessionId);
}

/**
 * Returns true if a session entry's `sessionFile` does not match its
 * `sessionId`. This catches a contamination variant where the sessionId
 * looks normal but the sessionFile points to a completely different
 * session's transcript (e.g. a remediation, cron, or boot session file
 * leaked into the main agent session entry).
 */
export function isContaminatedSessionFile(
  sessionId: string | undefined,
  sessionFile: string | undefined,
): boolean {
  if (!sessionId || !sessionFile) {
    return false;
  }
  const basename = sessionFile.split("/").pop() ?? "";
  return !basename.includes(sessionId);
}

export type ParsedAgentSessionKey = {
  agentId: string;
  rest: string;
};

export function parseAgentSessionKey(
  sessionKey: string | undefined | null,
): ParsedAgentSessionKey | null {
  const raw = (sessionKey ?? "").trim();
  if (!raw) {
    return null;
  }
  const parts = raw.split(":").filter(Boolean);
  if (parts.length < 3) {
    return null;
  }
  if (parts[0] !== "agent") {
    return null;
  }
  const agentId = parts[1]?.trim();
  const rest = parts.slice(2).join(":");
  if (!agentId || !rest) {
    return null;
  }
  return { agentId, rest };
}

export function isCronRunSessionKey(sessionKey: string | undefined | null): boolean {
  const parsed = parseAgentSessionKey(sessionKey);
  if (!parsed) {
    return false;
  }
  return /^cron:[^:]+:run:[^:]+$/.test(parsed.rest);
}

export function isCronSessionKey(sessionKey: string | undefined | null): boolean {
  const parsed = parseAgentSessionKey(sessionKey);
  if (!parsed) {
    return false;
  }
  return parsed.rest.toLowerCase().startsWith("cron:");
}

export function isSubagentSessionKey(sessionKey: string | undefined | null): boolean {
  const raw = (sessionKey ?? "").trim();
  if (!raw) {
    return false;
  }
  if (raw.toLowerCase().startsWith("subagent:")) {
    return true;
  }
  const parsed = parseAgentSessionKey(raw);
  return Boolean((parsed?.rest ?? "").toLowerCase().startsWith("subagent:"));
}

export function getSubagentDepth(sessionKey: string | undefined | null): number {
  const raw = (sessionKey ?? "").trim().toLowerCase();
  if (!raw) {
    return 0;
  }
  return raw.split(":subagent:").length - 1;
}

export function isAcpSessionKey(sessionKey: string | undefined | null): boolean {
  const raw = (sessionKey ?? "").trim();
  if (!raw) {
    return false;
  }
  const normalized = raw.toLowerCase();
  if (normalized.startsWith("acp:")) {
    return true;
  }
  const parsed = parseAgentSessionKey(raw);
  return Boolean((parsed?.rest ?? "").toLowerCase().startsWith("acp:"));
}

const THREAD_SESSION_MARKERS = [":thread:", ":topic:"];

export function resolveThreadParentSessionKey(
  sessionKey: string | undefined | null,
): string | null {
  const raw = (sessionKey ?? "").trim();
  if (!raw) {
    return null;
  }
  const normalized = raw.toLowerCase();
  let idx = -1;
  for (const marker of THREAD_SESSION_MARKERS) {
    const candidate = normalized.lastIndexOf(marker);
    if (candidate > idx) {
      idx = candidate;
    }
  }
  if (idx <= 0) {
    return null;
  }
  const parent = raw.slice(0, idx).trim();
  return parent ? parent : null;
}
