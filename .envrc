#!/bin/bash
#
# Install https://direnv.net/ to load this file automatically
#

if [[ -n "${ENVRC:-}" ]]; then
    return
fi
export ENVRC=1

# Hook pre-commit
if [[ -f .pre-commit-config.yaml ]] \
    && command -v pre-commit &>/dev/null \
    && ! grep -q pre-commit .git/hooks/pre-commit; then
    echo "direnv: initializing pre-commit"
    pre-commit install
fi

if [[ -d .envrc.d ]]; then
    # Load all .envrc files in .envrc.d directory, guard against sourcing errors.
    for file in .envrc.d/*.sh; do
        source_env_if_exists "$file"
    done
fi

# Define the actual script logic functions
clean_filter_func() {
    # 使用 awk 來簡化配置合併邏輯
    # 直接合併 .env 和 .env-store 檔案，跳過系統變數

    # 設置 umask 確保新創建的文件權限為 0600
    umask 077

    # 過濾並合併配置檔案
    {
        # 如果 .env-store 存在，先輸出（優先級較低）
        if [[ -f .env-store ]]; then
            cat .env-store
        fi
        # 輸出 .env 檔案（優先級較高，會覆蓋重複的 key）
        if [[ -f .env ]]; then
            cat .env
        fi
    } | awk '
		# 處理包含 = 的值，只分割第一個 = 符號
		/^[^=]+=/ {
			# 找到第一個 = 的位置
			pos = index($0, "=")
			if (pos > 0) {
				key = substr($0, 1, pos-1)

				# 使用 awk 邏輯：後面的值會覆蓋前面的值
				if (!seen[key]++) {
					print
				} else {
					val[key] = $0
				}
			}
		}
		END {
			for(k in val) print val[k]
		}
	' | sort >.env-store

    # 處理輸入並輸出到 filter stdout
    sed -E -e "/^[^#=]+=/s/=.*/=/" -

    # 確保已存在的文件權限正確（umask 只影響新創建的文件）
    if [[ -f .env ]]; then
        chmod 0600 .env
    fi
    chmod 0600 .env-store
}

smudge_filter_func() {
    # shellcheck disable=SC2016

    # 設置 umask 確保新創建的文件權限為 0600
    umask 077

    if [[ -f .env-store ]]; then
        set -a
        # shellcheck source=/dev/null
        source .env-store
        set +a
    fi
    while IFS= read -r line; do
        if echo "$line" | grep -qE '^[^#=]+='; then
            key=$(echo "$line" | cut -d= -f1)
            value="${!key}"
            # 如果值包含空格或特殊字符，需要用雙引號包圍
            if [[ "$value" =~ [[:space:]] ]] || [[ "$value" =~ [\"\$\`\\] ]]; then
                echo "$key=\"$value\""
            else
                echo "$key=$value"
            fi
        else
            echo "$line"
        fi
    done

    # 如果輸出的內容被寫入 .env 文件，確保權限為 0600
    # 注意：smudge filter 通常不會直接寫入文件，但為安全起見保留此邏輯
    if [[ -f .env ]]; then
        chmod 0600 .env
    fi
}

# KISS & DRY: Single generic function for script generation
generate_filter_script() {
    local func_name="$1"
    if [[ "$func_name" == clean ]]; then
        func_name="clean_filter_func"
    elif [[ "$func_name" == smudge ]]; then
        func_name="smudge_filter_func"
    else
        echo "direnv: invalid filter function name: $func_name" >&2
        return 1
    fi
    echo '#!/bin/bash'
    declare -f "${func_name}"
    echo "${func_name} \"\$@\""
}

# Function to setup a specific git filter hook (simplified with diff)
setup_hook() {
    local hook_type="$1"
    local script_file=".git/${hook_type}_filter.sh"
    local temp_file="${script_file}.tmp"
    local git_config_key="filter.sanitize-env.${hook_type}"

    # Generate to temp file and compare with diff
    generate_filter_script "$hook_type" >"$temp_file"
    if [[ -f "$script_file" ]] && diff "$script_file" "$temp_file" >/dev/null 2>&1; then
        rm -f "$temp_file"
    else
        mv "$temp_file" "$script_file"
        chmod +x "$script_file"
    fi

    # Set git config
    local expected_config_value=".git/${hook_type}_filter.sh"
    if [[ $(git config --get "$git_config_key") != "$expected_config_value" ]]; then
        git config "$git_config_key" "$expected_config_value"
    fi
}

setup_git_env_filter() {
    if [[ ! -d .git ]] || [[ ! -f .env ]]; then
        return
    fi
    # Setup both git filter hooks
    setup_hook clean
    setup_hook smudge
    # Remove unused .env files from .gitignore
    sed -E -i '/^\/\.env$|^\/\.env-store$/d' .gitignore

    # Add .env-store to .gitignore if not already present
    if ! grep "^/.env-store\*$" .gitignore &>/dev/null; then
        echo "/.env-store*" >>.gitignore
    fi

}
# Config git .env sanitize
if [[ -f .env ]]; then
    # 設置 umask 確保新創建的 .env 相關文件權限為 0600
    # umask 077 = 文件權限 600 (rw-------)
    umask 077
    # 修正已存在的 .env 文件權限（如果需要的話）
    chmod 0600 .env
    # Load .env file
    dotenv .env

    if ! grep "^/.env" .gitattributes &>/dev/null; then
        echo "/.env filter=sanitize-env" >>.gitattributes
    fi
    setup_git_env_filter

fi

# Load python environment
if [[ -f uv.lock ]]; then
    if [[ ! -d .venv ]]; then
        echo "direnv: creating uv venv"
        uv sync --venv .venv
    fi
    export VIRTUAL_ENV=."venv"
    layout python
elif [[ -f pyproject.toml ]] && command -v poetry &>/dev/null && grep -q poetry pyproject.toml; then
    log_status "loading Poetry"

    if ! direnv_load poetry run direnv dump; then
        log_error "failed to enter Poetry env, do you need 'poetry install'?"
        return 2
    fi
elif [[ -f Pipfile ]]; then
    echo "direnv: loading Pipenv"
    layout pipenv
fi

# load node env
if [[ -f pnpm-lock.yaml ]]; then
    echo "direnv: loading pnpm"
    PATH_add node_modules/.bin
fi
