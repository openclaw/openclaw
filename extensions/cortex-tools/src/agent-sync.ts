/**
 * Auto-generates one Athena agent per Cortex MCP.
 *
 * For each MCP discovered via Cortex tool schemas:
 *   1. Adds/updates an agent entry in athena.json (agents.list)
 *   2. Creates workspace directory with IDENTITY.md, SOUL.md, TOOLS.md
 *
 * TOOLS.md is always regenerated (auto-generated parameter reference).
 * SOUL.md and IDENTITY.md are only written if missing (preserves customizations).
 */

import fs from "node:fs";
import os from "node:os";
import path from "node:path";
import { resolveAgentProfile } from "./agent-profiles.js";
import type { CortexTool } from "./client.js";

type MinimalLogger = {
  info(msg: string): void;
  warn(msg: string): void;
};

const AGENT_ID_PREFIX = "cortex-";
const AUTO_GEN_MARKER = "<!-- auto-generated by cortex-tools plugin -->";

// ---------------------------------------------------------------------------
// Public entry point
// ---------------------------------------------------------------------------

export function syncCortexAgents(tools: CortexTool[], logger: MinimalLogger): void {
  const mcpMap = groupToolsByMcp(tools);
  const stateDir = resolveStateDir();
  const configPath = path.join(stateDir, "athena.json");

  // Read existing config
  let config: Record<string, unknown>;
  try {
    config = JSON.parse(fs.readFileSync(configPath, "utf-8"));
  } catch {
    logger.warn("Cortex agent sync: could not read athena.json, skipping");
    return;
  }

  // Ensure agents.list exists
  if (!config.agents || typeof config.agents !== "object") {
    (config as Record<string, unknown>).agents = {};
  }
  const agents = config.agents as Record<string, unknown>;
  if (!Array.isArray(agents.list)) {
    agents.list = [];
  }
  const agentList = agents.list as Record<string, unknown>[];

  let synced = 0;

  for (const [mcpName, mcpTools] of mcpMap.entries()) {
    const agentId = AGENT_ID_PREFIX + mcpName.replace(/_/g, "-");
    const profile = resolveAgentProfile(mcpName, mcpTools);

    // Upsert agent in config
    upsertAgent(agentList, agentId, profile.displayName, mcpTools);

    // Write workspace files
    const workspaceDir = path.join(stateDir, `workspace-${agentId}`);
    fs.mkdirSync(workspaceDir, { recursive: true });

    writeIfMissing(
      path.join(workspaceDir, "IDENTITY.md"),
      `- Name: ${profile.displayName}\n- Emoji: ${profile.emoji}\n`,
    );

    writeIfMissing(path.join(workspaceDir, "SOUL.md"), profile.soul + "\n");

    // TOOLS.md is always regenerated
    const toolsMd = generateToolsMd(mcpName, mcpTools);
    fs.writeFileSync(path.join(workspaceDir, "TOOLS.md"), toolsMd, "utf-8");

    synced++;
  }

  // Write config back
  fs.writeFileSync(configPath, JSON.stringify(config, null, 2) + "\n", "utf-8");
  logger.info(`Cortex agent sync: ${synced} MCP agents synced`);
}

// ---------------------------------------------------------------------------
// Internals
// ---------------------------------------------------------------------------

function resolveStateDir(): string {
  const override = process.env.ATHENA_STATE_DIR?.trim() || process.env.OPENCLAW_STATE_DIR?.trim();
  if (override) return path.resolve(override);
  return path.join(os.homedir(), ".athena");
}

function groupToolsByMcp(tools: CortexTool[]): Map<string, CortexTool[]> {
  const map = new Map<string, CortexTool[]>();
  for (const tool of tools) {
    const sep = tool.name.indexOf("__");
    if (sep === -1) continue;
    const mcpName = tool.name.slice(0, sep);
    let list = map.get(mcpName);
    if (!list) {
      list = [];
      map.set(mcpName, list);
    }
    list.push(tool);
  }
  return map;
}

function upsertAgent(
  agentList: Record<string, unknown>[],
  agentId: string,
  displayName: string,
  mcpTools: CortexTool[],
): void {
  const toolNames = mcpTools.map((t) => `cortex_${t.name}`);

  const existing = agentList.find((a) => a.id === agentId);
  if (existing) {
    // Always update the tool allow list so new/removed tools are reflected
    if (!existing.tools || typeof existing.tools !== "object") {
      existing.tools = {};
    }
    const toolsCfg = existing.tools as Record<string, unknown>;
    toolsCfg.profile = "full";
    toolsCfg.allow = toolNames;
  } else {
    agentList.push({
      id: agentId,
      name: displayName,
      tools: {
        profile: "full",
        allow: toolNames,
      },
    });
  }
}

function writeIfMissing(filePath: string, content: string): void {
  if (fs.existsSync(filePath)) return;
  fs.writeFileSync(filePath, content, "utf-8");
}

// ---------------------------------------------------------------------------
// TOOLS.md generation
// ---------------------------------------------------------------------------

function generateToolsMd(mcpName: string, tools: CortexTool[]): string {
  const lines: string[] = [];
  lines.push(AUTO_GEN_MARKER);
  lines.push(`# ${mcpName} Tools Reference`);
  lines.push("");
  lines.push(
    `> ${tools.length} tool${tools.length === 1 ? "" : "s"} available via Cortex MCP \`${mcpName}\`.`,
  );
  lines.push("");

  for (const tool of tools) {
    const shortName = tool.name.slice(tool.name.indexOf("__") + 2);
    const athenaName = `cortex_${tool.name}`;

    lines.push(`## \`${shortName}\``);
    lines.push("");
    lines.push(`**Athena tool name:** \`${athenaName}\``);
    lines.push("");
    lines.push(tool.description || "_No description._");
    lines.push("");

    // Parameter table
    const schema = tool.inputSchema;
    const properties = (schema?.properties ?? {}) as Record<string, Record<string, unknown>>;
    const required = new Set(Array.isArray(schema?.required) ? (schema.required as string[]) : []);

    const propNames = Object.keys(properties);
    if (propNames.length > 0) {
      lines.push("### Parameters");
      lines.push("");
      lines.push("| Parameter | Type | Required | Description |");
      lines.push("|-----------|------|----------|-------------|");

      for (const propName of propNames) {
        const prop = properties[propName];
        const type = formatType(prop);
        const req = required.has(propName) ? "Yes" : "No";
        const desc = formatDescription(prop);
        lines.push(`| \`${propName}\` | ${type} | ${req} | ${desc} |`);
      }

      lines.push("");

      // Enum details for any enum properties
      for (const propName of propNames) {
        const prop = properties[propName];
        if (Array.isArray(prop.enum) && prop.enum.length > 0) {
          const vals = prop.enum.map((v: unknown) => `\`${String(v)}\``).join(", ");
          lines.push(`**\`${propName}\` values:** ${vals}`);
          lines.push("");
        }
      }
    } else {
      lines.push("_No parameters._");
      lines.push("");
    }

    lines.push("---");
    lines.push("");
  }

  return lines.join("\n");
}

function formatType(prop: Record<string, unknown>): string {
  if (prop.enum) return "enum";
  if (typeof prop.type === "string") return prop.type;
  if (Array.isArray(prop.type)) return prop.type.join(" \\| ");
  if (prop.oneOf || prop.anyOf) return "union";
  return "any";
}

function formatDescription(prop: Record<string, unknown>): string {
  let desc = typeof prop.description === "string" ? prop.description : "";
  // Escape pipe characters for markdown table
  desc = desc.replace(/\|/g, "\\|").replace(/\n/g, " ");
  if (prop.default !== undefined) {
    desc += ` (default: \`${JSON.stringify(prop.default)}\`)`;
  }
  return desc || "-";
}
