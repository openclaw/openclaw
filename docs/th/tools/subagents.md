---
summary: "ซับเอเจนต์: การสปอว์นการรันเอเจนต์ที่แยกจากกันและประกาศผลกลับไปยังแชทของผู้ร้องขอ"
read_when:
  - คุณต้องการงานเบื้องหลัง/ขนานผ่านเอเจนต์
  - คุณกำลังเปลี่ยน sessions_spawn หรือนโยบายเครื่องมือของซับเอเจนต์
title: "ซับเอเจนต์"
---

# ซับเอเจนต์

Sub-agents are background agent runs spawned from an existing agent run. ซับเอเจนต์คือการรันเอเจนต์เบื้องหลังที่ถูกสปอว์นจากการรันเอเจนต์ที่มีอยู่ พวกมันทำงานในเซสชันของตนเอง (`agent:<agentId>:subagent:<uuid>`) และเมื่อเสร็จสิ้นจะ **ประกาศ** ผลลัพธ์กลับไปยังช่องทางแชทของผู้ร้องขอ

## คำสั่งสแลช

ใช้ `/subagents` เพื่อตรวจสอบหรือควบคุมการรันซับเอเจนต์สำหรับ **เซสชันปัจจุบัน**:

- `/subagents list`
- `/subagents stop <id|#|all>`
- `/subagents log <id|#> [limit] [tools]`
- `/subagents info <id|#>`
- `/subagents send <id|#> <message>`

`/subagents info` แสดงเมทาดาทาของการรัน (สถานะ เวลาประทับ เซสชันไอดี เส้นทางทรานสคริปต์ การทำความสะอาด)

เป้าหมายหลัก:

- ทำงาน “การวิจัย/งานยาว/เครื่องมือช้า” แบบขนานโดยไม่บล็อกการรันหลัก
- ทำให้ซับเอเจนต์แยกจากกันเป็นค่าเริ่มต้น (การแยกเซสชัน + sandboxing แบบไม่บังคับ)
- ทำให้พื้นผิวเครื่องมือใช้งานผิดพลาดได้ยาก: ซับเอเจนต์ **จะไม่** ได้รับเครื่องมือของเซสชันโดยค่าเริ่มต้น
- หลีกเลี่ยงการกระจายแบบซ้อน: ซับเอเจนต์ไม่สามารถสปอว์นซับเอเจนต์ได้

Cost note: each sub-agent has its **own** context and token usage. หมายเหตุด้านต้นทุน: ซับเอเจนต์แต่ละตัวมีบริบทและการใช้โทเคนเป็นของ **ตนเอง** สำหรับงานที่หนักหรือทำซ้ำ ให้ตั้งค่าโมเดลที่ถูกกว่าสำหรับซับเอเจนต์ และคงเอเจนต์หลักไว้ที่โมเดลคุณภาพสูงกว่า คุณสามารถกำหนดค่านี้ได้ผ่าน `agents.defaults.subagents.model` หรือการโอเวอร์ไรด์ต่อเอเจนต์
You can configure this via `agents.defaults.subagents.model` or per-agent overrides.

## เครื่องมือ

ใช้ `sessions_spawn`:

- เริ่มการรันซับเอเจนต์ (`deliver: false`, เลนส่วนกลาง: `subagent`)
- จากนั้นรันขั้นตอนประกาศและโพสต์คำตอบประกาศไปยังช่องทางแชทของผู้ร้องขอ
- โมเดลเริ่มต้น: สืบทอดจากผู้เรียก เว้นแต่คุณตั้งค่า `agents.defaults.subagents.model` (หรือ `agents.list[].subagents.model` ต่อเอเจนต์); ค่า `sessions_spawn.model` ที่ระบุชัดเจนจะมีผลเหนือกว่าเสมอ
- ระดับการคิดเริ่มต้น: สืบทอดจากผู้เรียก เว้นแต่คุณตั้งค่า `agents.defaults.subagents.thinking` (หรือ `agents.list[].subagents.thinking` ต่อเอเจนต์); ค่า `sessions_spawn.thinking` ที่ระบุชัดเจนจะมีผลเหนือกว่าเสมอ

พารามิเตอร์ของเครื่องมือ:

- `task` (บังคับ)
- `label?` (ไม่บังคับ)
- `agentId?` (ไม่บังคับ; สปอว์นภายใต้เอเจนต์ไอดีอื่นหากได้รับอนุญาต)
- `model?` (ไม่บังคับ; โอเวอร์ไรด์โมเดลของซับเอเจนต์; ค่าที่ไม่ถูกต้องจะถูกข้ามและซับเอเจนต์จะรันด้วยโมเดลเริ่มต้นพร้อมคำเตือนในผลลัพธ์ของเครื่องมือ)
- `thinking?` (ไม่บังคับ; โอเวอร์ไรด์ระดับการคิดสำหรับการรันซับเอเจนต์)
- `runTimeoutSeconds?` (ค่าเริ่มต้น `0`; เมื่อกำหนด การรันซับเอเจนต์จะถูกยกเลิกหลังจาก N วินาที)
- `cleanup?` (`delete|keep`, ค่าเริ่มต้น `keep`)

รายการอนุญาต:

- `agents.list[].subagents.allowAgents`: รายการเอเจนต์ไอดีที่สามารถกำหนดเป้าหมายผ่าน `agentId` (`["*"]` เพื่ออนุญาตทั้งหมด) ค่าเริ่มต้น: เฉพาะเอเจนต์ผู้ร้องขอ Default: only the requester agent.

Discovery:

- ใช้ `agents_list` เพื่อดูว่าเอเจนต์ไอดีใดบ้างที่ได้รับอนุญาตสำหรับ `sessions_spawn` ในปัจจุบัน

การเก็บถาวรอัตโนมัติ:

- เซสชันซับเอเจนต์จะถูกเก็บถาวรโดยอัตโนมัติหลัง `agents.defaults.subagents.archiveAfterMinutes` (ค่าเริ่มต้น: 60)
- การเก็บถาวรใช้ `sessions.delete` และเปลี่ยนชื่อทรานสคริปต์เป็น `*.deleted.<timestamp>` (โฟลเดอร์เดียวกัน)
- `cleanup: "delete"` จะเก็บถาวรทันทีหลังการประกาศ (ยังคงเก็บทรานสคริปต์ผ่านการเปลี่ยนชื่อ)
- การเก็บถาวรอัตโนมัติเป็นแบบพยายามให้ดีที่สุด; ตัวจับเวลาที่ค้างอยู่จะหายไปหาก Gateway รีสตาร์ต
- `runTimeoutSeconds` จะ **ไม่** เก็บถาวรอัตโนมัติ; มันเพียงหยุดการรัน เซสชันจะคงอยู่จนกว่าจะถูกเก็บถาวรอัตโนมัติ The session remains until auto-archive.

## การยืนยันตัวตน

การยืนยันตัวตนของซับเอเจนต์ถูกกำหนดโดย **เอเจนต์ไอดี** ไม่ใช่โดยประเภทเซสชัน:

- คีย์เซสชันของซับเอเจนต์คือ `agent:<agentId>:subagent:<uuid>`.
- ที่เก็บการยืนยันตัวตนถูกโหลดจาก `agentDir` ของเอเจนต์นั้น
- โปรไฟล์การยืนยันตัวตนของเอเจนต์หลักจะถูกรวมเข้าเป็น **ทางเลือกสำรอง**; โปรไฟล์ของเอเจนต์จะมีผลเหนือกว่าโปรไฟล์หลักเมื่อเกิดความขัดแย้ง

หมายเหตุ: การรวมเป็นแบบเพิ่มเข้า ดังนั้นโปรไฟล์หลักจึงพร้อมใช้งานเป็นทางเลือกสำรองเสมอ การแยกการยืนยันตัวตนอย่างสมบูรณ์ต่อเอเจนต์ยังไม่รองรับในขณะนี้ Fully isolated auth per agent is not supported yet.

## การประกาศ

ซับเอเจนต์รายงานกลับผ่านขั้นตอนประกาศ:

- ขั้นตอนประกาศทำงานภายในเซสชันซับเอเจนต์ (ไม่ใช่เซสชันของผู้ร้องขอ)
- หากซับเอเจนต์ตอบกลับตรงตาม `ANNOUNCE_SKIP` จะไม่มีการโพสต์ใดๆ
- มิฉะนั้น คำตอบประกาศจะถูกโพสต์ไปยังช่องทางแชทของผู้ร้องขอผ่านการเรียก `agent` ติดตามผล (`deliver=true`)
- คำตอบประกาศจะคงการกำหนดเส้นทางเธรด/หัวข้อเมื่อมีให้ (เธรด Slack หัวข้อ Telegram เธรด Matrix)
- ข้อความประกาศจะถูกทำให้เป็นมาตรฐานตามเทมเพลตที่คงที่:
  - `Status:` ที่ได้มาจากผลลัพธ์ของการรัน (`success`, `error`, `timeout`, หรือ `unknown`)
  - `Result:` เนื้อหาสรุปจากขั้นตอนประกาศ (หรือ `(not available)` หากไม่มี)
  - `Notes:` รายละเอียดข้อผิดพลาดและบริบทที่เป็นประโยชน์อื่นๆ
- `Status` ไม่ได้อนุมานจากเอาต์พุตของโมเดล; มาจากสัญญาณผลลัพธ์ของรันไทม์

เพย์โหลดการประกาศจะมีบรรทัดสถิติท้ายข้อความ (แม้เมื่อถูกห่อ):

- เวลารัน (เช่น `runtime 5m12s`)
- การใช้โทเคน (อินพุต/เอาต์พุต/รวม)
- ต้นทุนโดยประมาณเมื่อมีการกำหนดราคาของโมเดล (`models.providers.*.models[].cost`)
- `sessionKey`, `sessionId`, และเส้นทางทรานสคริปต์ (เพื่อให้เอเจนต์หลักดึงประวัติผ่าน `sessions_history` หรือเปิดดูไฟล์บนดิสก์ได้)

## นโยบายเครื่องมือ (เครื่องมือของซับเอเจนต์)

โดยค่าเริ่มต้น ซับเอเจนต์จะได้รับ **เครื่องมือทั้งหมด ยกเว้นเครื่องมือของเซสชัน**:

- `sessions_list`
- `sessions_history`
- `sessions_send`
- `sessions_spawn`

Override via config:

```json5
{
  agents: {
    defaults: {
      subagents: {
        maxConcurrent: 1,
      },
    },
  },
  tools: {
    subagents: {
      tools: {
        // deny wins
        deny: ["gateway", "cron"],
        // if allow is set, it becomes allow-only (deny still wins)
        // allow: ["read", "exec", "process"]
      },
    },
  },
}
```

## การทำงานพร้อมกัน

ซับเอเจนต์ใช้เลนคิวภายในโปรเซสที่แยกเฉพาะ:

- ชื่อเลน: `subagent`
- การทำงานพร้อมกัน: `agents.defaults.subagents.maxConcurrent` (ค่าเริ่มต้น `8`)

## การหยุด

- การส่ง `/stop` ในแชทของผู้ร้องขอจะยกเลิกเซสชันของผู้ร้องขอและหยุดการรันซับเอเจนต์ที่ยังทำงานอยู่ทั้งหมดที่ถูกสปอว์นจากมัน

## ข้อจำกัด

- Sub-agent announce is **best-effort**. การประกาศของซับเอเจนต์เป็นแบบ **พยายามให้ดีที่สุด** หาก Gateway รีสตาร์ต งาน “ประกาศกลับ” ที่ค้างอยู่จะสูญหาย
- ซับเอเจนต์ยังคงใช้ทรัพยากรของโปรเซส Gateway เดียวกัน ให้ถือว่า `maxConcurrent` เป็นวาล์วนิรภัย
- `sessions_spawn` เป็นแบบไม่บล็อกเสมอ: มันจะส่งคืน `{ status: "accepted", runId, childSessionKey }` ทันที
- บริบทของซับเอเจนต์จะฉีดเฉพาะ `AGENTS.md` + `TOOLS.md` (ไม่มี `SOUL.md`, `IDENTITY.md`, `USER.md`, `HEARTBEAT.md`, หรือ `BOOTSTRAP.md`)
