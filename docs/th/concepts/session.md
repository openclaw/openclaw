---
summary: "กฎการจัดการเซสชัน คีย์ และการคงอยู่ของข้อมูลสำหรับแชต"
read_when:
  - การแก้ไขการจัดการหรือการจัดเก็บเซสชัน
title: "การจัดการเซสชัน"
x-i18n:
  source_path: concepts/session.md
  source_hash: e2040cea1e0738a8
  provider: openai
  model: gpt-5.2-chat-latest
  workflow: v1
  generated_at: 2026-02-08T10:52:35Z
---

# การจัดการเซสชัน

OpenClaw ถือว่า **หนึ่งเซสชันแชตตรงต่อหนึ่งเอเจนต์** เป็นหลัก แชตตรงจะถูกรวมเป็น `agent:<agentId>:<mainKey>` (ค่าเริ่มต้น `main`) ในขณะที่แชตกลุ่ม/ช่องทางจะมีคีย์ของตัวเอง และจะเคารพ `session.mainKey`.

ใช้ `session.dmScope` เพื่อควบคุมการจัดกลุ่ม **ข้อความตรง(DMs)**:

- `main` (ค่าเริ่มต้น): DMs ทั้งหมดใช้เซสชันหลักร่วมกันเพื่อความต่อเนื่อง
- `per-peer`: แยกตาม sender id ข้ามช่องทาง
- `per-channel-peer`: แยกตาม channel + sender (แนะนำสำหรับอินบ็อกซ์หลายผู้ใช้)
- `per-account-channel-peer`: แยกตาม account + channel + sender (แนะนำสำหรับอินบ็อกซ์หลายบัญชี)
  ใช้ `session.identityLinks` เพื่อแมป peer id ที่มีคำนำหน้าผู้ให้บริการให้เป็นตัวตนมาตรฐาน เพื่อให้บุคคลเดียวกันใช้เซสชัน DM ร่วมกันข้ามช่องทางเมื่อใช้ `per-peer`, `per-channel-peer`, หรือ `per-account-channel-peer`.

## โหมด DM ปลอดภัย (แนะนำสำหรับการตั้งค่าหลายผู้ใช้)

> **คำเตือนด้านความปลอดภัย:** หากเอเจนต์ของคุณสามารถรับ DM จาก **หลายคน** ได้ ขอแนะนำอย่างยิ่งให้เปิดโหมด DM ปลอดภัย หากไม่เปิด ผู้ใช้ทุกคนจะใช้บริบทการสนทนาเดียวกัน ซึ่งอาจทำให้ข้อมูลส่วนตัวรั่วไหลระหว่างผู้ใช้ได้

**ตัวอย่างปัญหาด้วยการตั้งค่าเริ่มต้น:**

- Alice (`<SENDER_A>`) ส่งข้อความถึงเอเจนต์ของคุณเกี่ยวกับเรื่องส่วนตัว (เช่น การนัดหมายแพทย์)
- Bob (`<SENDER_B>`) ส่งข้อความถึงเอเจนต์ถามว่า “เราคุยอะไรกันอยู่?”
- เนื่องจาก DM ทั้งสองใช้เซสชันเดียวกัน โมเดลอาจตอบ Bob โดยอ้างอิงบริบทก่อนหน้าของ Alice

**วิธีแก้ไข:** ตั้งค่า `dmScope` เพื่อแยกเซสชันต่อผู้ใช้:

```json5
// ~/.openclaw/openclaw.json
{
  session: {
    // Secure DM mode: isolate DM context per channel + sender.
    dmScope: "per-channel-peer",
  },
}
```

**ควรเปิดเมื่อใด:**

- คุณมีการอนุมัติการจับคู่สำหรับผู้ส่งมากกว่าหนึ่งราย
- คุณใช้ DM allowlist ที่มีหลายรายการ
- คุณตั้งค่า `dmPolicy: "open"`
- มีหลายหมายเลขโทรศัพท์หรือหลายบัญชีที่สามารถส่งข้อความถึงเอเจนต์ของคุณได้

หมายเหตุ:

- ค่าเริ่มต้นคือ `dmScope: "main"` เพื่อความต่อเนื่อง (DM ทั้งหมดใช้เซสชันหลักร่วมกัน) เหมาะสำหรับการตั้งค่าผู้ใช้คนเดียว
- สำหรับอินบ็อกซ์หลายบัญชีในช่องทางเดียวกัน ควรใช้ `per-account-channel-peer`
- หากบุคคลเดียวกันติดต่อคุณผ่านหลายช่องทาง ให้ใช้ `session.identityLinks` เพื่อรวมเซสชัน DM ของเขาเป็นตัวตนมาตรฐานเดียว
- คุณสามารถตรวจสอบการตั้งค่า DM ได้ด้วย `openclaw security audit` (ดู [security](/cli/security))

## Gateway คือแหล่งความจริงเพียงหนึ่งเดียว

สถานะเซสชันทั้งหมด **เป็นของ Gateway** (OpenClaw “ตัวหลัก”) ไคลเอนต์ UI (แอปmacOS, WebChat ฯลฯ) ต้องสอบถาม Gateway เพื่อขอรายการเซสชันและจำนวนโทเคน แทนการอ่านไฟล์ในเครื่อง

- ใน **โหมดรีโมต** ที่เก็บเซสชันที่สำคัญจะอยู่บนโฮสต์Gateway ระยะไกล ไม่ใช่บน Mac ของคุณ
- จำนวนโทเคนที่แสดงใน UI มาจากฟิลด์ในสโตร์ของ Gateway (`inputTokens`, `outputTokens`, `totalTokens`, `contextTokens`) ไคลเอนต์จะไม่พาร์สทรานสคริปต์ JSONL เพื่อ “แก้ไข” ยอดรวม

## ตำแหน่งที่สถานะถูกเก็บ

- บน **โฮสต์Gateway**:
  - ไฟล์สโตร์: `~/.openclaw/agents/<agentId>/sessions/sessions.json` (ต่อเอเจนต์)
- ทรานสคริปต์: `~/.openclaw/agents/<agentId>/sessions/<SessionId>.jsonl` (เซสชันหัวข้อ Telegram ใช้ `.../<SessionId>-topic-<threadId>.jsonl`)
- สโตร์เป็นแมป `sessionKey -> { sessionId, updatedAt, ... }` การลบเอนทรีปลอดภัย ระบบจะสร้างใหม่เมื่อจำเป็น
- เอนทรีของกลุ่มอาจมี `displayName`, `channel`, `subject`, `room`, และ `space` เพื่อใช้ติดป้ายเซสชันใน UI
- เอนทรีของเซสชันมีเมทาดาทา `origin` (ป้ายกำกับ + คำใบ้การกำหนดเส้นทาง) เพื่อให้ UI อธิบายที่มาของเซสชันได้
- OpenClaw **ไม่** อ่านโฟลเดอร์เซสชัน Pi/Tau แบบเดิม

## การตัดแต่งเซสชัน

OpenClaw จะตัด **ผลลัพธ์เครื่องมือเก่า** ออกจากบริบทในหน่วยความจำก่อนเรียก LLM ตามค่าเริ่มต้น
การทำเช่นนี้ **ไม่** เขียนทับประวัติ JSONL ดู [/concepts/session-pruning](/concepts/session-pruning)

## การล้างหน่วยความจำก่อนการคอมแพ็กต์

เมื่อเซสชันใกล้ถึงการคอมแพ็กต์อัตโนมัติ OpenClaw สามารถรัน **การล้างหน่วยความจำแบบเงียบ**
เพื่อเตือนโมเดลให้เขียนบันทึกถาวรลงดิสก์ การทำงานนี้จะเกิดขึ้นเฉพาะเมื่อเวิร์กสเปซสามารถเขียนได้ ดู [Memory](/concepts/memory) และ
[Compaction](/concepts/compaction)

## การแมปทรานสปอร์ต → คีย์เซสชัน

- แชตตรงปฏิบัติตาม `session.dmScope` (ค่าเริ่มต้น `main`)
  - `main`: `agent:<agentId>:<mainKey>` (ความต่อเนื่องข้ามอุปกรณ์/ช่องทาง)
    - หมายเลขโทรศัพท์และหลายช่องทางสามารถแมปไปยังคีย์หลักของเอเจนต์เดียวกันได้ โดยทำหน้าที่เป็นทรานสปอร์ตเข้าสู่การสนทนาเดียว
  - `per-peer`: `agent:<agentId>:dm:<peerId>`
  - `per-channel-peer`: `agent:<agentId>:<channel>:dm:<peerId>`
  - `per-account-channel-peer`: `agent:<agentId>:<channel>:<accountId>:dm:<peerId>` (accountId ค่าเริ่มต้นคือ `default`)
  - หาก `session.identityLinks` ตรงกับ peer id ที่มีคำนำหน้าผู้ให้บริการ (เช่น `telegram:123`) คีย์มาตรฐานจะมาแทนที่ `<peerId>` เพื่อให้บุคคลเดียวกันใช้เซสชันร่วมกันข้ามช่องทาง
- แชตกลุ่มจะแยกสถานะ: `agent:<agentId>:<channel>:group:<id>` (ห้อง/ช่องทางใช้ `agent:<agentId>:<channel>:channel:<id>`)
  - หัวข้อฟอรัม Telegram จะต่อท้าย `:topic:<threadId>` เข้ากับ group id เพื่อแยกสถานะ
  - คีย์ `group:<id>` แบบเดิมยังคงถูกรับรู้เพื่อการย้ายข้อมูล
- บริบทขาเข้าอาจยังใช้ `group:<id>` โดยอนุมานช่องทางจาก `Provider` และปรับให้เป็นรูปแบบมาตรฐาน `agent:<agentId>:<channel>:group:<id>`
- แหล่งอื่นๆ:
  - งาน Cron: `cron:<job.id>`
  - Webhook: `hook:<uuid>` (เว้นแต่จะตั้งค่าโดยฮุกอย่างชัดเจน)
  - การรันโหนด: `node-<nodeId>`

## วงจรชีวิต

- นโยบายรีเซ็ต: เซสชันจะถูกใช้ซ้ำจนกว่าจะหมดอายุ และการหมดอายุจะถูกประเมินเมื่อมีข้อความขาเข้าถัดไป
- รีเซ็ตรายวัน: ค่าเริ่มต้นคือ **04:00 น. ตามเวลาท้องถิ่นบนโฮสต์Gateway** เซสชันจะถือว่าเก่าหากการอัปเดตล่าสุดก่อนเวลารีเซ็ตรายวันล่าสุด
- รีเซ็ตเมื่อว่าง (ไม่บังคับ): `idleMinutes` เพิ่มหน้าต่างเวลาว่างแบบเลื่อน เมื่อกำหนดทั้งรีเซ็ตรายวันและรีเซ็ตเมื่อว่าง **อย่างใดอย่างหนึ่งที่หมดก่อน** จะบังคับเริ่มเซสชันใหม่
- โหมดเดิมแบบว่างอย่างเดียว: หากคุณตั้งค่า `session.idleMinutes` โดยไม่มีคอนฟิก `session.reset`/`resetByType` ใดๆ OpenClaw จะคงอยู่ในโหมดว่างอย่างเดียวเพื่อความเข้ากันได้ย้อนหลัง
- การแทนที่ตามประเภท (ไม่บังคับ): `resetByType` ให้คุณแทนที่นโยบายสำหรับเซสชัน `dm`, `group`, และ `thread` (thread = เธรด Slack/Discord, หัวข้อ Telegram, เธรด Matrix เมื่อคอนเน็กเตอร์รองรับ)
- การแทนที่ตามช่องทาง (ไม่บังคับ): `resetByChannel` แทนที่นโยบายรีเซ็ตสำหรับช่องทางหนึ่งๆ (มีผลกับทุกประเภทเซสชันของช่องทางนั้น และมีลำดับความสำคัญเหนือ `reset`/`resetByType`)
- ทริกเกอร์การรีเซ็ต: ข้อความ `/new` หรือ `/reset` แบบตรงตัว (รวมส่วนเพิ่มเติมใน `resetTriggers`) จะเริ่ม session id ใหม่และส่งต่อข้อความที่เหลือ `/new <model>` ยอมรับนามแฝงโมเดล, `provider/model`, หรือชื่อผู้ให้บริการ (จับคู่แบบคลุมเครือ) เพื่อกำหนดโมเดลของเซสชันใหม่ หากส่ง `/new` หรือ `/reset` เพียงอย่างเดียว OpenClaw จะรันรอบทักทายสั้นๆ เพื่อยืนยันการรีเซ็ต
- รีเซ็ตด้วยตนเอง: ลบคีย์เฉพาะจากสโตร์หรือลบทรานสคริปต์ JSONL ข้อความถัดไปจะสร้างใหม่
- งาน Cron แบบแยกจะสร้าง `sessionId` ใหม่เสมอในแต่ละรอบ (ไม่มีการใช้ซ้ำเมื่อว่าง)

## นโยบายการส่ง (ไม่บังคับ)

บล็อกการส่งสำหรับประเภทเซสชันเฉพาะโดยไม่ต้องระบุ id รายตัว

```json5
{
  session: {
    sendPolicy: {
      rules: [
        { action: "deny", match: { channel: "discord", chatType: "group" } },
        { action: "deny", match: { keyPrefix: "cron:" } },
      ],
      default: "allow",
    },
  },
}
```

การแทนที่ขณะรัน (เฉพาะเจ้าของ):

- `/send on` → อนุญาตสำหรับเซสชันนี้
- `/send off` → ปฏิเสธสำหรับเซสชันนี้
- `/send inherit` → ล้างการแทนที่และใช้กฎคอนฟิก
  ส่งเป็นข้อความเดี่ยวเพื่อให้ระบบลงทะเบียน

## การกำหนดค่า (ตัวอย่างการเปลี่ยนชื่อ ไม่บังคับ)

```json5
// ~/.openclaw/openclaw.json
{
  session: {
    scope: "per-sender", // keep group keys separate
    dmScope: "main", // DM continuity (set per-channel-peer/per-account-channel-peer for shared inboxes)
    identityLinks: {
      alice: ["telegram:123456789", "discord:987654321012345678"],
    },
    reset: {
      // Defaults: mode=daily, atHour=4 (gateway host local time).
      // If you also set idleMinutes, whichever expires first wins.
      mode: "daily",
      atHour: 4,
      idleMinutes: 120,
    },
    resetByType: {
      thread: { mode: "daily", atHour: 4 },
      dm: { mode: "idle", idleMinutes: 240 },
      group: { mode: "idle", idleMinutes: 120 },
    },
    resetByChannel: {
      discord: { mode: "idle", idleMinutes: 10080 },
    },
    resetTriggers: ["/new", "/reset"],
    store: "~/.openclaw/agents/{agentId}/sessions/sessions.json",
    mainKey: "main",
  },
}
```

## การตรวจสอบ

- `openclaw status` — แสดงพาธสโตร์และเซสชันล่าสุด
- `openclaw sessions --json` — ดัมพ์ทุกเอนทรี (กรองด้วย `--active <minutes>`)
- `openclaw gateway call sessions.list --params '{}'` — ดึงเซสชันจาก Gateway ที่กำลังรันอยู่ (ใช้ `--url`/`--token` สำหรับการเข้าถึง Gateway ระยะไกล)
- ส่ง `/status` เป็นข้อความเดี่ยวในแชตเพื่อดูว่าเอเจนต์เข้าถึงได้หรือไม่ ใช้บริบทเซสชันไปเท่าใด การสลับโหมดคิด/ละเอียดปัจจุบัน และเวลาที่รีเฟรชข้อมูลรับรอง WhatsApp web ล่าสุด (ช่วยตรวจพบความจำเป็นต้องเชื่อมใหม่)
- ส่ง `/context list` หรือ `/context detail` เพื่อดูสิ่งที่อยู่ใน system prompt และไฟล์เวิร์กสเปซที่ถูกฉีดเข้าไป (รวมถึงตัวที่ใช้บริบทมากที่สุด)
- ส่ง `/stop` เป็นข้อความเดี่ยวเพื่อยกเลิกรันปัจจุบัน ล้างฟอลโลว์อัปที่ค้างคิวสำหรับเซสชันนั้น และหยุดการรันซับเอเจนต์ใดๆ ที่ถูกสร้างจากมัน (คำตอบจะรวมจำนวนที่หยุด)
- ส่ง `/compact` (คำสั่งเสริมไม่บังคับ) เป็นข้อความเดี่ยวเพื่อสรุปบริบทเก่าและคืนพื้นที่หน้าต่าง ดู [/concepts/compaction](/concepts/compaction)
- สามารถเปิดทรานสคริปต์ JSONL โดยตรงเพื่อทบทวนเทิร์นทั้งหมด

## เคล็ดลับ

- รักษาคีย์หลักให้ใช้กับทราฟฟิกแบบ 1:1 ปล่อยให้กลุ่มใช้คีย์ของตนเอง
- เมื่อทำการล้างอัตโนมัติ ให้ลบคีย์รายตัวแทนการลบทั้งสโตร์เพื่อคงบริบทส่วนอื่นไว้

## เมทาดาทาต้นกำเนิดเซสชัน

เอนทรีเซสชันแต่ละรายการจะบันทึกที่มา(ตามความพยายามที่ดีที่สุด)ไว้ใน `origin`:

- `label`: ป้ายกำกับสำหรับมนุษย์ (แก้ไขจากป้ายการสนทนา + หัวข้อกลุ่ม/ช่องทาง)
- `provider`: channel id ที่ถูกปรับมาตรฐาน (รวมส่วนขยาย)
- `from`/`to`: routing id ดิบจากซองจดหมายขาเข้า
- `accountId`: account id ของผู้ให้บริการ (เมื่อหลายบัญชี)
- `threadId`: thread/topic id เมื่อช่องทางรองรับ
  ฟิลด์ต้นกำเนิดจะถูกเติมสำหรับข้อความตรง ช่องทาง และกลุ่ม หากคอนเน็กเตอร์อัปเดตเฉพาะการกำหนดเส้นทางการส่งมอบ (เช่น เพื่อทำให้เซสชันหลักของ DM สดใหม่) ก็ควรส่งบริบทขาเข้าเพื่อให้เซสชันคงเมทาดาทาอธิบายที่มาไว้ ส่วนขยายสามารถทำได้โดยส่ง `ConversationLabel`, `GroupSubject`, `GroupChannel`, `GroupSpace`, และ `SenderName` ในบริบทขาเข้า และเรียก `recordSessionMetaFromInbound` (หรือส่งบริบทเดียวกันไปยัง `updateLastRoute`).
