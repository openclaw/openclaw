---
summary: "การป้องกันGatewayแบบซิงเกิลตันด้วยการผูกตัวรับฟังWebSocket"
read_when:
  - ขณะรันหรือดีบักโปรเซสGateway
  - 44. การตรวจสอบการบังคับใช้แบบอินสแตนซ์เดียว
title: "Gateway Lock"
---

# Gateway lock

อัปเดตล่าสุด: 2025-12-11

## ทำไม

- รับประกันว่ามีGateway（เกตเวย์）ทำงานได้เพียงอินสแตนซ์เดียวต่อพอร์ตฐานบนโฮสต์เดียวกัน; Gatewayเพิ่มเติมต้องใช้โปรไฟล์ที่แยกจากกันและพอร์ตที่ไม่ซ้ำกัน
- อยู่รอดจากการแครช/SIGKILLโดยไม่ทิ้งไฟล์ล็อกค้าง
- ล้มเหลวอย่างรวดเร็วพร้อมข้อผิดพลาดที่ชัดเจนเมื่อพอร์ตควบคุมถูกใช้งานอยู่แล้ว

## กลไก

- Gateway（เกตเวย์）จะผูกตัวรับฟังWebSocket(ค่าเริ่มต้น `ws://127.0.0.1:18789`) ทันทีเมื่อเริ่มต้น โดยใช้ตัวรับฟังTCPแบบเอ็กซ์คลูซีฟ
- หากการผูกล้มเหลวด้วย `EADDRINUSE` การเริ่มต้นจะขว้าง `GatewayLockError("another gateway instance is already listening on ws://127.0.0.1:<port>")`
- ระบบปฏิบัติการจะปล่อยตัวรับฟังโดยอัตโนมัติเมื่อโปรเซสสิ้นสุด ไม่ว่าจะเป็นการแครชหรือ SIGKILL—ไม่ต้องมีไฟล์ล็อกแยกหรือขั้นตอนทำความสะอาดเพิ่มเติม
- ตอนปิดการทำงาน Gatewayจะปิดเซิร์ฟเวอร์WebSocketและเซิร์ฟเวอร์HTTPที่อยู่เบื้องหลังเพื่อคืนพอร์ตอย่างรวดเร็ว

## พื้นผิวข้อผิดพลาด

- หากมีโปรเซสอื่นถือครองพอร์ต การเริ่มต้นจะขว้าง `GatewayLockError("another gateway instance is already listening on ws://127.0.0.1:<port>")`
- ความล้มเหลวในการผูกอื่นๆจะแสดงเป็น `GatewayLockError("failed to bind gateway socket on ws://127.0.0.1:<port>: …")`

## หมายเหตุการปฏิบัติงาน

- หากพอร์ตถูกใช้งานโดยโปรเซส _อื่น_ ข้อผิดพลาดจะเหมือนกัน; ให้คืนพอร์ตหรือเลือกพอร์ตอื่นด้วย `openclaw gateway --port <port>`
- แอปmacOSยังคงรักษาตัวป้องกันPIDแบบเบาก่อนจะสปอว์นGateway; การล็อกรันไทม์ถูกบังคับใช้โดยการผูกWebSocket
