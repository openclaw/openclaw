---
summary: "รีแฟกเตอร์Clawnet: รวมโปรโตคอลเครือข่าย บทบาท การยืนยันตัวตน การอนุมัติ และอัตลักษณ์"
read_when:
  - วางแผนโปรโตคอลเครือข่ายแบบรวมศูนย์สำหรับโหนดและไคลเอนต์ผู้ปฏิบัติการ
  - ปรับโครงสร้างการอนุมัติ การจับคู่ TLS และสถานะการเชื่อมต่อข้ามอุปกรณ์
title: "Clawnet Refactor"
---

# Clawnet รีแฟกเตอร์ (การรวมโปรโตคอล + การยืนยันตัวตน)

## สวัสดี

สวัสดี Peter — ทิศทางนี้ดีมาก ช่วยปลดล็อก UX ที่เรียบง่ายขึ้นและความปลอดภัยที่แข็งแรงขึ้น

## วัตถุประสงค์

เอกสารฉบับเดียวที่เคร่งครัดสำหรับ:

- สถานะปัจจุบัน: โปรโตคอล โฟลว์ และขอบเขตความเชื่อถือ
- จุดเจ็บปวด: การอนุมัติ การเราท์หลายฮอป ความซ้ำซ้อนของ UI
- สถานะใหม่ที่เสนอ: โปรโตคอลเดียว บทบาทที่มีขอบเขต การยืนยันตัวตน/การจับคู่แบบรวมศูนย์ การปักหมุดTLS
- โมเดลอัตลักษณ์: ID ที่เสถียร + slug น่ารัก
- แผนย้าย ความเสี่ยง และคำถามที่เปิดอยู่

## เป้าหมาย (จากการสนทนา)

- โปรโตคอลเดียวสำหรับไคลเอนต์ทั้งหมด (แอปmac, CLI, iOS, Android, โหนดแบบ headless)
- ผู้เข้าร่วมเครือข่ายทุกคนต้องผ่านการยืนยันตัวตนและการจับคู่
- ความชัดเจนของบทบาท: โหนด vs ผู้ปฏิบัติการ
- การอนุมัติแบบศูนย์กลาง ส่งไปยังที่ที่ผู้ใช้อยู่
- การเข้ารหัสTLS + การปักหมุดแบบไม่บังคับสำหรับทราฟฟิกระยะไกลทั้งหมด
- ลดความซ้ำซ้อนของโค้ดให้เหลือน้อยที่สุด
- เครื่องเดียวควรปรากฏเพียงครั้งเดียว (ไม่มีรายการซ้ำ UI/โหนด)

## สิ่งที่ไม่อยู่ในขอบเขต (ระบุชัดเจน)

- ยกเลิกการแยกความสามารถ (ยังต้องใช้หลักสิทธิ์น้อยที่สุด)
- เปิดเผย control plane ของGatewayทั้งหมดโดยไม่มีการตรวจสอบขอบเขต
- ทำให้การยืนยันตัวตนพึ่งพาป้ายกำกับของมนุษย์ (slug ไม่ใช่เรื่องความปลอดภัย)

---

# สถานะปัจจุบัน (as‑is)

## สองโปรโตคอล

### 1. Gateway WebSocket (control plane)

- พื้นผิวAPIครบถ้วน: คอนฟิก ช่องทาง โมเดล เซสชัน การรันเอเจนต์ ล็อก โหนด ฯลฯ
- การ bind เริ่มต้น: loopback การผูกค่าเริ่มต้น: loopback การเข้าถึงระยะไกลผ่าน SSH/Tailscale
- การยืนยันตัวตน: โทเคน/รหัสผ่านผ่าน `connect`
- ไม่มีการปักหมุดTLS (พึ่งพา loopback/อุโมงค์)
- โค้ด:
  - `src/gateway/server/ws-connection/message-handler.ts`
  - `src/gateway/client.ts`
  - `docs/gateway/protocol.md`

### 2. Bridge (ทรานสปอร์ตของโหนด)

- พื้นผิวแบบ allowlist แคบ อัตลักษณ์โหนด + การจับคู่
- JSONL บน TCP; ตัวเลือก TLS + การปักหมุดลายนิ้วมือใบรับรอง
- TLS โฆษณาลายนิ้วมือใน discovery TXT
- โค้ด:
  - `src/infra/bridge/server/connection.ts`
  - `src/gateway/server-bridge.ts`
  - `src/node-host/bridge-client.ts`
  - `docs/gateway/bridge-protocol.md`

## ไคลเอนต์ control plane ในปัจจุบัน

- CLI → Gateway WS ผ่าน `callGateway` (`src/gateway/call.ts`).
- UI แอปmacOS → Gateway WS (`GatewayConnection`).
- Web Control UI → Gateway WS.
- ACP → Gateway WS.
- การควบคุมผ่านเบราว์เซอร์ใช้เซิร์ฟเวอร์ควบคุม HTTP ของตัวเอง

## โหนดในปัจจุบัน

- แอปmacOS ในโหมดโหนดเชื่อมต่อกับ Gateway bridge (`MacNodeBridgeSession`).
- แอป iOS/Android เชื่อมต่อกับ Gateway bridge
- การจับคู่ + โทเคนต่อโหนดถูกเก็บไว้ที่Gateway

## โฟลว์การอนุมัติปัจจุบัน (exec)

- เอเจนต์ใช้ `system.run` ผ่านGateway
- Gateway เรียกโหนดผ่าน bridge
- รันไทม์ของโหนดตัดสินใจการอนุมัติ
- แสดงพรอมป์ต์ UI โดยแอปmac (เมื่อโหนด == แอปmac)
- โหนดส่ง `invoke-res` กลับไปที่Gateway
- หลายฮอป และ UI ผูกกับโฮสต์โหนด

## การมีตัวตน + อัตลักษณ์ในปัจจุบัน

- Gateway มีรายการสถานะจากไคลเอนต์ WS
- โหนดมีรายการสถานะจาก bridge
- แอปmac แสดงสองรายการสำหรับเครื่องเดียวกันได้ (UI + โหนด)
- อัตลักษณ์โหนดเก็บในสโตร์การจับคู่; อัตลักษณ์ UI แยกต่างหาก

---

# ปัญหา / จุดเจ็บปวด

- ต้องดูแลสแตกโปรโตคอลสองชุด (WS + Bridge)
- การอนุมัติบนโหนดระยะไกล: พรอมป์ต์ปรากฏบนโฮสต์โหนด ไม่ใช่ที่ผู้ใช้อยู่
- การปักหมุดTLSมีเฉพาะ bridge; WS พึ่งพา SSH/Tailscale
- อัตลักษณ์ซ้ำ: เครื่องเดียวแสดงเป็นหลายอินสแตนซ์
- บทบาทกำกวม: ความสามารถของ UI + โหนด + CLI ไม่ได้แยกชัด

---

# สถานะใหม่ที่เสนอ (Clawnet)

## โปรโตคอลเดียว สองบทบาท

โปรโตคอล WS เดียวพร้อมบทบาท + ขอบเขต

- **บทบาท: node** (โฮสต์ความสามารถ)
- **บทบาท: operator** (control plane)
- **ขอบเขต** แบบไม่บังคับสำหรับ operator:
  - `operator.read` (สถานะ + การดู)
  - `operator.write` (รันเอเจนต์ การส่ง)
  - `operator.admin` (คอนฟิก ช่องทาง โมเดล)

### พฤติกรรมตามบทบาท

**Node**

- ลงทะเบียนความสามารถได้ (`caps`, `commands`, สิทธิ์)
- รับคำสั่ง `invoke` (`system.run`, `camera.*`, `canvas.*`, `screen.record` ฯลฯ)
- ส่งอีเวนต์ได้: `voice.transcript`, `agent.request`, `chat.subscribe`
- ไม่สามารถเรียก API ของ control plane สำหรับคอนฟิก/โมเดล/ช่องทาง/เซสชัน/เอเจนต์

**Operator**

- เข้าถึง API ของ control plane ทั้งหมด โดยถูกจำกัดด้วยขอบเขต
- รับการอนุมัติทั้งหมด
- ไม่รันการกระทำของ OS โดยตรง; เราท์ไปยังโหนด

### กฎสำคัญ

บทบาทเป็นแบบต่อการเชื่อมต่อ ไม่ใช่ต่ออุปกรณ์ บทบาทเป็นต่อการเชื่อมต่อ ไม่ใช่ต่ออุปกรณ์ อุปกรณ์หนึ่งอาจเปิดทั้งสองบทบาทได้ แยกกัน

---

# การยืนยันตัวตน + การจับคู่แบบรวมศูนย์

## อัตลักษณ์ไคลเอนต์

ไคลเอนต์ทุกตัวต้องให้:

- `deviceId` (เสถียร สร้างจากกุญแจอุปกรณ์)
- `displayName` (ชื่อสำหรับมนุษย์)
- `role` + `scope` + `caps` + `commands`

## โฟลว์การจับคู่ (รวมศูนย์)

- ไคลเอนต์เชื่อมต่อแบบไม่ยืนยันตัวตน
- Gateway สร้าง **คำขอจับคู่** สำหรับ `deviceId` นั้น
- Operator ได้รับพรอมป์ต์; อนุมัติ/ปฏิเสธ
- Gateway ออกข้อมูลรับรองที่ผูกกับ:
  - กุญแจสาธารณะของอุปกรณ์
  - บทบาท
  - ขอบเขต
  - ความสามารถ/คำสั่ง
- ไคลเอนต์บันทึกโทเคน แล้วเชื่อมต่อใหม่แบบยืนยันตัวตน

## การยืนยันตัวตนผูกกับอุปกรณ์ (หลีกเลี่ยงการรีเพลย์โทเคนแบบ bearer)

แนะนำ: คู่กุญแจของอุปกรณ์

- อุปกรณ์สร้างคู่กุญแจครั้งเดียว
- `deviceId = fingerprint(publicKey)`
- Gateway ส่ง nonce; อุปกรณ์ลงนาม; Gateway ตรวจสอบ
- โทเคนออกให้กับกุญแจสาธารณะ (proof‑of‑possession) ไม่ใช่สตริง

ทางเลือก:

- mTLS (ใบรับรองไคลเอนต์): แข็งแรงที่สุด แต่ซับซ้อนเชิงปฏิบัติการ
- โทเคน bearer อายุสั้น ใช้เฉพาะช่วงเปลี่ยนผ่าน (หมุนเวียน + เพิกถอนเร็ว)

## การอนุมัติแบบเงียบ (ฮิวริสติก SSH)

กำหนดให้ชัดเจนเพื่อหลีกเลี่ยงจุดอ่อน เลือกอย่างใดอย่างหนึ่ง:

- **Local‑only**: จับคู่อัตโนมัติเมื่อไคลเอนต์เชื่อมต่อผ่าน loopback/Unix socket
- **ท้าทายผ่าน SSH**: Gateway ออก nonce; ไคลเอนต์พิสูจน์ SSH ด้วยการดึงมา
- **หน้าต่างการปรากฏตัวทางกายภาพ**: หลังอนุมัติใน UI บนโฮสต์Gateway ให้จับคู่อัตโนมัติได้ช่วงสั้น (เช่น 10 นาที)

บันทึกและเก็บประวัติการอนุมัติอัตโนมัติเสมอ

---

# TLS ทุกที่ (dev + prod)

## ใช้ TLS ของ bridge เดิมซ้ำ

ใช้รันไทม์ TLS ปัจจุบัน + การปักหมุดลายนิ้วมือ:

- `src/infra/bridge/server/tls.ts`
- ลอจิกตรวจสอบลายนิ้วมือใน `src/node-host/bridge-client.ts`

## นำไปใช้กับ WS

- เซิร์ฟเวอร์ WS รองรับ TLS ด้วย cert/key เดียวกัน + ลายนิ้วมือ
- ไคลเอนต์ WS สามารถปักหมุดลายนิ้วมือได้ (ไม่บังคับ)
- Discovery โฆษณา TLS + ลายนิ้วมือสำหรับทุกเอ็นด์พอยต์
  - Discovery เป็นเพียงตัวช่วยระบุตำแหน่ง ไม่ใช่จุดยึดความเชื่อถือ

## เหตุผล

- ลดการพึ่งพา SSH/Tailscale เพื่อความลับ
- ทำให้การเชื่อมต่อมือถือระยะไกลปลอดภัยโดยค่าเริ่มต้น

---

# การออกแบบการอนุมัติใหม่ (แบบศูนย์กลาง)

## ปัจจุบัน

การอนุมัติเกิดบนโฮสต์โหนด (รันไทม์โหนดของแอปmac) พรอมป์ต์ปรากฏที่ที่โหนดรัน พรอมป์ต์จะปรากฏในตำแหน่งที่โหนดทำงาน

## ที่เสนอ

การอนุมัติ **โฮสต์ที่Gateway**, UI ส่งไปยังไคลเอนต์ operator

### โฟลว์ใหม่

1. Gateway รับ intent `system.run` (เอเจนต์)
2. Gateway สร้างบันทึกการอนุมัติ: `approval.requested`
3. UI ของ operator แสดงพรอมป์ต์
4. การตัดสินใจส่งไปที่Gateway: `approval.resolve`
5. Gateway เรียกคำสั่งโหนดหากอนุมัติ
6. โหนดรันและส่งกลับ `invoke-res`

### ความหมายเชิงการอนุมัติ (การเสริมความแข็งแรง)

- กระจายไปยัง operator ทุกคน; เฉพาะ UI ที่แอคทีฟแสดงโมดัล (ที่เหลือเป็น toast)
- การตัดสินใจแรกชนะ; Gateway ปฏิเสธการตัดสินใจถัดไปว่าเสร็จแล้ว
- หมดเวลาเริ่มต้น: ปฏิเสธหลัง N วินาที (เช่น 60 วินาที) พร้อมบันทึกเหตุผล
- การตัดสินใจต้องมีขอบเขต `operator.approvals`

## ประโยชน์

- พรอมป์ต์ปรากฏที่ที่ผู้ใช้อยู่ (mac/โทรศัพท์)
- การอนุมัติสม่ำเสมอสำหรับโหนดระยะไกล
- รันไทม์โหนดเป็น headless ไม่พึ่ง UI

---

# ตัวอย่างความชัดเจนของบทบาท

## แอป iPhone

- **บทบาท node** สำหรับ: ไมค์ กล้อง แชตเสียง ตำแหน่ง กดคุย
- **operator.read** แบบไม่บังคับสำหรับสถานะและมุมมองแชต
- **operator.write/admin** แบบไม่บังคับ เฉพาะเมื่อเปิดใช้อย่างชัดเจน

## แอปmacOS

- บทบาท operator โดยค่าเริ่มต้น (UI ควบคุม)
- บทบาท node เมื่อเปิด “Mac node” (system.run, หน้าจอ กล้อง)
- deviceId เดียวกันสำหรับทั้งสองการเชื่อมต่อ → รวมเป็นรายการ UI เดียว

## CLI

- บทบาท operator เสมอ
- ขอบเขตกำหนดตามซับคอมมานด์:
  - `status`, `logs` → read
  - `agent`, `message` → write
  - `config`, `channels` → admin
  - การอนุมัติ + การจับคู่ → `operator.approvals` / `operator.pairing`

---

# อัตลักษณ์ + slug

## ID เสถียร

จำเป็นสำหรับการยืนยันตัวตน ไม่เปลี่ยนแปลง
แนะนำ:
แนะนำ:

- ลายนิ้วมือคู่กุญแจ (แฮชกุญแจสาธารณะ)

## Slug น่ารัก (ธีมกุ้งล็อบสเตอร์)

ป้ายกำกับสำหรับมนุษย์เท่านั้น

- ตัวอย่าง: `scarlet-claw`, `saltwave`, `mantis-pinch`
- เก็บในรีจิสทรีของGateway แก้ไขได้
- การจัดการชนกัน: `-2`, `-3`

## การจัดกลุ่ม UI

`deviceId` เดียวกันข้ามบทบาท → แถว “อินสแตนซ์” เดียว:

- แบดจ์: `operator`, `node`
- แสดงความสามารถ + เห็นล่าสุด

---

# กลยุทธ์การย้าย

## ระยะ 0: เอกสาร + จัดแนว

- เผยแพร่เอกสารนี้
- ทำบัญชีรายการการเรียกโปรโตคอล + โฟลว์การอนุมัติทั้งหมด

## ระยะ 1: เพิ่มบทบาท/ขอบเขตให้ WS

- ขยายพารามิเตอร์ `connect` ด้วย `role`, `scope`, `deviceId`
- เพิ่มการคุม allowlist สำหรับบทบาท node

## ระยะ 2: ความเข้ากันได้กับ Bridge

- คง Bridge ไว้
- เพิ่มการรองรับโหนดผ่าน WS ควบคู่
- กั้นฟีเจอร์ไว้หลังแฟล็กการตั้งค่า

## ระยะ 3: การอนุมัติแบบศูนย์กลาง

- เพิ่มอีเวนต์คำขอและการตัดสินใจการอนุมัติใน WS
- อัปเดต UI แอปmac ให้แสดงพรอมป์ต์และตอบกลับ
- รันไทม์โหนดหยุดแสดง UI

## ระยะ 4: รวม TLS

- เพิ่มคอนฟิก TLS สำหรับ WS โดยใช้รันไทม์ TLS ของ bridge
- เพิ่มการปักหมุดให้ไคลเอนต์

## ระยะ 5: เลิกใช้ Bridge

- ย้ายโหนด iOS/Android/mac ไป WS
- คง Bridge เป็นตัวสำรอง และลบเมื่อเสถียร

## ระยะ 6: การยืนยันตัวตนผูกกับอุปกรณ์

- บังคับใช้ตัวตนแบบกุญแจสำหรับการเชื่อมต่อที่ไม่ใช่ local ทั้งหมด
- เพิ่ม UI สำหรับการเพิกถอน + การหมุนเวียน

---

# หมายเหตุด้านความปลอดภัย

- บทบาท/allowlist ถูกบังคับที่ขอบเขตGateway
- ไม่มีไคลเอนต์ใดได้ API “เต็มรูปแบบ” หากไม่มีขอบเขต operator
- ต้องจับคู่สำหรับการเชื่อมต่อ _ทั้งหมด_
- TLS + การปักหมุดลดความเสี่ยง MITM สำหรับมือถือ
- การอนุมัติแบบเงียบผ่าน SSH เป็นความสะดวก; ยังถูกบันทึกและเพิกถอนได้
- Discovery ไม่ใช่จุดยึดความเชื่อถือ
- การอ้างสิทธิ์ความสามารถถูกตรวจสอบกับ allowlist ฝั่งเซิร์ฟเวอร์ตามแพลตฟอร์ม/ประเภท

# สตรีมมิง + เพย์โหลดขนาดใหญ่ (สื่อของโหนด)

WS control plane เหมาะกับข้อความเล็ก แต่โหนดยังทำ:

- คลิปกล้อง
- บันทึกหน้าจอ
- สตรีมเสียง

ตัวเลือก:

1. เฟรมไบนารีของ WS + การแบ่งชิ้น + กฎ backpressure
2. เอ็นด์พอยต์สตรีมแยก (ยังใช้ TLS + การยืนยันตัวตน)
3. คง Bridge ไว้นานขึ้นสำหรับคำสั่งสื่อหนัก แล้วย้ายทีหลัง

เลือกอย่างใดอย่างหนึ่งก่อนลงมือเพื่อหลีกเลี่ยงความคลาดเคลื่อน

# นโยบายความสามารถ + คำสั่ง

- ความสามารถ/คำสั่งที่โหนดรายงานถือเป็น **การอ้างสิทธิ์**
- Gateway บังคับใช้ allowlist ต่อแพลตฟอร์ม
- คำสั่งใหม่ใด ๆ ต้องการการอนุมัติจาก operator หรือการเปลี่ยน allowlist อย่างชัดเจน
- ตรวจสอบบันทึกการเปลี่ยนแปลงพร้อมเวลา

# การตรวจสอบ + การจำกัดอัตรา

- บันทึก: คำขอจับคู่ การอนุมัติ/ปฏิเสธ การออก/หมุนเวียน/เพิกถอนโทเคน
- จำกัดอัตราการสแปมการจับคู่และพรอมป์ต์การอนุมัติ

# สุขอนามัยโปรโตคอล

- เวอร์ชันโปรโตคอลและรหัสข้อผิดพลาดที่ชัดเจน
- กฎการเชื่อมต่อใหม่ + นโยบายฮาร์ตบีต
- TTL ของสถานะและความหมายของ last‑seen

---

# คำถามที่เปิดอยู่

1. อุปกรณ์เดียวรันทั้งสองบทบาท: โมเดลโทเคน
   - แนะนำโทเคนแยกต่อบทบาท (node vs operator)
   - deviceId เดียวกัน ขอบเขตต่างกัน เพิกถอนได้ชัดเจน

2. ความละเอียดของขอบเขต operator
   - read/write/admin + approvals + pairing (ขั้นต่ำที่ใช้งานได้)
   - พิจารณาขอบเขตระดับฟีเจอร์ภายหลัง

3. UX การหมุนเวียน + เพิกถอนโทเคน
   - หมุนอัตโนมัติเมื่อบทบาทเปลี่ยน
   - UI เพิกถอนตาม deviceId + บทบาท

4. Discovery
   - ขยาย Bonjour TXT ปัจจุบันให้รวมลายนิ้วมือ TLS ของ WS + เบาะแสบทบาท
   - ใช้เป็นเพียงตัวช่วยระบุตำแหน่ง

5. การอนุมัติข้ามเครือข่าย
   - กระจายไปยัง operator ทุกคน; UI ที่แอคทีฟแสดงโมดัล
   - คำตอบแรกชนะ; Gateway บังคับความเป็นอะตอม

---

# สรุป (TL;DR)

- วันนี้: WS control plane + Bridge สำหรับทรานสปอร์ตโหนด
- ปัญหา: การอนุมัติ + ความซ้ำซ้อน + สองสแตก
- ข้อเสนอ: โปรโตคอล WS เดียวพร้อมบทบาท + ขอบเขตที่ชัด การจับคู่รวมศูนย์ + การปักหมุดTLS การอนุมัติที่โฮสต์โดยGateway อัตลักษณ์อุปกรณ์เสถียร + slug น่ารัก
- ผลลัพธ์: UX ง่ายขึ้น ความปลอดภัยแข็งแรงขึ้น ลดความซ้ำซ้อน และการเราท์บนมือถือที่ดีกว่า
