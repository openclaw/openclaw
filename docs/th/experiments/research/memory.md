---
summary: "บันทึกการวิจัย: ระบบหน่วยความจำออฟไลน์สำหรับเวิร์กสเปซของClawd (Markdownเป็นแหล่งข้อมูลหลัก + ดัชนีที่สร้างจากอนุพันธ์)"
read_when:
  - การออกแบบหน่วยความจำเวิร์กสเปซ (~/.openclaw/workspace) นอกเหนือจากบันทึกMarkdownรายวัน
  - Deciding: "การตัดสินใจ: CLI แบบสแตนด์อโลน vs การผสานรวมกับOpenClawอย่างลึก"
  - การเพิ่มการเรียกคืนออฟไลน์ + การสะท้อน (retain/recall/reflect)
title: "การวิจัยหน่วยความจำเวิร์กสเปซ"
---

# Workspace Memory v2 (ออฟไลน์): บันทึกการวิจัย

เป้าหมาย: เวิร์กสเปซสไตล์Clawd (`agents.defaults.workspace`, ค่าเริ่มต้น `~/.openclaw/workspace`) ซึ่ง “หน่วยความจำ” ถูกจัดเก็บเป็นไฟล์Markdownหนึ่งไฟล์ต่อวัน (`memory/YYYY-MM-DD.md`) พร้อมไฟล์ที่คงที่จำนวนเล็กน้อย (เช่น `memory.md`, `SOUL.md`)

เอกสารนี้เสนอสถาปัตยกรรมหน่วยความจำแบบ **offline-first** ที่คงMarkdownเป็นแหล่งข้อมูลหลักที่ตรวจทานได้โดยมนุษย์ แต่เพิ่ม **การเรียกคืนเชิงโครงสร้าง** (การค้นหา สรุปเอนทิตี การอัปเดตความเชื่อมั่น) ผ่านดัชนีที่สร้างจากอนุพันธ์

## ทำไมต้องเปลี่ยน?

การตั้งค่าปัจจุบัน (หนึ่งไฟล์ต่อวัน) ดีเยี่ยมสำหรับ:

- การบันทึกแบบ “append-only”
- การแก้ไขโดยมนุษย์
- ความทนทานและการตรวจสอบย้อนหลังด้วยgit
- การบันทึกที่แรงเสียดทานต่ำ (“แค่เขียนลงไป”)

It’s weak for:

- การดึงข้อมูลที่ต้องการการเรียกคืนสูง (“เราตัดสินใจเรื่องXว่าอย่างไร?”, “ครั้งล่าสุดที่ลองYคือเมื่อไหร่?”)
- คำตอบแบบยึดเอนทิตีเป็นศูนย์กลาง (“เล่าให้ฟังเกี่ยวกับAlice / The Castle / warelay”) โดยไม่ต้องอ่านหลายไฟล์
- ความเสถียรของความคิดเห็น/ความชอบ (และหลักฐานเมื่อมีการเปลี่ยน)
- ข้อจำกัดด้านเวลา (“อะไรเป็นความจริงในช่วงพ.ย.2025?”) และการแก้ไขความขัดแย้ง

## เป้าหมายการออกแบบ

- **ออฟไลน์**: ทำงานได้โดยไม่ต้องใช้เครือข่าย; รันบนแล็ปท็อป/ปราสาท; ไม่พึ่งพาคลาวด์
- **อธิบายได้**: รายการที่ดึงมาควรระบุแหล่งที่มาได้ (ไฟล์ + ตำแหน่ง) และแยกจากการอนุมาน
- **พิธีการต่ำ**: การบันทึกรายวันยังคงเป็นMarkdown ไม่ต้องมีสคีมาหนัก
- **เพิ่มทีละขั้น**: v1 ใช้ได้ด้วยFTSอย่างเดียว; semantic/vectorและกราฟเป็นอัปเกรดเสริม
- **เป็นมิตรกับเอเจนต์**: ทำให้ “การเรียกคืนภายใต้งบโทเคน” ง่าย (ส่งคืนชุดข้อเท็จจริงขนาดเล็ก)

## โมเดลเป้าหมาย (Hindsight × Letta)

สองส่วนที่ต้องผสาน:

1. **ลูปควบคุมสไตล์Letta/MemGPT**

- เก็บ “แกนหลัก” ขนาดเล็กไว้ในบริบทเสมอ (persona + ข้อเท็จจริงผู้ใช้ที่สำคัญ)
- ทุกอย่างอื่นอยู่นอกบริบทและเรียกคืนผ่านเครื่องมือ
- การเขียนหน่วยความจำเป็นการเรียกเครื่องมือแบบชัดเจน (append/replace/insert) ถูกบันทึก แล้วฉีดกลับเข้ามาในเทิร์นถัดไป

2. **ซับสเตรตหน่วยความจำสไตล์Hindsight**

- แยกสิ่งที่สังเกต vs สิ่งที่เชื่อ vs สิ่งที่สรุป
- รองรับ retain/recall/reflect
- ความคิดเห็นที่มีระดับความเชื่อมั่นและพัฒนาได้ด้วยหลักฐาน
- การเรียกคืนที่ตระหนักถึงเอนทิตี + คำถามเชิงเวลา (แม้ไม่มีกราฟความรู้เต็มรูปแบบ)

## สถาปัตยกรรมที่เสนอ (Markdownเป็นแหล่งข้อมูลหลัก + ดัชนีที่สร้างจากอนุพันธ์)

### คลังข้อมูลหลัก (เป็นมิตรกับgit)

เก็บ `~/.openclaw/workspace` เป็นหน่วยความจำหลักที่มนุษย์อ่านได้

เลย์เอาต์เวิร์กสเปซที่แนะนำ:

```
~/.openclaw/workspace/
  memory.md                    # small: durable facts + preferences (core-ish)
  memory/
    YYYY-MM-DD.md              # daily log (append; narrative)
  bank/                        # “typed” memory pages (stable, reviewable)
    world.md                   # objective facts about the world
    experience.md              # what the agent did (first-person)
    opinions.md                # subjective prefs/judgments + confidence + evidence pointers
    entities/
      Peter.md
      The-Castle.md
      warelay.md
      ...
```

หมายเหตุ:

- **Daily log stays daily log**. No need to turn it into JSON.
- ไฟล์ `bank/` เป็นไฟล์ **คัดสรร** ผลิตโดยงานสะท้อน และยังแก้ไขด้วยมือได้
- `memory.md` ยังคง “เล็ก + ใกล้แกน”: สิ่งที่คุณต้องการให้Clawdเห็นทุกเซสชัน

### คลังข้อมูลอนุพันธ์ (การเรียกคืนของเครื่อง)

เพิ่มดัชนีอนุพันธ์ภายใต้เวิร์กสเปซ (ไม่จำเป็นต้องติดตามด้วยgit):

```
~/.openclaw/workspace/.memory/index.sqlite
```

Back it with:

- สคีมาSQLiteสำหรับข้อเท็จจริง + ลิงก์เอนทิตี + เมตาดาต้าความคิดเห็น
- SQLite **FTS5** สำหรับการเรียกคืนเชิงคำศัพท์ (เร็ว เล็ก ออฟไลน์)
- ตารางembeddingsเสริมสำหรับการเรียกคืนเชิงความหมาย (ยังคงออฟไลน์)

ดัชนีสามารถ **สร้างใหม่จากMarkdownได้เสมอ**

## Retain / Recall / Reflect (ลูปการปฏิบัติการ)

### Retain: ทำให้บันทึกรายวันเป็น “ข้อเท็จจริง”

อินไซต์สำคัญของHindsightที่ใช้ได้ที่นี่: เก็บ **ข้อเท็จจริงเชิงบรรยายที่สมบูรณ์ในตัวเอง** ไม่ใช่ชิ้นส่วนเล็กๆ

กฎเชิงปฏิบัติสำหรับ `memory/YYYY-MM-DD.md`:

- ตอนสิ้นวัน (หรือระหว่างวัน) เพิ่มส่วน `## Retain` พร้อมบูลเล็ต 2–5 ข้อ ที่:
  - เป็นเชิงบรรยาย (รักษาบริบทข้ามเทิร์น)
  - สมบูรณ์ในตัวเอง (อ่านเดี่ยวๆแล้วเข้าใจ)
  - ติดแท็กด้วยชนิด + การกล่าวถึงเอนทิตี

ตัวอย่าง:

```
## Retain
- W @Peter: Currently in Marrakech (Nov 27–Dec 1, 2025) for Andy’s birthday.
- B @warelay: I fixed the Baileys WS crash by wrapping connection.update handlers in try/catch (see memory/2025-11-27.md).
- O(c=0.95) @Peter: Prefers concise replies (&lt;1500 chars) on WhatsApp; long content goes into files.
```

การพาร์สขั้นต่ำ:

- คำนำหน้าชนิด: `W` (โลก), `B` (ประสบการณ์/ชีวประวัติ), `O` (ความคิดเห็น), `S` (การสังเกต/สรุป; มักถูกสร้าง)
- เอนทิตี: `@Peter`, `@warelay` ฯลฯ (slugแมปไปที่ `bank/entities/*.md`)
- ความเชื่อมั่นของความคิดเห็น: `O(c=0.0..1.0)` ไม่บังคับ

หากไม่ต้องการให้ผู้เขียนต้องคิดมาก งานสะท้อนสามารถอนุมานบูลเล็ตเหล่านี้จากบันทึกที่เหลือได้ แต่การมีส่วน `## Retain` แบบชัดเจนคือ “คันโยกคุณภาพ” ที่ง่ายที่สุด

### Recall: การสืบค้นผ่านดัชนีอนุพันธ์

การเรียกคืนควรรองรับ:

- **เชิงคำศัพท์**: “ค้นหาคำ/ชื่อ/คำสั่งแบบตรงตัว” (FTS5)
- **เชิงเอนทิตี**: “เล่าให้ฟังเกี่ยวกับX” (หน้าเอนทิตี + ข้อเท็จจริงที่เชื่อมกับเอนทิตี)
- **เชิงเวลา**: “เกิดอะไรขึ้นแถวๆ27พ.ย.” / “ตั้งแต่สัปดาห์ที่แล้ว”
- **เชิงความคิดเห็น**: “Peterชอบอะไร?” (พร้อมความเชื่อมั่น + หลักฐาน)

รูปแบบการส่งคืนควรเป็นมิตรกับเอเจนต์และอ้างอิงแหล่งที่มา:

- `kind` (`world|experience|opinion|observation`)
- `timestamp` (วันต้นทาง หรือช่วงเวลาที่สกัดได้ถ้ามี)
- `entities` (`["Peter","warelay"]`)
- `content` (ข้อเท็จจริงเชิงบรรยาย)
- `source` (`memory/2025-11-27.md#L12` ฯลฯ)

### Reflect: สร้างหน้าที่เสถียร + อัปเดตความเชื่อ

การสะท้อนเป็นงานตามตาราง (รายวันหรือฮาร์ตบีต `ultrathink`) ที่:

- อัปเดต `bank/entities/*.md` จากข้อเท็จจริงล่าสุด (สรุปเอนทิตี)
- อัปเดตความเชื่อมั่นของ `bank/opinions.md` ตามการเสริมหรือขัดแย้ง
- เสนอการแก้ไข `memory.md` แบบเลือกได้ (“ใกล้แกน” และคงทน)

วิวัฒนาการของความคิดเห็น (เรียบง่าย อธิบายได้):

- แต่ละความคิดเห็นมี:
  - statement
  - ความเชื่อมั่น `c ∈ [0,1]`
  - last_updated
  - ลิงก์หลักฐาน (สนับสนุน + ขัดแย้ง IDข้อเท็จจริง)
- เมื่อมีข้อเท็จจริงใหม่:
  - หา候选ความคิดเห็นด้วยการทับซ้อนเอนทิตี + ความคล้าย (เริ่มด้วยFTS แล้วค่อย embeddings)
  - ปรับความเชื่อมั่นทีละน้อย; การเปลี่ยนแปลงมากต้องมีการขัดแย้งที่แรง + หลักฐานซ้ำ

## การผสานรวมCLI: สแตนด์อโลน vs ผสานลึก

ข้อแนะนำ: **ผสานรวมลึกในOpenClaw** แต่แยกไลบรารีแกนหลักได้

### ทำไมต้องผสานในOpenClaw?

- OpenClawรู้อยู่แล้ว:
  - พาธเวิร์กสเปซ (`agents.defaults.workspace`)
  - โมเดลเซสชัน + ฮาร์ตบีต
  - รูปแบบการบันทึก + การแก้ไขปัญหา
- คุณต้องการให้เอเจนต์เรียกเครื่องมือเอง:
  - `openclaw memory recall "…" --k 25 --since 30d`
  - `openclaw memory reflect --since 7d`

### ทำไมยังต้องแยกเป็นไลบรารี?

- ทำให้ตรรกะหน่วยความจำทดสอบได้โดยไม่ต้องพึ่งGateway/รันไทม์
- นำกลับไปใช้ในบริบทอื่น (สคริปต์โลคัล แอปเดสก์ท็อปในอนาคต ฯลฯ)

รูปแบบ:
เครื่องมือหน่วยความจำตั้งใจให้เป็นCLIขนาดเล็ก + ชั้นไลบรารี แต่ทั้งหมดนี้เป็นเชิงสำรวจเท่านั้น

## “S-Collide” / SuCo: ควรใช้เมื่อใด (การวิจัย)

หาก “S-Collide” หมายถึง **SuCo (Subspace Collision)**: เป็นแนวทางการดึงANNที่มุ่งเน้นสมดุลระหว่างการเรียกคืน/เวลาแฝงโดยใช้การชนกันที่เรียนรู้/มีโครงสร้างในซับสเปซ (บทความ: arXiv 2411.14754, 2024)

มุมมองเชิงปฏิบัติสำหรับ `~/.openclaw/workspace`:

- **อย่าเริ่ม** ด้วยSuCo
- เริ่มด้วยSQLite FTS + (เสริม) embeddingsแบบง่าย; จะได้ประสบการณ์ผู้ใช้ส่วนใหญ่ทันที
- พิจารณาโซลูชันระดับSuCo/HNSW/ScaNNก็ต่อเมื่อ:
  - คอร์ปัสมีขนาดใหญ่ (หลายหมื่น/แสนชิ้น)
  - การค้นหาembeddingsแบบ brute-force ช้าเกินไป
  - recall quality is meaningfully bottlenecked by lexical search

ทางเลือกที่เป็นมิตรกับออฟไลน์ (ซับซ้อนเพิ่มขึ้นตามลำดับ):

- SQLite FTS5 + ตัวกรองเมตาดาต้า (ไม่มีML)
- Embeddings + brute force (ไปได้ไกลกว่าที่คิดเมื่อจำนวนชิ้นไม่มาก)
- ดัชนีHNSW (แพร่หลาย แข็งแรง; ต้องมีไลบรารี)
- SuCo (ระดับวิจัย; น่าสนใจหากมีอิมพลีเมนต์ที่ฝังได้)

คำถามเปิด:

- โมเดลembeddingออฟไลน์ที่ **ดีที่สุด** สำหรับ “หน่วยความจำผู้ช่วยส่วนตัว” บนเครื่องของคุณ (แล็ปท็อป + เดสก์ท็อป) คืออะไร?
  - หากคุณมีOllamaอยู่แล้ว: ฝังด้วยโมเดลโลคัล; มิฉะนั้นจัดส่งโมเดลembeddingขนาดเล็กไปกับทูลเชน

## Smallest useful pilot

หากต้องการเวอร์ชันขั้นต่ำที่ยังใช้ได้:

- เพิ่มหน้าเอนทิตี `bank/` และส่วน `## Retain` ในบันทึกรายวัน
- ใช้SQLite FTSสำหรับการเรียกคืนพร้อมการอ้างอิง (พาธ + หมายเลขบรรทัด)
- เพิ่มembeddingsเฉพาะเมื่อคุณภาพการเรียกคืนหรือสเกลต้องการ

## อ้างอิง

- แนวคิดLetta / MemGPT: “core memory blocks” + “archival memory” + หน่วยความจำที่แก้ไขตนเองด้วยเครื่องมือ
- รายงานเทคนิคHindsight: “retain / recall / reflect”, หน่วยความจำสี่เครือข่าย, การสกัดข้อเท็จจริงเชิงบรรยาย, วิวัฒนาการความเชื่อมั่นของความคิดเห็น
- SuCo: arXiv 2411.14754 (2024): “Subspace Collision” การดึงเพื่อนบ้านใกล้เคียงโดยประมาณ
