---
summary: "Clawnet रिफैक्टर: नेटवर्क प्रोटोकॉल, भूमिकाएँ, प्रमाणीकरण, अनुमोदन और पहचान का एकीकरण"
read_when:
  - नोड्स + ऑपरेटर क्लाइंट्स के लिए एकीकृत नेटवर्क प्रोटोकॉल की योजना बनाते समय
  - उपकरणों के बीच अनुमोदन, पेयरिंग, TLS और उपस्थिति को पुनः डिज़ाइन करते समय
title: "Clawnet रिफैक्टर"
---

# Clawnet रिफैक्टर (प्रोटोकॉल + प्रमाणीकरण का एकीकरण)

## नमस्ते

नमस्ते पीटर — शानदार दिशा; इससे सरल UX और अधिक मजबूत सुरक्षा संभव होती है।

## उद्देश्य

इसके लिए एक एकल, सख़्त दस्तावेज़:

- वर्तमान स्थिति: प्रोटोकॉल, फ़्लो, ट्रस्ट सीमाएँ।
- समस्याएँ: अनुमोदन, मल्टी‑हॉप रूटिंग, UI दोहराव।
- प्रस्तावित नई स्थिति: एक प्रोटोकॉल, सीमित भूमिकाएँ, एकीकृत प्रमाणीकरण/पेयरिंग, TLS पिनिंग।
- पहचान मॉडल: स्थिर IDs + प्यारे स्लग।
- माइग्रेशन योजना, जोखिम, खुले प्रश्न।

## लक्ष्य (चर्चा से)

- सभी क्लाइंट्स के लिए एक प्रोटोकॉल (mac ऐप, CLI, iOS, Android, हेडलेस नोड)।
- हर नेटवर्क प्रतिभागी का प्रमाणीकरण + पेयरिंग।
- भूमिका स्पष्टता: नोड्स बनाम ऑपरेटर्स।
- केंद्रीय अनुमोदन जो उपयोगकर्ता जहाँ है वहाँ रूट हों।
- सभी रिमोट ट्रैफ़िक के लिए TLS एन्क्रिप्शन + वैकल्पिक पिनिंग।
- न्यूनतम कोड दोहराव।
- एक ही मशीन UI में एक बार ही दिखे (कोई UI/नोड डुप्लिकेट एंट्री नहीं)।

## गैर‑लक्ष्य (स्पष्ट)

- क्षमता पृथक्करण हटाना (न्यूनतम‑विशेषाधिकार अभी भी आवश्यक)।
- स्कोप जाँच के बिना पूर्ण Gateway कंट्रोल प्लेन उजागर करना।
- प्रमाणीकरण को मानव लेबल्स पर निर्भर बनाना (स्लग सुरक्षा‑संबंधी नहीं रहते)।

---

# वर्तमान स्थिति (as‑is)

## दो प्रोटोकॉल

### 1. Gateway WebSocket (कंट्रोल प्लेन)

- पूर्ण API सतह: config, channels, models, sessions, agent runs, logs, nodes, आदि।
- Default bind: loopback. Remote access via SSH/Tailscale.
- प्रमाणीकरण: `connect` के माध्यम से टोकन/पासवर्ड।
- TLS पिनिंग नहीं (loopback/टनल पर निर्भर)।
- कोड:
  - `src/gateway/server/ws-connection/message-handler.ts`
  - `src/gateway/client.ts`
  - `docs/gateway/protocol.md`

### 2. Bridge (नोड ट्रांसपोर्ट)

- सीमित allowlist सतह, नोड पहचान + पेयरिंग।
- TCP पर JSONL; वैकल्पिक TLS + प्रमाणपत्र फ़िंगरप्रिंट पिनिंग।
- TLS डिस्कवरी TXT में फ़िंगरप्रिंट विज्ञापित करता है।
- कोड:
  - `src/infra/bridge/server/connection.ts`
  - `src/gateway/server-bridge.ts`
  - `src/node-host/bridge-client.ts`
  - `docs/gateway/bridge-protocol.md`

## आज के कंट्रोल प्लेन क्लाइंट्स

- CLI → Gateway WS via `callGateway` (`src/gateway/call.ts`)।
- macOS ऐप UI → Gateway WS (`GatewayConnection`)।
- वेब कंट्रोल UI → Gateway WS।
- ACP → Gateway WS।
- ब्राउज़र कंट्रोल अपने अलग HTTP कंट्रोल सर्वर का उपयोग करता है।

## आज के नोड्स

- macOS ऐप (नोड मोड) Gateway bridge से कनेक्ट करता है (`MacNodeBridgeSession`)।
- iOS/Android ऐप्स Gateway bridge से कनेक्ट करते हैं।
- पेयरिंग + प्रति‑नोड टोकन Gateway पर संग्रहीत।

## वर्तमान अनुमोदन फ़्लो (exec)

- एजेंट Gateway के माध्यम से `system.run` का उपयोग करता है।
- Gateway bridge के माध्यम से नोड को कॉल करता है।
- नोड रनटाइम अनुमोदन का निर्णय लेता है।
- UI प्रॉम्प्ट mac ऐप द्वारा दिखाया जाता है (जब नोड == mac ऐप)।
- नोड `invoke-res` Gateway को लौटाता है।
- मल्टी‑हॉप, UI नोड होस्ट से जुड़ा हुआ।

## उपस्थिति + पहचान आज

- WS क्लाइंट्स से Gateway उपस्थिति प्रविष्टियाँ।
- bridge से नोड उपस्थिति प्रविष्टियाँ।
- mac ऐप एक ही मशीन के लिए दो प्रविष्टियाँ दिखा सकता है (UI + नोड)।
- नोड पहचान pairing store में; UI पहचान अलग।

---

# समस्याएँ / दर्द बिंदु

- दो प्रोटोकॉल स्टैक्स का रखरखाव (WS + Bridge)।
- रिमोट नोड्स पर अनुमोदन: प्रॉम्प्ट नोड होस्ट पर दिखता है, उपयोगकर्ता जहाँ है वहाँ नहीं।
- TLS पिनिंग केवल bridge में; WS SSH/Tailscale पर निर्भर।
- पहचान दोहराव: एक ही मशीन कई इंस्टेंस के रूप में दिखती है।
- अस्पष्ट भूमिकाएँ: UI + नोड + CLI क्षमताएँ स्पष्ट रूप से अलग नहीं।

---

# प्रस्तावित नई स्थिति (Clawnet)

## एक प्रोटोकॉल, दो भूमिकाएँ

भूमिका + स्कोप के साथ एकल WS प्रोटोकॉल।

- **भूमिका: node** (क्षमता होस्ट)
- **भूमिका: operator** (कंट्रोल प्लेन)
- ऑपरेटर के लिए वैकल्पिक **scope**:
  - `operator.read` (स्थिति + दृश्य)
  - `operator.write` (agent run, sends)
  - `operator.admin` (config, channels, models)

### भूमिका व्यवहार

**Node**

- क्षमताएँ रजिस्टर कर सकता है (`caps`, `commands`, permissions)।
- `invoke` कमांड्स प्राप्त कर सकता है (`system.run`, `camera.*`, `canvas.*`, `screen.record`, आदि)।
- इवेंट्स भेज सकता है: `voice.transcript`, `agent.request`, `chat.subscribe`।
- config/models/channels/sessions/agent कंट्रोल प्लेन APIs को कॉल नहीं कर सकता।

**Operator**

- स्कोप द्वारा नियंत्रित पूर्ण कंट्रोल प्लेन API।
- सभी अनुमोदन प्राप्त करता है।
- सीधे OS क्रियाएँ निष्पादित नहीं करता; नोड्स को रूट करता है।

### प्रमुख नियम

Role is per‑connection, not per device. A device may open both roles, separately.

---

# एकीकृत प्रमाणीकरण + पेयरिंग

## क्लाइंट पहचान

हर क्लाइंट प्रदान करता है:

- `deviceId` (स्थिर, डिवाइस कुंजी से व्युत्पन्न)।
- `displayName` (मानव नाम)।
- `role` + `scope` + `caps` + `commands`।

## पेयरिंग फ़्लो (एकीकृत)

- क्लाइंट बिना प्रमाणीकरण कनेक्ट करता है।
- Gateway उस `deviceId` के लिए **पेयरिंग अनुरोध** बनाता है।
- ऑपरेटर को प्रॉम्प्ट मिलता है; स्वीकृत/अस्वीकृत करता है।
- Gateway निम्न से बंधी क्रेडेंशियल्स जारी करता है:
  - डिवाइस सार्वजनिक कुंजी
  - भूमिका(एँ)
  - स्कोप(एँ)
  - क्षमताएँ/कमांड्स
- क्लाइंट टोकन सहेजता है, प्रमाणीकृत होकर पुनः कनेक्ट करता है।

## डिवाइस‑बाउंड प्रमाणीकरण (bearer token replay से बचाव)

प्राथमिकता: डिवाइस keypairs।

- डिवाइस एक बार keypair बनाता है।
- `deviceId = fingerprint(publicKey)`।
- Gateway nonce भेजता है; डिवाइस साइन करता है; Gateway सत्यापित करता है।
- टोकन स्ट्रिंग नहीं, सार्वजनिक कुंजी (proof‑of‑possession) से जारी होते हैं।

विकल्प:

- mTLS (क्लाइंट प्रमाणपत्र): सबसे मज़बूत, अधिक ऑप्स जटिलता।
- अल्प‑कालिक bearer tokens केवल अस्थायी चरण के रूप में (घुमाएँ + शीघ्र निरस्त करें)।

## साइलेंट अनुमोदन (SSH heuristic)

Define it precisely to avoid a weak link. Prefer one:

- **Local‑only**: जब क्लाइंट loopback/Unix socket से कनेक्ट करे तो auto‑pair।
- **SSH के माध्यम से चुनौती**: Gateway nonce जारी करे; क्लाइंट SSH द्वारा उसे प्राप्त कर प्रमाण दे।
- **भौतिक उपस्थिति विंडो**: Gateway होस्ट UI पर स्थानीय अनुमोदन के बाद, थोड़े समय (जैसे 10 मिनट) के लिए auto‑pair की अनुमति।

हमेशा auto‑approvals को लॉग + रिकॉर्ड करें।

---

# हर जगह TLS (dev + prod)

## मौजूदा bridge TLS का पुनः उपयोग

वर्तमान TLS रनटाइम + फ़िंगरप्रिंट पिनिंग का उपयोग करें:

- `src/infra/bridge/server/tls.ts`
- `src/node-host/bridge-client.ts` में फ़िंगरप्रिंट सत्यापन लॉजिक

## WS पर लागू करें

- WS सर्वर उसी cert/key + फ़िंगरप्रिंट के साथ TLS सपोर्ट करे।
- WS क्लाइंट्स फ़िंगरप्रिंट पिन कर सकते हैं (वैकल्पिक)।
- डिस्कवरी सभी एंडपॉइंट्स के लिए TLS + फ़िंगरप्रिंट विज्ञापित करे।
  - डिस्कवरी केवल लोकेटर संकेत है; कभी भी trust anchor नहीं।

## क्यों

- गोपनीयता के लिए SSH/Tailscale पर निर्भरता कम करना।
- रिमोट मोबाइल कनेक्शनों को डिफ़ॉल्ट रूप से सुरक्षित बनाना।

---

# अनुमोदन पुनःडिज़ाइन (केंद्रीकृत)

## वर्तमान

Approval happens on node host (mac app node runtime). Prompt appears where node runs.

## प्रस्तावित

अनुमोदन **Gateway‑होस्टेड** होगा, UI ऑपरेटर क्लाइंट्स को डिलीवर किया जाएगा।

### नया फ़्लो

1. Gateway `system.run` intent (agent) प्राप्त करता है।
2. Gateway अनुमोदन रिकॉर्ड बनाता है: `approval.requested`।
3. ऑपरेटर UI(s) प्रॉम्प्ट दिखाते हैं।
4. अनुमोदन निर्णय Gateway को भेजा जाता है: `approval.resolve`।
5. स्वीकृति पर Gateway नोड कमांड को कॉल करता है।
6. नोड निष्पादित करता है, `invoke-res` लौटाता है।

### अनुमोदन अर्थ (हार्डनिंग)

- सभी ऑपरेटर्स को ब्रॉडकास्ट; केवल सक्रिय UI मोडल दिखाता है (अन्य को टोस्ट)।
- पहला निर्णय मान्य; Gateway बाद के निर्णयों को पहले से निपटान बताकर अस्वीकार करता है।
- डिफ़ॉल्ट टाइमआउट: N सेकंड बाद अस्वीकार (जैसे 60s), कारण लॉग करें।
- निर्णय के लिए `operator.approvals` स्कोप आवश्यक।

## लाभ

- प्रॉम्प्ट उपयोगकर्ता जहाँ है (mac/फोन) वहाँ दिखता है।
- रिमोट नोड्स के लिए सुसंगत अनुमोदन।
- नोड रनटाइम हेडलेस रहता है; UI निर्भरता नहीं।

---

# भूमिका स्पष्टता उदाहरण

## iPhone ऐप

- **Node भूमिका**: mic, camera, voice chat, location, push‑to‑talk।
- वैकल्पिक **operator.read**: स्थिति और चैट दृश्य।
- वैकल्पिक **operator.write/admin** केवल स्पष्ट रूप से सक्षम होने पर।

## macOS ऐप

- डिफ़ॉल्ट रूप से Operator भूमिका (कंट्रोल UI)।
- “Mac node” सक्षम होने पर Node भूमिका (system.run, screen, camera)।
- दोनों कनेक्शनों के लिए समान deviceId → मर्ज्ड UI एंट्री।

## CLI

- हमेशा Operator भूमिका।
- उपकमांड के अनुसार स्कोप:
  - `status`, `logs` → read
  - `agent`, `message` → write
  - `config`, `channels` → admin
  - अनुमोदन + पेयरिंग → `operator.approvals` / `operator.pairing`

---

# पहचान + स्लग

## स्थिर ID

Required for auth; never changes.
प्राथमिक:

- keypair फ़िंगरप्रिंट (पब्लिक की हैश)।

## प्यारा स्लग (लॉब्स्टर‑थीम)

केवल मानव लेबल।

- उदाहरण: `scarlet-claw`, `saltwave`, `mantis-pinch`।
- Gateway रजिस्ट्री में संग्रहीत, संपादन योग्य।
- टकराव हैंडलिंग: `-2`, `-3`।

## UI समूहकरण

भूमिकाओं में समान `deviceId` → एकल “Instance” पंक्ति:

- बैज: `operator`, `node`।
- क्षमताएँ + अंतिम बार देखा गया दिखाता है।

---

# माइग्रेशन रणनीति

## चरण 0: दस्तावेज़ + संरेखण

- इस दस्तावेज़ को प्रकाशित करें।
- सभी प्रोटोकॉल कॉल्स + अनुमोदन फ़्लोज़ की सूची बनाएँ।

## चरण 1: WS में भूमिकाएँ/स्कोप जोड़ें

- `connect` params को `role`, `scope`, `deviceId` के साथ विस्तारित करें।
- node भूमिका के लिए allowlist गेटिंग जोड़ें।

## चरण 2: Bridge संगतता

- bridge चालू रखें।
- समानांतर WS node सपोर्ट जोड़ें।
- फीचर्स को config फ़्लैग के पीछे रखें।

## चरण 3: केंद्रीय अनुमोदन

- WS में अनुमोदन अनुरोध + resolve इवेंट्स जोड़ें।
- mac ऐप UI को प्रॉम्प्ट + प्रतिक्रिया के लिए अपडेट करें।
- नोड रनटाइम UI प्रॉम्प्ट करना बंद करे।

## चरण 4: TLS एकीकरण

- bridge TLS रनटाइम का उपयोग करके WS के लिए TLS config जोड़ें।
- क्लाइंट्स में पिनिंग जोड़ें।

## चरण 5: bridge को अप्रचलित करें

- iOS/Android/mac नोड को WS पर माइग्रेट करें।
- fallback के रूप में bridge रखें; स्थिर होने पर हटाएँ।

## चरण 6: डिवाइस‑बाउंड प्रमाणीकरण

- सभी non‑local कनेक्शनों के लिए key‑आधारित पहचान आवश्यक करें।
- निरस्तीकरण + रोटेशन UI जोड़ें।

---

# सुरक्षा नोट्स

- भूमिकाएँ/allowlist Gateway सीमा पर लागू।
- operator स्कोप के बिना किसी क्लाइंट को “पूर्ण” API नहीं।
- _सभी_ कनेक्शनों के लिए पेयरिंग आवश्यक।
- TLS + पिनिंग मोबाइल के लिए MITM जोखिम कम करता है।
- SSH साइलेंट अनुमोदन सुविधा है; फिर भी रिकॉर्डेबल + निरस्त करने योग्य।
- डिस्कवरी कभी trust anchor नहीं।
- क्षमता दावे प्लेटफ़ॉर्म/प्रकार द्वारा सर्वर allowlists के विरुद्ध सत्यापित होते हैं।

# स्ट्रीमिंग + बड़े पेलोड्स (नोड मीडिया)

WS कंट्रोल प्लेन छोटे संदेशों के लिए ठीक है, लेकिन नोड्स यह भी करते हैं:

- कैमरा क्लिप्स
- स्क्रीन रिकॉर्डिंग्स
- ऑडियो स्ट्रीम्स

विकल्प:

1. WS बाइनरी फ़्रेम्स + चंकिंग + बैकप्रेशर नियम।
2. अलग स्ट्रीमिंग एंडपॉइंट (फिर भी TLS + auth)।
3. मीडिया‑भारी कमांड्स के लिए bridge को अधिक समय रखें, अंत में माइग्रेट करें।

ड्रिफ्ट से बचने के लिए कार्यान्वयन से पहले एक चुनें।

# क्षमता + कमांड नीति

- नोड‑रिपोर्टेड caps/commands को **claims** माना जाता है।
- Gateway प्रति‑प्लेटफ़ॉर्म allowlists लागू करता है।
- किसी भी नए कमांड के लिए ऑपरेटर अनुमोदन या स्पष्ट allowlist परिवर्तन आवश्यक।
- टाइमस्टैम्प के साथ परिवर्तनों का ऑडिट करें।

# ऑडिट + रेट लिमिटिंग

- लॉग करें: पेयरिंग अनुरोध, अनुमोदन/अस्वीकृति, टोकन जारी/रोटेशन/निरस्तीकरण।
- पेयरिंग स्पैम और अनुमोदन प्रॉम्प्ट्स पर रेट‑लिमिट लगाएँ।

# प्रोटोकॉल स्वच्छता

- स्पष्ट प्रोटोकॉल संस्करण + त्रुटि कोड्स।
- री‑कनेक्ट नियम + हार्टबीट नीति।
- उपस्थिति TTL और last‑seen सेमांटिक्स।

---

# खुले प्रश्न

1. एक ही डिवाइस दोनों भूमिकाएँ चला रहा हो: टोकन मॉडल
   - प्रति भूमिका अलग टोकन की सिफ़ारिश (node बनाम operator)।
   - समान deviceId; अलग स्कोप; स्पष्ट निरस्तीकरण।

2. ऑपरेटर स्कोप की सूक्ष्मता
   - read/write/admin + approvals + pairing (न्यूनतम व्यवहार्य)।
   - बाद में प्रति‑फ़ीचर स्कोप पर विचार करें।

3. टोकन रोटेशन + निरस्तीकरण UX
   - भूमिका परिवर्तन पर auto‑rotate।
   - deviceId + भूमिका के आधार पर निरस्तीकरण UI।

4. डिस्कवरी
   - वर्तमान Bonjour TXT को WS TLS फ़िंगरप्रिंट + भूमिका संकेतों के साथ विस्तारित करें।
   - केवल लोकेटर संकेत के रूप में मानें।

5. क्रॉस‑नेटवर्क अनुमोदन
   - सभी ऑपरेटर क्लाइंट्स को ब्रॉडकास्ट; सक्रिय UI मोडल दिखाए।
   - पहला उत्तर मान्य; Gateway एटोमिकता लागू करे।

---

# सारांश (TL;DR)

- आज: WS कंट्रोल प्लेन + Bridge नोड ट्रांसपोर्ट।
- समस्या: अनुमोदन + दोहराव + दो स्टैक्स।
- प्रस्ताव: स्पष्ट भूमिकाओं + स्कोप्स के साथ एक WS प्रोटोकॉल, एकीकृत पेयरिंग + TLS पिनिंग, Gateway‑होस्टेड अनुमोदन, स्थिर डिवाइस IDs + प्यारे स्लग।
- परिणाम: सरल UX, मज़बूत सुरक्षा, कम दोहराव, बेहतर मोबाइल रूटिंग।
