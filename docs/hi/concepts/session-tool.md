---
summary: "सत्रों की सूची बनाने, इतिहास प्राप्त करने और क्रॉस‑सत्र संदेश भेजने के लिए एजेंट सत्र टूल्स"
read_when:
  - सत्र टूल्स जोड़ते या संशोधित करते समय
title: "सत्र टूल्स"
---

# सत्र टूल्स

लक्ष्य: छोटे, दुरुपयोग से सुरक्षित टूल्स का सेट ताकि एजेंट सत्रों की सूची बना सकें, इतिहास प्राप्त कर सकें, और किसी अन्य सत्र में संदेश भेज सकें।

## टूल नाम

- `sessions_list`
- `sessions_history`
- `sessions_send`
- `sessions_spawn`

## कुंजी मॉडल

- मुख्य प्रत्यक्ष चैट बकेट हमेशा शाब्दिक कुंजी `"main"` होती है (वर्तमान एजेंट की मुख्य कुंजी में रिज़ॉल्व होती है)।
- समूह चैट्स `agent:<agentId>:<channel>:group:<id>` या `agent:<agentId>:<channel>:channel:<id>` का उपयोग करते हैं (पूर्ण कुंजी पास करें)।
- क्रॉन जॉब्स `cron:<job.id>` का उपयोग करते हैं।
- हुक्स डिफ़ॉल्ट रूप से `hook:<uuid>` का उपयोग करते हैं, जब तक स्पष्ट रूप से सेट न किया जाए।
- नोड सत्र डिफ़ॉल्ट रूप से `node-<nodeId>` का उपयोग करते हैं, जब तक स्पष्ट रूप से सेट न किया जाए।

3. `global` और `unknown` आरक्षित मान हैं और कभी सूचीबद्ध नहीं किए जाते। 4. यदि `session.scope = "global"` है, तो हम इसे सभी टूल्स के लिए `main` का उपनाम देते हैं ताकि कॉल करने वालों को कभी `global` न दिखे।

## sessions_list

सत्रों को पंक्तियों की एक ऐरे के रूप में सूचीबद्ध करें।

Parameters:

- `kinds?: string[]` फ़िल्टर: `"main" | "group" | "cron" | "hook" | "node" | "other"` में से कोई
- `limit?: number` अधिकतम पंक्तियाँ (डिफ़ॉल्ट: सर्वर डिफ़ॉल्ट, क्लैम्प जैसे 200)
- `activeMinutes?: number` केवल वे सत्र जो पिछले N मिनटों में अपडेट हुए हों
- `messageLimit?: number` 0 = कोई संदेश नहीं (डिफ़ॉल्ट 0); >0 = अंतिम N संदेश शामिल करें

Behavior:

- `messageLimit > 0` प्रति सत्र `chat.history` फ़ेच करता है और अंतिम N संदेश शामिल करता है।
- सूची आउटपुट में टूल परिणाम फ़िल्टर कर दिए जाते हैं; टूल संदेशों के लिए `sessions_history` का उपयोग करें।
- **sandboxed** एजेंट सत्र में चलने पर, सत्र टूल्स डिफ़ॉल्ट रूप से **केवल‑स्पॉन की गई दृश्यता** पर सेट होते हैं (नीचे देखें)।

Row shape (JSON):

- `key`: सत्र कुंजी (string)
- `kind`: `main | group | cron | hook | node | other`
- `channel`: `whatsapp | telegram | discord | signal | imessage | webchat | internal | unknown`
- `displayName` (यदि उपलब्ध हो तो समूह प्रदर्शन लेबल)
- `updatedAt` (ms)
- `sessionId`
- `model`, `contextTokens`, `totalTokens`
- `thinkingLevel`, `verboseLevel`, `systemSent`, `abortedLastRun`
- `sendPolicy` (यदि सेट हो तो सत्र ओवरराइड)
- `lastChannel`, `lastTo`
- `deliveryContext` (उपलब्ध होने पर सामान्यीकृत `{ channel, to, accountId }`)
- `transcriptPath` (स्टोर डायरेक्टरी + sessionId से व्युत्पन्न सर्वोत्तम‑प्रयास पथ)
- `messages?` (केवल तब जब `messageLimit > 0`)

## sessions_history

एक सत्र के लिए ट्रांसक्रिप्ट प्राप्त करें।

Parameters:

- `sessionKey` (आवश्यक; सत्र कुंजी या `sessions_list` से `sessionId` स्वीकार करता है)
- `limit?: number` अधिकतम संदेश (सर्वर द्वारा क्लैम्प)
- `includeTools?: boolean` (डिफ़ॉल्ट false)

Behavior:

- `includeTools=false` `role: "toolResult"` संदेशों को फ़िल्टर करता है।
- कच्चे ट्रांसक्रिप्ट प्रारूप में संदेशों की ऐरे लौटाता है।
- `sessionId` दिए जाने पर, OpenClaw इसे संबंधित सत्र कुंजी में रिज़ॉल्व करता है (ग़ायब ids पर त्रुटि)।

## sessions_send

किसी अन्य सत्र में संदेश भेजें।

Parameters:

- `sessionKey` (आवश्यक; सत्र कुंजी या `sessions_list` से `sessionId` स्वीकार करता है)
- `message` (आवश्यक)
- `timeoutSeconds?: number` (डिफ़ॉल्ट >0; 0 = फ़ायर‑एंड‑फ़ॉरगेट)

Behavior:

- `timeoutSeconds = 0`: क्यू में डालता है और `{ runId, status: "accepted" }` लौटाता है।
- `timeoutSeconds > 0`: पूर्णता के लिए N सेकंड तक प्रतीक्षा करता है, फिर `{ runId, status: "ok", reply }` लौटाता है।
- 5. यदि प्रतीक्षा का समय समाप्त हो जाए: `{ runId, status: "timeout", error }`। 6. रन जारी रहता है; बाद में `sessions_history` कॉल करें।
- यदि रन विफल हो: `{ runId, status: "error", error }`।
- प्राथमिक रन पूर्ण होने के बाद डिलीवरी रन की घोषणा की जाती है और यह सर्वोत्तम‑प्रयास है; `status: "ok"` यह गारंटी नहीं देता कि घोषणा वितरित हुई।
- प्रतीक्षा Gateway `agent.wait` (सर्वर‑साइड) के माध्यम से होती है ताकि री‑कनेक्ट होने पर प्रतीक्षा न टूटे।
- प्राथमिक रन के लिए एजेंट‑टू‑एजेंट संदेश संदर्भ इंजेक्ट किया जाता है।
- प्राथमिक रन पूर्ण होने के बाद, OpenClaw एक **रिप्लाई‑बैक लूप** चलाता है:
  - राउंड 2+ अनुरोधकर्ता और लक्ष्य एजेंट के बीच बारी‑बारी से होते हैं।
  - पिंग‑पोंग रोकने के लिए ठीक `REPLY_SKIP` का उत्तर दें।
  - अधिकतम टर्न `session.agentToAgent.maxPingPongTurns` हैं (0–5, डिफ़ॉल्ट 5)।
- लूप समाप्त होने पर, OpenClaw **एजेंट‑टू‑एजेंट घोषणा चरण** चलाता है (केवल लक्ष्य एजेंट):
  - मौन रहने के लिए ठीक `ANNOUNCE_SKIP` का उत्तर दें।
  - कोई भी अन्य उत्तर लक्ष्य चैनल पर भेजा जाता है।
  - घोषणा चरण में मूल अनुरोध + राउंड‑1 उत्तर + नवीनतम पिंग‑पोंग उत्तर शामिल होते हैं।

## चैनल फ़ील्ड

- समूहों के लिए, `channel` वह चैनल है जो सत्र प्रविष्टि पर दर्ज होता है।
- प्रत्यक्ष चैट्स के लिए, `channel` `lastChannel` से मैप होता है।
- क्रॉन/हुक/नोड के लिए, `channel` `internal` होता है।
- यदि अनुपलब्ध हो, तो `channel` `unknown` होता है।

## सुरक्षा / भेजने की नीति

चैनल/चैट प्रकार के आधार पर नीति‑आधारित अवरोधन (प्रति सत्र id नहीं)।

```json
{
  "session": {
    "sendPolicy": {
      "rules": [
        {
          "match": { "channel": "discord", "chatType": "group" },
          "action": "deny"
        }
      ],
      "default": "allow"
    }
  }
}
```

रनटाइम ओवरराइड (प्रति सत्र प्रविष्टि):

- `sendPolicy: "allow" | "deny"` (unset = विन्यास विरासत में लें)
- `sessions.patch` या केवल‑मालिक `/send on|off|inherit` (स्टैंडअलोन संदेश) के माध्यम से सेट करने योग्य।

Enforcement points:

- `chat.send` / `agent` (Gateway)
- ऑटो‑रिप्लाई डिलीवरी लॉजिक

## sessions_spawn

एक अलग‑थलग सत्र में उप‑एजेंट रन स्पॉन करें और परिणाम को अनुरोधकर्ता चैट चैनल पर घोषित करें।

Parameters:

- `task` (आवश्यक)
- `label?` (वैकल्पिक; लॉग्स/UI के लिए उपयोग)
- `agentId?` (वैकल्पिक; यदि अनुमति हो तो किसी अन्य एजेंट id के अंतर्गत स्पॉन करें)
- `model?` (वैकल्पिक; उप‑एजेंट मॉडल को ओवरराइड करता है; अमान्य मानों पर त्रुटि)
- `runTimeoutSeconds?` (डिफ़ॉल्ट 0; सेट होने पर N सेकंड बाद उप‑एजेंट रन को रद्द करता है)
- `cleanup?` (`delete|keep`, डिफ़ॉल्ट `keep`)

Allowlist:

- 7. `agents.list[].subagents.allowAgents`: `agentId` के माध्यम से अनुमत एजेंट आईडी की सूची (`["*"]` किसी को भी अनुमति देने के लिए)। 8. डिफ़ॉल्ट: केवल अनुरोध करने वाला एजेंट।

Discovery:

- `agents_list` का उपयोग करें यह पता लगाने के लिए कि `sessions_spawn` के लिए कौन‑कौन से एजेंट ids अनुमत हैं।

Behavior:

- `deliver: false` के साथ एक नया `agent:<agentId>:subagent:<uuid>` सत्र शुरू करता है।
- उप‑एजेंट्स डिफ़ॉल्ट रूप से पूर्ण टूल सेट **माइनस सत्र टूल्स** के साथ आते हैं ( `tools.subagents.tools` के माध्यम से विन्यास योग्य)।
- उप‑एजेंट्स को `sessions_spawn` कॉल करने की अनुमति नहीं है (कोई उप‑एजेंट → उप‑एजेंट स्पॉनिंग नहीं)।
- हमेशा नॉन‑ब्लॉकिंग: तुरंत `{ status: "accepted", runId, childSessionKey }` लौटाता है।
- पूर्णता के बाद, OpenClaw एक उप‑एजेंट **घोषणा चरण** चलाता है और परिणाम को अनुरोधकर्ता चैट चैनल पर पोस्ट करता है।
- घोषणा चरण के दौरान मौन रहने के लिए ठीक `ANNOUNCE_SKIP` का उत्तर दें।
- घोषणा उत्तरों को `Status`/`Result`/`Notes` में सामान्यीकृत किया जाता है; `Status` रनटाइम परिणाम से आता है (मॉडल पाठ से नहीं)।
- उप‑एजेंट सत्र `agents.defaults.subagents.archiveAfterMinutes` के बाद स्वतः आर्काइव हो जाते हैं (डिफ़ॉल्ट: 60)।
- घोषणा उत्तरों में एक आँकड़े पंक्ति शामिल होती है (रनटाइम, टोकन्स, sessionKey/sessionId, ट्रांसक्रिप्ट पथ, और वैकल्पिक लागत)।

## Sandbox सत्र दृश्यता

Sandboxed सत्र सत्र टूल्स का उपयोग कर सकते हैं, लेकिन डिफ़ॉल्ट रूप से वे केवल वे सत्र देखते हैं जिन्हें उन्होंने `sessions_spawn` के माध्यम से स्पॉन किया है।

Config:

```json5
{
  agents: {
    defaults: {
      sandbox: {
        // default: "spawned"
        sessionToolsVisibility: "spawned", // or "all"
      },
    },
  },
}
```
