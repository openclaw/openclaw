---
summary: "चैट्स के लिए सत्र प्रबंधन के नियम, कुंजियाँ और स्थायित्व"
read_when:
  - सत्र हैंडलिंग या स्टोरेज में संशोधन करते समय
title: "सत्र प्रबंधन"
---

# सत्र प्रबंधन

9. OpenClaw **प्रति एजेंट एक डायरेक्ट-चैट सत्र** को प्राथमिक मानता है। 10. डायरेक्ट चैट्स `agent:<agentId>:<mainKey>` (डिफ़ॉल्ट `main`) में समाहित हो जाती हैं, जबकि समूह/चैनल चैट्स को अपनी अलग कुंजियाँ मिलती हैं। 11. `session.mainKey` का सम्मान किया जाता है।

**डायरेक्ट संदेशों** को कैसे समूहित किया जाए, इसे नियंत्रित करने के लिए `session.dmScope` का उपयोग करें:

- `main` (डिफ़ॉल्ट): निरंतरता के लिए सभी DMs मुख्य सत्र साझा करते हैं।
- `per-peer`: चैनलों के पार प्रेषक id के आधार पर अलगाव।
- `per-channel-peer`: चैनल + प्रेषक के आधार पर अलगाव (मल्टी-यूज़र इनबॉक्स के लिए अनुशंसित)।
- 12. `per-account-channel-peer`: खाते + चैनल + प्रेषक के आधार पर अलगाव (मल्टी-अकाउंट इनबॉक्स के लिए अनुशंसित)।
  13. `session.identityLinks` का उपयोग करें ताकि प्रदाता-प्रिफ़िक्स वाले पीयर आईडी को एक कैनॉनिकल पहचान से मैप किया जा सके, जिससे `per-peer`, `per-channel-peer`, या `per-account-channel-peer` का उपयोग करते समय एक ही व्यक्ति विभिन्न चैनलों में एक ही DM सत्र साझा करे।

## Secure DM मोड (मल्टी-यूज़र सेटअप्स के लिए अनुशंसित)

> 14. **सुरक्षा चेतावनी:** यदि आपका एजेंट **कई लोगों** से DM प्राप्त कर सकता है, तो आपको सुरक्षित DM मोड सक्षम करने पर गंभीरता से विचार करना चाहिए। 15. इसके बिना, सभी उपयोगकर्ता एक ही वार्तालाप संदर्भ साझा करते हैं, जिससे उपयोगकर्ताओं के बीच निजी जानकारी लीक हो सकती है।

**डिफ़ॉल्ट सेटिंग्स के साथ समस्या का उदाहरण:**

- Alice (`<SENDER_A>`) आपके एजेंट को किसी निजी विषय पर संदेश भेजती है (उदाहरण के लिए, चिकित्सा अपॉइंटमेंट)
- Bob (`<SENDER_B>`) आपके एजेंट को संदेश भेजता है और पूछता है, "हम किस बारे में बात कर रहे थे?"
- क्योंकि दोनों DMs एक ही सत्र साझा करते हैं, मॉडल Alice के पूर्व संदर्भ का उपयोग करते हुए Bob को उत्तर दे सकता है।

**समाधान:** प्रति उपयोगकर्ता सत्र अलग करने के लिए `dmScope` सेट करें:

```json5
// ~/.openclaw/openclaw.json
{
  session: {
    // Secure DM mode: isolate DM context per channel + sender.
    dmScope: "per-channel-peer",
  },
}
```

**इसे कब सक्षम करें:**

- आपके पास एक से अधिक प्रेषकों के लिए पेयरिंग अनुमोदन हैं
- आप कई प्रविष्टियों के साथ DM allowlist का उपयोग करते हैं
- आप `dmPolicy: "open"` सेट करते हैं
- कई फ़ोन नंबर या खाते आपके एजेंट को संदेश भेज सकते हैं

नोट्स:

- 16. निरंतरता के लिए डिफ़ॉल्ट `dmScope: "main"` है (सभी DMs मुख्य सत्र साझा करते हैं)। 17. यह सिंगल-यूज़र सेटअप के लिए ठीक है।
- एक ही चैनल पर मल्टी-अकाउंट इनबॉक्स के लिए, `per-account-channel-peer` को प्राथमिकता दें।
- यदि वही व्यक्ति आपको कई चैनलों पर संपर्क करता है, तो उनकी DM सत्रों को एक कैनॉनिकल पहचान में समाहित करने के लिए `session.identityLinks` का उपयोग करें।
- आप अपनी DM सेटिंग्स को `openclaw security audit` से सत्यापित कर सकते हैं (देखें [security](/cli/security))।

## Gateway सत्य का स्रोत है

18. सभी सत्र स्थिति **गेटवे** ("मास्टर" OpenClaw) के स्वामित्व में होती है। 19. UI क्लाइंट्स (macOS ऐप, WebChat, आदि) 20. को स्थानीय फ़ाइलें पढ़ने के बजाय सत्र सूचियों और टोकन गणनाओं के लिए गेटवे से क्वेरी करनी चाहिए।

- **रिमोट मोड** में, जिस सत्र स्टोर की आपको परवाह है वह आपके Mac पर नहीं, बल्कि रिमोट Gateway होस्ट पर रहता है।
- 21. UI में दिखाए गए टोकन काउंट गेटवे के स्टोर फ़ील्ड्स (`inputTokens`, `outputTokens`, `totalTokens`, `contextTokens`) से आते हैं। 22. क्लाइंट्स कुल योग को “ठीक करने” के लिए JSONL ट्रांसक्रिप्ट्स को पार्स नहीं करते।

## स्थिति कहाँ रहती है

- **Gateway होस्ट** पर:
  - स्टोर फ़ाइल: `~/.openclaw/agents/<agentId>/sessions/sessions.json` (प्रति एजेंट)।
- ट्रांसक्रिप्ट्स: `~/.openclaw/agents/<agentId>/sessions/<SessionId>.jsonl` (Telegram टॉपिक सत्र `.../<SessionId>-topic-<threadId>.jsonl` का उपयोग करते हैं)।
- 23. स्टोर एक मैप है `sessionKey -> { sessionId, updatedAt, ... 24. }`। 25. प्रविष्टियाँ हटाना सुरक्षित है; आवश्यकता होने पर वे फिर से बनाई जाती हैं।
- समूह प्रविष्टियों में UI में सत्रों को लेबल करने के लिए `displayName`, `channel`, `subject`, `room`, और `space` शामिल हो सकते हैं।
- सत्र प्रविष्टियों में `origin` मेटाडेटा (लेबल + रूटिंग संकेत) शामिल होता है ताकि UI समझा सके कि सत्र कहाँ से आया।
- OpenClaw **लीगेसी Pi/Tau सत्र फ़ोल्डर्स** को नहीं पढ़ता।

## सत्र प्रूनिंग

26. OpenClaw डिफ़ॉल्ट रूप से LLM कॉल से ठीक पहले इन-मेमोरी संदर्भ से **पुराने टूल परिणाम** ट्रिम करता है।
27. यह JSONL इतिहास को **पुनर्लेखित नहीं** करता। 28. देखें [/concepts/session-pruning](/concepts/session-pruning)।

## प्री-कम्पैक्शन मेमोरी फ़्लश

29. जब कोई सत्र ऑटो-कॉम्पैक्शन के करीब होता है, तो OpenClaw एक **साइलेंट मेमोरी फ़्लश** चला सकता है
    जो मॉडल को टिकाऊ नोट्स डिस्क पर लिखने की याद दिलाता है। 30. यह केवल तब चलता है जब
    वर्कस्पेस लिखने योग्य हो। 31. देखें [Memory](/concepts/memory) और
    [Compaction](/concepts/compaction)।

## ट्रांसपोर्ट्स → सत्र कुंजियों का मैपिंग

- डायरेक्ट चैट्स `session.dmScope` का अनुसरण करती हैं (डिफ़ॉल्ट `main`)।
  - `main`: `agent:<agentId>:<mainKey>` (डिवाइस/चैनलों के पार निरंतरता)।
    - कई फ़ोन नंबर और चैनल एक ही एजेंट मुख्य कुंजी से मैप हो सकते हैं; वे एक बातचीत में ट्रांसपोर्ट्स की तरह कार्य करते हैं।
  - `per-peer`: `agent:<agentId>:dm:<peerId>`।
  - `per-channel-peer`: `agent:<agentId>:<channel>:dm:<peerId>`।
  - `per-account-channel-peer`: `agent:<agentId>:<channel>:<accountId>:dm:<peerId>` (accountId का डिफ़ॉल्ट `default` है)।
  - यदि `session.identityLinks` किसी प्रदाता-प्रिफ़िक्स्ड peer id (उदाहरण के लिए `telegram:123`) से मेल खाता है, तो कैनॉनिकल कुंजी `<peerId>` को प्रतिस्थापित कर देती है, ताकि वही व्यक्ति चैनलों के पार एक ही सत्र साझा करे।
- समूह चैट्स स्थिति को अलग करती हैं: `agent:<agentId>:<channel>:group:<id>` (रूम्स/चैनल्स `agent:<agentId>:<channel>:channel:<id>` का उपयोग करते हैं)।
  - Telegram फ़ोरम टॉपिक्स अलगाव के लिए समूह id में `:topic:<threadId>` जोड़ते हैं।
  - माइग्रेशन के लिए लीगेसी `group:<id>` कुंजियाँ अभी भी पहचानी जाती हैं।
- इनबाउंड संदर्भ अभी भी `group:<id>` का उपयोग कर सकते हैं; चैनल `Provider` से अनुमानित होता है और कैनॉनिकल `agent:<agentId>:<channel>:group:<id>` रूप में सामान्यीकृत किया जाता है।
- अन्य स्रोत:
  - Cron जॉब्स: `cron:<job.id>`
  - Webhooks: `hook:<uuid>` (जब तक हुक द्वारा स्पष्ट रूप से सेट न किया गया हो)
  - Node रन: `node-<nodeId>`

## जीवनचक्र

- रीसेट नीति: सत्रों का पुनः उपयोग तब तक किया जाता है जब तक वे समाप्त न हो जाएँ, और समाप्ति का मूल्यांकन अगले इनबाउंड संदेश पर किया जाता है।
- 32. दैनिक रीसेट: डिफ़ॉल्ट रूप से **गेटवे होस्ट के स्थानीय समय अनुसार सुबह 4:00 बजे**। 33. किसी सत्र को तब स्टेल माना जाता है जब उसका अंतिम अपडेट सबसे हालिया दैनिक रीसेट समय से पहले का हो।
- 34. आइडल रीसेट (वैकल्पिक): `idleMinutes` एक स्लाइडिंग आइडल विंडो जोड़ता है। 35. जब दैनिक और आइडल दोनों रीसेट कॉन्फ़िगर हों, तो **जो भी पहले समाप्त होता है** वह नया सत्र मजबूर करता है।
- लीगेसी केवल-आइडल: यदि आप किसी भी `session.reset`/`resetByType` कॉन्फ़िग के बिना `session.idleMinutes` सेट करते हैं, तो बैकवर्ड कम्पैटिबिलिटी के लिए OpenClaw केवल-आइडल मोड में रहता है।
- प्रति-प्रकार ओवरराइड्स (वैकल्पिक): `resetByType` आपको `dm`, `group`, और `thread` सत्रों के लिए नीति ओवरराइड करने देता है (thread = Slack/Discord थ्रेड्स, Telegram टॉपिक्स, Matrix थ्रेड्स जब कनेक्टर द्वारा प्रदान किए गए हों)।
- प्रति-चैनल ओवरराइड्स (वैकल्पिक): `resetByChannel` किसी चैनल के लिए रीसेट नीति को ओवरराइड करता है (उस चैनल के सभी सत्र प्रकारों पर लागू होता है और `reset`/`resetByType` पर प्राथमिकता लेता है)।
- 36. रीसेट ट्रिगर्स: सटीक `/new` या `/reset` (साथ ही `resetTriggers` में कोई भी अतिरिक्त) एक नया सत्र आईडी शुरू करते हैं और संदेश के शेष भाग को आगे पास करते हैं। 37. `/new <model>` एक मॉडल एलियास, `provider/model`, या प्रदाता नाम (फज़ी मैच) स्वीकार करता है ताकि नए सत्र का मॉडल सेट किया जा सके। 38. यदि `/new` या `/reset` अकेले भेजा जाता है, तो OpenClaw रीसेट की पुष्टि के लिए एक छोटा “हैलो” अभिवादन टर्न चलाता है।
- मैनुअल रीसेट: स्टोर से विशिष्ट कुंजियाँ हटाएँ या JSONL ट्रांसक्रिप्ट हटाएँ; अगला संदेश उन्हें पुनः बनाएगा।
- पृथक Cron जॉब्स हर रन पर हमेशा एक नया `sessionId` जारी करते हैं (कोई आइडल पुनः उपयोग नहीं)।

## भेजने की नीति (वैकल्पिक)

व्यक्तिगत ids सूचीबद्ध किए बिना विशिष्ट सत्र प्रकारों के लिए डिलीवरी ब्लॉक करें।

```json5
{
  session: {
    sendPolicy: {
      rules: [
        { action: "deny", match: { channel: "discord", chatType: "group" } },
        { action: "deny", match: { keyPrefix: "cron:" } },
      ],
      default: "allow",
    },
  },
}
```

रनटाइम ओवरराइड (केवल मालिक):

- `/send on` → इस सत्र के लिए अनुमति दें
- `/send off` → इस सत्र के लिए अस्वीकार करें
- `/send inherit` → ओवरराइड साफ़ करें और कॉन्फ़िग नियमों का उपयोग करें
  इन्हें स्टैंडअलोन संदेशों के रूप में भेजें ताकि वे पंजीकृत हों।

## विन्यास (वैकल्पिक नाम बदलने का उदाहरण)

```json5
// ~/.openclaw/openclaw.json
{
  session: {
    scope: "per-sender", // keep group keys separate
    dmScope: "main", // DM continuity (set per-channel-peer/per-account-channel-peer for shared inboxes)
    identityLinks: {
      alice: ["telegram:123456789", "discord:987654321012345678"],
    },
    reset: {
      // Defaults: mode=daily, atHour=4 (gateway host local time).
      // If you also set idleMinutes, whichever expires first wins.
      mode: "daily",
      atHour: 4,
      idleMinutes: 120,
    },
    resetByType: {
      thread: { mode: "daily", atHour: 4 },
      dm: { mode: "idle", idleMinutes: 240 },
      group: { mode: "idle", idleMinutes: 120 },
    },
    resetByChannel: {
      discord: { mode: "idle", idleMinutes: 10080 },
    },
    resetTriggers: ["/new", "/reset"],
    store: "~/.openclaw/agents/{agentId}/sessions/sessions.json",
    mainKey: "main",
  },
}
```

## निरीक्षण

- `openclaw status` — स्टोर पथ और हाल के सत्र दिखाता है।
- `openclaw sessions --json` — हर प्रविष्टि डंप करता है ( `--active <minutes>` के साथ फ़िल्टर करें)।
- `openclaw gateway call sessions.list --params '{}'` — चल रहे Gateway से सत्र प्राप्त करता है (रिमोट Gateway एक्सेस के लिए `--url`/`--token` का उपयोग करें)।
- चैट में `/status` को स्टैंडअलोन संदेश के रूप में भेजें ताकि पता चले कि एजेंट पहुँच योग्य है या नहीं, सत्र संदर्भ का कितना उपयोग हो रहा है, वर्तमान thinking/verbose टॉगल्स, और आपके WhatsApp वेब क्रेड्स आख़िरी बार कब रिफ़्रेश हुए थे (रीलिंक की ज़रूरत पहचानने में मदद करता है)।
- सिस्टम प्रॉम्प्ट और इंजेक्टेड वर्कस्पेस फ़ाइलों (और सबसे बड़े संदर्भ योगदानकर्ताओं) को देखने के लिए `/context list` या `/context detail` भेजें।
- मौजूदा रन को रोकने, उस सत्र के लिए कतारबद्ध फ़ॉलोअप्स साफ़ करने, और उससे स्पॉन हुए किसी भी सब-एजेंट रन को रोकने के लिए `/stop` को स्टैंडअलोन संदेश के रूप में भेजें (उत्तर में रुके हुए काउंट शामिल होते हैं)।
- 39. पुराने संदर्भ को सारांशित करने और विंडो स्पेस खाली करने के लिए एक स्टैंडअलोन संदेश के रूप में `/compact` (वैकल्पिक निर्देशों सहित) भेजें। 40. देखें [/concepts/compaction](/concepts/compaction)।
- पूर्ण टर्न्स की समीक्षा के लिए JSONL ट्रांसक्रिप्ट्स सीधे खोली जा सकती हैं।

## सुझाव

- प्राथमिक कुंजी को 1:1 ट्रैफ़िक के लिए समर्पित रखें; समूहों को अपनी कुंजियाँ रखने दें।
- क्लीनअप को स्वचालित करते समय, पूरे स्टोर को हटाने के बजाय व्यक्तिगत कुंजियाँ हटाएँ ताकि अन्यत्र संदर्भ सुरक्षित रहे।

## सत्र उत्पत्ति मेटाडेटा

प्रत्येक सत्र प्रविष्टि यह रिकॉर्ड करती है कि वह कहाँ से आई (सर्वोत्तम प्रयास) `origin` में:

- `label`: मानव-पठनीय लेबल (बातचीत लेबल + समूह विषय/चैनल से हल किया गया)
- `provider`: सामान्यीकृत चैनल id (एक्सटेंशन्स सहित)
- `from`/`to`: इनबाउंड एनवेलप से कच्चे रूटिंग ids
- `accountId`: प्रदाता खाता id (जब मल्टी-अकाउंट)
- 41. `threadId`: जब चैनल इसका समर्थन करता है तब थ्रेड/टॉपिक आईडी
      डायरेक्ट मैसेज, चैनल और समूहों के लिए origin फ़ील्ड्स भरे जाते हैं। 42. यदि कोई
      कनेक्टर केवल डिलीवरी रूटिंग अपडेट करता है (उदाहरण के लिए, DM मुख्य सत्र को
      ताज़ा रखने के लिए), तो उसे फिर भी इनबाउंड संदर्भ प्रदान करना चाहिए ताकि सत्र
      अपना एक्सप्लेनर मेटाडेटा बनाए रखे। 43. एक्सटेंशन्स यह `ConversationLabel`,
      `GroupSubject`, `GroupChannel`, `GroupSpace`, और `SenderName` को इनबाउंड
      संदर्भ में भेजकर और `recordSessionMetaFromInbound` कॉल करके (या वही संदर्भ
      `updateLastRoute` को पास करके) कर सकती हैं।
