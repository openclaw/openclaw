---
summary: "स्ट्रीमिंग + चंकिंग व्यवहार (ब्लॉक उत्तर, ड्राफ्ट स्ट्रीमिंग, सीमाएँ)"
read_when:
  - चैनलों पर स्ट्रीमिंग या चंकिंग कैसे काम करती है, यह समझाते समय
  - ब्लॉक स्ट्रीमिंग या चैनल चंकिंग व्यवहार बदलते समय
  - डुप्लिकेट/शीघ्र ब्लॉक उत्तर या ड्राफ्ट स्ट्रीमिंग का डिबग करते समय
title: "स्ट्रीमिंग और चंकिंग"
---

# स्ट्रीमिंग + चंकिंग

OpenClaw में दो अलग-अलग “स्ट्रीमिंग” परतें हैं:

- 44. **ब्लॉक स्ट्रीमिंग (चैनल):** सहायक के लिखते समय पूर्ण **ब्लॉक्स** उत्सर्जित करें। 45. ये सामान्य चैनल संदेश होते हैं (टोकन डेल्टा नहीं)।
- **टोकन-जैसी स्ट्रीमिंग (केवल Telegram):** जेनरेशन के दौरान आंशिक पाठ के साथ एक **ड्राफ्ट बबल** अपडेट करता है; अंतिम संदेश अंत में भेजा जाता है।

46. आज बाहरी चैनल संदेशों के लिए **कोई वास्तविक टोकन स्ट्रीमिंग** नहीं है। 47. Telegram ड्राफ़्ट स्ट्रीमिंग ही एकमात्र आंशिक-स्ट्रीम सतह है।

## ब्लॉक स्ट्रीमिंग (चैनल संदेश)

ब्लॉक स्ट्रीमिंग सहायक आउटपुट को मोटे चंक्स में, उपलब्ध होते ही भेजती है।

```
Model output
  └─ text_delta/events
       ├─ (blockStreamingBreak=text_end)
       │    └─ chunker emits blocks as buffer grows
       └─ (blockStreamingBreak=message_end)
            └─ chunker flushes at message_end
                   └─ channel send (block replies)
```

Legend:

- `text_delta/events`: मॉडल स्ट्रीम इवेंट्स (नॉन-स्ट्रीमिंग मॉडलों के लिए विरल हो सकते हैं)।
- `chunker`: `EmbeddedBlockChunker` न्यूनतम/अधिकतम सीमाएँ + ब्रेक प्राथमिकता लागू करता है।
- `channel send`: वास्तविक आउटबाउंड संदेश (ब्लॉक उत्तर)।

**नियंत्रण:**

- `agents.defaults.blockStreamingDefault`: `"on"`/`"off"` (डिफ़ॉल्ट बंद)।
- चैनल ओवरराइड्स: `*.blockStreaming` (और प्रति-खाता वैरिएंट्स) ताकि प्रति चैनल `"on"`/`"off"` को बाध्य किया जा सके।
- `agents.defaults.blockStreamingBreak`: `"text_end"` या `"message_end"`।
- 48. `agents.defaults.blockStreamingChunk`: `{ minChars, maxChars, breakPreference?` 49. }\`।
- 50. `agents.defaults.blockStreamingCoalesce`: `{ minChars?, maxChars?, idleMs?` }\` (भेजने से पहले स्ट्रीम किए गए ब्लॉक्स को मर्ज करें)।
- चैनल हार्ड कैप: `*.textChunkLimit` (उदा., `channels.whatsapp.textChunkLimit`)।
- चैनल चंक मोड: `*.chunkMode` (`length` डिफ़ॉल्ट, `newline` लंबाई-आधारित चंकिंग से पहले खाली पंक्तियों (अनुच्छेद सीमाओं) पर विभाजन करता है)।
- Discord सॉफ्ट कैप: `channels.discord.maxLinesPerMessage` (डिफ़ॉल्ट 17) UI क्लिपिंग से बचने के लिए लंबे उत्तरों को विभाजित करता है।

**सीमा (Boundary) सेमांटिक्स:**

- `text_end`: जैसे ही चंकर उत्सर्जित करे, ब्लॉक्स स्ट्रीम करें; प्रत्येक `text_end` पर फ्लश करें।
- `message_end`: सहायक संदेश पूरा होने तक प्रतीक्षा करें, फिर बफ़र किया हुआ आउटपुट फ्लश करें।

`message_end` तब भी चंकर का उपयोग करता है यदि बफ़र किया गया पाठ `maxChars` से अधिक हो, इसलिए अंत में यह कई चंक्स उत्सर्जित कर सकता है।

## चंकिंग एल्गोरिद्म (न्यून/उच्च सीमाएँ)

ब्लॉक चंकिंग `EmbeddedBlockChunker` द्वारा लागू की जाती है:

- **न्यून सीमा:** बफ़र >= `minChars` होने तक उत्सर्जित न करें (जब तक बाध्य न किया जाए)।
- **उच्च सीमा:** `maxChars` से पहले विभाजन को प्राथमिकता दें; यदि बाध्य हो, तो `maxChars` पर विभाजित करें।
- **ब्रेक प्राथमिकता:** `paragraph` → `newline` → `sentence` → `whitespace` → हार्ड ब्रेक।
- **कोड फ़ेंस:** फ़ेंस के भीतर कभी विभाजन न करें; यदि `maxChars` पर बाध्य हो, तो Markdown को वैध रखने के लिए फ़ेंस को बंद + पुनः खोलें।

`maxChars` चैनल `textChunkLimit` पर क्लैम्प किया जाता है, इसलिए आप प्रति-चैनल कैप से अधिक नहीं जा सकते।

## कोएलसिंग (स्ट्रीम किए गए ब्लॉक्स को मर्ज करना)

जब ब्लॉक स्ट्रीमिंग सक्षम होती है, OpenClaw भेजने से पहले **लगातार आने वाले ब्लॉक चंक्स को मर्ज** कर सकता है। इससे “सिंगल-लाइन स्पैम” कम होता है, जबकि प्रोग्रेसिव आउटपुट बना रहता है।

- कोएलसिंग **आइडल गैप्स** (`idleMs`) का इंतज़ार करती है, फिर फ्लश करती है।
- बफ़र्स `maxChars` द्वारा सीमित होते हैं और उससे अधिक होने पर फ्लश हो जाते हैं।
- `minChars` पर्याप्त पाठ जमा होने तक छोटे टुकड़ों को भेजने से रोकता है
  (अंतिम फ्लश हमेशा शेष पाठ भेजता है)।
- जॉइनर `blockStreamingChunk.breakPreference` से व्युत्पन्न होता है
  (`paragraph` → `\n\n`, `newline` → `\n`, `sentence` → स्पेस)।
- चैनल ओवरराइड्स `*.blockStreamingCoalesce` के माध्यम से उपलब्ध हैं (प्रति-खाता विन्यास सहित)।
- डिफ़ॉल्ट कोएलस `minChars` को Signal/Slack/Discord के लिए 1500 तक बढ़ाया जाता है, जब तक ओवरराइड न किया जाए।

## ब्लॉक्स के बीच मानव-जैसी गति

जब ब्लॉक स्ट्रीमिंग सक्षम हो, तो आप ब्लॉक रिप्लाईज़ के बीच **रैंडमाइज़्ड पॉज़** जोड़ सकते हैं (पहले ब्लॉक के बाद)। इससे मल्टी-बबल प्रतिक्रियाएँ अधिक स्वाभाविक लगती हैं।

- विन्यास: `agents.defaults.humanDelay` (एजेंट-प्रति ओवरराइड `agents.list[].humanDelay` के माध्यम से)।
- मोड्स: `off` (डिफ़ॉल्ट), `natural` (800–2500ms), `custom` (`minMs`/`maxMs`)।
- केवल **ब्लॉक उत्तरों** पर लागू; अंतिम उत्तरों या टूल सारांशों पर नहीं।

## “चंक्स स्ट्रीम करें या सब कुछ”

यह निम्न से मैप होता है:

- **स्ट्रीम चंक्स:** `blockStreamingDefault: "on"` + `blockStreamingBreak: "text_end"` (जैसे-जैसे हो, वैसे emit करें)। नॉन-टेलीग्राम चैनलों को भी `*.blockStreaming: true` की आवश्यकता होती है।
- **अंत में सब कुछ स्ट्रीम करें:** `blockStreamingBreak: "message_end"` (एक बार फ्लश; बहुत लंबा होने पर संभवतः कई चंक्स)।
- **ब्लॉक स्ट्रीमिंग नहीं:** `blockStreamingDefault: "off"` (केवल अंतिम उत्तर)।

**चैनल नोट:** नॉन-टेलीग्राम चैनलों के लिए, ब्लॉक स्ट्रीमिंग **डिफ़ॉल्ट रूप से बंद** रहती है जब तक `*.blockStreaming` को स्पष्ट रूप से `true` न किया जाए। Telegram ड्राफ्ट्स को (`channels.telegram.streamMode`) बिना ब्लॉक रिप्लाईज़ के स्ट्रीम कर सकता है।

विन्यास स्थान स्मरण: `blockStreaming*` के डिफ़ॉल्ट्स
`agents.defaults` के अंतर्गत रहते हैं, रूट विन्यास में नहीं।

## Telegram ड्राफ्ट स्ट्रीमिंग (टोकन-जैसी)

Telegram ही एकमात्र चैनल है जिसमें ड्राफ्ट स्ट्रीमिंग है:

- **टॉपिक्स वाले निजी चैट्स** में Bot API `sendMessageDraft` का उपयोग करता है।
- `channels.telegram.streamMode: "partial" | "block" | "off"`।
  - `partial`: नवीनतम स्ट्रीम पाठ के साथ ड्राफ्ट अपडेट्स।
  - `block`: चंक किए गए ब्लॉक्स में ड्राफ्ट अपडेट्स (उसी चंकर नियमों के साथ)।
  - `off`: ड्राफ्ट स्ट्रीमिंग नहीं।
- ड्राफ्ट चंक विन्यास (केवल `streamMode: "block"` के लिए): `channels.telegram.draftChunk` (डिफ़ॉल्ट्स: `minChars: 200`, `maxChars: 800`)।
- ड्राफ्ट स्ट्रीमिंग ब्लॉक स्ट्रीमिंग से अलग है; ब्लॉक उत्तर डिफ़ॉल्ट रूप से बंद रहते हैं और केवल नॉन-Telegram चैनलों पर `*.blockStreaming: true` द्वारा सक्षम होते हैं।
- अंतिम उत्तर फिर भी एक सामान्य संदेश होता है।
- `/reasoning stream` तर्क (reasoning) को ड्राफ्ट बबल में लिखता है (केवल Telegram)।

जब ड्राफ्ट स्ट्रीमिंग सक्रिय होती है, OpenClaw डबल-स्ट्रीमिंग से बचने के लिए उस उत्तर के लिए ब्लॉक स्ट्रीमिंग को अक्षम कर देता है।

```
Telegram (private + topics)
  └─ sendMessageDraft (draft bubble)
       ├─ streamMode=partial → update latest text
       └─ streamMode=block   → chunker updates draft
  └─ final reply → normal message
```

Legend:

- `sendMessageDraft`: Telegram ड्राफ्ट बबल (वास्तविक संदेश नहीं)।
- `final reply`: सामान्य Telegram संदेश भेजना।
