---
summary: "एजेंट लूप जीवनचक्र, स्ट्रीम्स, और प्रतीक्षा अर्थविज्ञान"
read_when:
  - आपको एजेंट लूप या जीवनचक्र घटनाओं का सटीक चरण-दर-चरण विवरण चाहिए
title: "एजेंट लूप"
---

# एजेंट लूप (OpenClaw)

23. एजेंटिक लूप एजेंट का पूरा “वास्तविक” रन है: intake → context assembly → model inference → tool execution → streaming replies → persistence। 24. यह वह प्रामाणिक पथ है जो किसी संदेश को कार्रवाइयों और अंतिम उत्तर में बदलता है, साथ ही सेशन स्टेट को सुसंगत रखता है।

25. OpenClaw में, लूप प्रति सेशन एक एकल, क्रमबद्ध रन होता है जो मॉडल के सोचने, टूल्स कॉल करने और आउटपुट स्ट्रीम करने के दौरान lifecycle और stream इवेंट्स उत्सर्जित करता है। 26. यह दस्तावेज़ बताता है कि वह प्रामाणिक लूप एंड-टू-एंड कैसे जुड़ा हुआ है।

## प्रवेश बिंदु

- Gateway RPC: `agent` और `agent.wait`।
- CLI: `agent` कमांड।

## यह कैसे काम करता है (उच्च-स्तरीय)

1. `agent` RPC पैरामीटर मान्य करता है, सत्र (sessionKey/sessionId) को सुलझाता है, सत्र मेटाडेटा को स्थायी करता है, और तुरंत `{ runId, acceptedAt }` लौटाता है।
2. `agentCommand` एजेंट चलाता है:
   - मॉडल + thinking/verbose डिफ़ॉल्ट्स को सुलझाता है
   - Skills स्नैपशॉट लोड करता है
   - `runEmbeddedPiAgent` (pi-agent-core runtime) को कॉल करता है
   - यदि एम्बेडेड लूप कोई **lifecycle end/error** उत्सर्जित नहीं करता, तो **lifecycle end/error** उत्सर्जित करता है
3. `runEmbeddedPiAgent`:
   - प्रति-सत्र + वैश्विक कतारों के माध्यम से रन को क्रमबद्ध करता है
   - मॉडल + auth प्रोफ़ाइल सुलझाता है और pi सत्र बनाता है
   - pi घटनाओं की सदस्यता लेता है और assistant/tool डेल्टाज़ स्ट्रीम करता है
   - टाइमआउट लागू करता है -> पार होने पर रन को abort करता है
   - payloads + उपयोग मेटाडेटा लौटाता है
4. `subscribeEmbeddedPiSession` pi-agent-core घटनाओं को OpenClaw `agent` स्ट्रीम से जोड़ता है:
   - टूल घटनाएँ => `stream: "tool"`
   - assistant डेल्टाज़ => `stream: "assistant"`
   - lifecycle घटनाएँ => `stream: "lifecycle"` (`phase: "start" | "end" | "error"`)
5. `agent.wait` `waitForAgentJob` का उपयोग करता है:
   - `runId` के लिए **lifecycle end/error** की प्रतीक्षा करता है
   - 27. returns `{ status: ok|error|timeout, startedAt, endedAt, error?` 28. `}`

## कतारबद्धता + समांतरता

- रन प्रति सत्र कुंजी (session lane) और वैकल्पिक रूप से एक वैश्विक लेन के माध्यम से क्रमबद्ध होते हैं।
- यह टूल/सत्र रेस को रोकता है और सत्र इतिहास को सुसंगत रखता है।
- 29. मैसेजिंग चैनल इस लेन सिस्टम को फ़ीड करने वाले queue modes (collect/steer/followup) चुन सकते हैं।
  30. देखें [Command Queue](/concepts/queue)।

## सत्र + कार्यक्षेत्र तैयारी

- कार्यक्षेत्र को सुलझाया और बनाया जाता है; सैंडबॉक्स में चलने वाले रन किसी sandbox कार्यक्षेत्र रूट पर रीडायरेक्ट हो सकते हैं।
- Skills लोड की जाती हैं (या स्नैपशॉट से पुन: उपयोग होती हैं) और env तथा prompt में इंजेक्ट की जाती हैं।
- Bootstrap/संदर्भ फ़ाइलें सुलझाई जाती हैं और system prompt रिपोर्ट में इंजेक्ट की जाती हैं।
- एक सत्र write लॉक प्राप्त किया जाता है; `SessionManager` स्ट्रीमिंग से पहले खोली और तैयार की जाती है।

## प्रॉम्प्ट संयोजन + सिस्टम प्रॉम्प्ट

- सिस्टम प्रॉम्प्ट OpenClaw के बेस प्रॉम्प्ट, skills प्रॉम्प्ट, bootstrap संदर्भ, और प्रति-रन ओवरराइड्स से बनाया जाता है।
- मॉडल-विशिष्ट सीमाएँ और compaction reserve टोकन लागू किए जाते हैं।
- मॉडल क्या देखता है, इसके लिए [System prompt](/concepts/system-prompt) देखें।

## हुक पॉइंट्स (जहाँ आप इंटरसेप्ट कर सकते हैं)

OpenClaw में दो हुक सिस्टम हैं:

- **आंतरिक हुक्स** (Gateway hooks): कमांड और जीवनचक्र घटनाओं के लिए इवेंट-ड्रिवन स्क्रिप्ट्स।
- **प्लगइन हुक्स**: एजेंट/टूल जीवनचक्र और gateway पाइपलाइन के भीतर विस्तार बिंदु।

### आंतरिक हुक्स (Gateway hooks)

- 31. **`agent:bootstrap`**: सिस्टम प्रॉम्प्ट को अंतिम रूप देने से पहले bootstrap फ़ाइलें बनाते समय चलता है।
  32. इसका उपयोग bootstrap context फ़ाइलें जोड़ने/हटाने के लिए करें।
- **कमांड हुक्स**: `/new`, `/reset`, `/stop`, और अन्य कमांड घटनाएँ (Hooks दस्तावेज़ देखें)।

सेटअप और उदाहरणों के लिए [Hooks](/automation/hooks) देखें।

### प्लगइन हुक्स (एजेंट + gateway जीवनचक्र)

ये एजेंट लूप या gateway पाइपलाइन के भीतर चलते हैं:

- **`before_agent_start`**: रन शुरू होने से पहले संदर्भ इंजेक्ट करें या सिस्टम प्रॉम्प्ट ओवरराइड करें।
- **`agent_end`**: पूर्णता के बाद अंतिम संदेश सूची और रन मेटाडेटा का निरीक्षण करें।
- **`before_compaction` / `after_compaction`**: compaction चक्रों का अवलोकन या एनोटेशन करें।
- **`before_tool_call` / `after_tool_call`**: टूल पैरामीटर/परिणामों को इंटरसेप्ट करें।
- **`tool_result_persist`**: सत्र ट्रांसक्रिप्ट में लिखे जाने से पहले टूल परिणामों को समकालिक रूप से रूपांतरित करें।
- **`message_received` / `message_sending` / `message_sent`**: इनबाउंड + आउटबाउंड संदेश हुक्स।
- **`session_start` / `session_end`**: सत्र जीवनचक्र सीमाएँ।
- **`gateway_start` / `gateway_stop`**: gateway जीवनचक्र घटनाएँ।

हुक API और पंजीकरण विवरण के लिए [Plugins](/tools/plugin#plugin-hooks) देखें।

## स्ट्रीमिंग + आंशिक प्रतिक्रियाएँ

- Assistant डेल्टाज़ pi-agent-core से स्ट्रीम होते हैं और `assistant` घटनाओं के रूप में उत्सर्जित होते हैं।
- ब्लॉक स्ट्रीमिंग `text_end` या `message_end` पर आंशिक प्रतिक्रियाएँ उत्सर्जित कर सकती है।
- Reasoning स्ट्रीमिंग अलग स्ट्रीम के रूप में या ब्लॉक प्रतिक्रियाओं के रूप में उत्सर्जित की जा सकती है।
- चंकिंग और ब्लॉक प्रतिक्रिया व्यवहार के लिए [Streaming](/concepts/streaming) देखें।

## टूल निष्पादन + मैसेजिंग टूल्स

- टूल start/update/end घटनाएँ `tool` स्ट्रीम पर उत्सर्जित होती हैं।
- टूल परिणाम लॉग/उत्सर्जन से पहले आकार और इमेज payloads के लिए sanitized किए जाते हैं।
- मैसेजिंग टूल सेंड्स को ट्रैक किया जाता है ताकि डुप्लिकेट assistant पुष्टि को दबाया जा सके।

## उत्तर आकार-निर्धारण + दमन

- अंतिम payloads निम्न से संयोजित होते हैं:
  - assistant पाठ (और वैकल्पिक reasoning)
  - इनलाइन टूल सारांश (जब verbose + अनुमति हो)
  - मॉडल त्रुटि होने पर assistant त्रुटि पाठ
- `NO_REPLY` को एक मौन टोकन माना जाता है और आउटगोइंग payloads से फ़िल्टर किया जाता है।
- मैसेजिंग टूल डुप्लिकेट्स को अंतिम payload सूची से हटा दिया जाता है।
- यदि कोई रेंडर योग्य payload शेष नहीं रहता और किसी टूल में त्रुटि हुई, तो एक fallback टूल त्रुटि उत्तर उत्सर्जित किया जाता है
  (जब तक कि कोई मैसेजिंग टूल पहले ही उपयोगकर्ता-दृश्यमान उत्तर न भेज चुका हो)।

## Compaction + पुनःप्रयास

- ऑटो-compaction `compaction` स्ट्रीम घटनाएँ उत्सर्जित करता है और पुनःप्रयास ट्रिगर कर सकता है।
- पुनःप्रयास पर, डुप्लिकेट आउटपुट से बचने के लिए इन-मेमोरी बफ़र्स और टूल सारांश रीसेट किए जाते हैं।
- compaction पाइपलाइन के लिए [Compaction](/concepts/compaction) देखें।

## इवेंट स्ट्रीम्स (आज)

- `lifecycle`: `subscribeEmbeddedPiSession` द्वारा उत्सर्जित (और fallback के रूप में `agentCommand` द्वारा)
- `assistant`: pi-agent-core से स्ट्रीम किए गए डेल्टाज़
- `tool`: pi-agent-core से स्ट्रीम किए गए टूल इवेंट्स

## चैट चैनल हैंडलिंग

- Assistant डेल्टाज़ को चैट `delta` संदेशों में बफ़र किया जाता है।
- **lifecycle end/error** पर एक चैट `final` उत्सर्जित किया जाता है।

## टाइमआउट्स

- 33. `agent.wait` डिफ़ॉल्ट: 30s (सिर्फ़ प्रतीक्षा)। 34. `timeoutMs` पैरामीटर ओवरराइड करता है।
- एजेंट रनटाइम: `agents.defaults.timeoutSeconds` डिफ़ॉल्ट 600s; `runEmbeddedPiAgent` abort टाइमर में लागू।

## जहाँ चीज़ें जल्दी समाप्त हो सकती हैं

- एजेंट टाइमआउट (abort)
- AbortSignal (cancel)
- Gateway डिस्कनेक्ट या RPC टाइमआउट
- `agent.wait` टाइमआउट (केवल प्रतीक्षा, एजेंट को नहीं रोकता)
