---
summary: "संदेश प्रवाह, सत्र, कतारबद्धता, और तर्क दृश्यता"
read_when:
  - यह समझाने के लिए कि इनबाउंड संदेश कैसे उत्तर बनते हैं
  - सत्रों, कतारबद्धता मोड, या स्ट्रीमिंग व्यवहार को स्पष्ट करने के लिए
  - तर्क दृश्यता और उपयोग संबंधी प्रभावों का दस्तावेज़ीकरण करने के लिए
title: "संदेश"
x-i18n:
  source_path: concepts/messages.md
  source_hash: 773301d5c0c1e3b8
  provider: openai
  model: gpt-5.2-chat-latest
  workflow: v1
  generated_at: 2026-02-08T10:49:17Z
---

# संदेश

यह पृष्ठ बताता है कि OpenClaw इनबाउंड संदेशों, सत्रों, कतारबद्धता,
स्ट्रीमिंग, और तर्क दृश्यता को कैसे संभालता है।

## संदेश प्रवाह (उच्च स्तर)

```
Inbound message
  -> routing/bindings -> session key
  -> queue (if a run is active)
  -> agent run (streaming + tools)
  -> outbound replies (channel limits + chunking)
```

मुख्य नियंत्रण विन्यास में रहते हैं:

- उपसर्गों, कतारबद्धता, और समूह व्यवहार के लिए `messages.*`।
- ब्लॉक स्ट्रीमिंग और चंकिंग डिफ़ॉल्ट के लिए `agents.defaults.*`।
- कैप्स और स्ट्रीमिंग टॉगल्स के लिए चैनल ओवरराइड्स (`channels.whatsapp.*`, `channels.telegram.*`, आदि)।

पूर्ण स्कीमा के लिए [Configuration](/gateway/configuration) देखें।

## इनबाउंड डीडुप्लीकेशन

रीकनेक्ट के बाद चैनल वही संदेश दोबारा भेज सकते हैं। OpenClaw
चैनल/खाता/पीयर/सत्र/संदेश आईडी द्वारा कुंजीकृत एक अल्पकालिक कैश रखता है ताकि
डुप्लिकेट डिलीवरी से एक और एजेंट रन ट्रिगर न हो।

## इनबाउंड डिबाउंसिंग

**उसी प्रेषक** से आने वाले तेज़ क्रमिक संदेशों को `messages.inbound` के माध्यम से
एक ही एजेंट टर्न में बैच किया जा सकता है। डिबाउंसिंग चैनल + वार्तालाप के प्रति
स्कोप्ड होती है और उत्तर थ्रेडिंग/आईडी के लिए सबसे हालिया संदेश का उपयोग करती है।

विन्यास (वैश्विक डिफ़ॉल्ट + प्रति-चैनल ओवरराइड्स):

```json5
{
  messages: {
    inbound: {
      debounceMs: 2000,
      byChannel: {
        whatsapp: 5000,
        slack: 1500,
        discord: 1500,
      },
    },
  },
}
```

नोट्स:

- डिबाउंस केवल **केवल-पाठ** संदेशों पर लागू होता है; मीडिया/अटैचमेंट तुरंत फ्लश होते हैं।
- नियंत्रण कमांड डिबाउंसिंग को बायपास करते हैं ताकि वे स्वतंत्र रहें।

## सत्र और डिवाइस

सत्र Gateway के स्वामित्व में होते हैं, क्लाइंट्स के नहीं।

- डायरेक्ट चैट्स एजेंट के मुख्य सत्र कुंजी में समाहित हो जाती हैं।
- समूह/चैनल अपने स्वयं के सत्र कुंजी प्राप्त करते हैं।
- सत्र स्टोर और ट्रांसक्रिप्ट Gateway होस्ट पर रहते हैं।

कई डिवाइस/चैनल एक ही सत्र से मैप हो सकते हैं, लेकिन इतिहास हर क्लाइंट में पूरी तरह
सिंक नहीं होता। अनुशंसा: संदर्भ में विचलन से बचने के लिए लंबी बातचीत के लिए एक
प्राथमिक डिवाइस का उपयोग करें। Control UI और TUI हमेशा Gateway-आधारित सत्र
ट्रांसक्रिप्ट दिखाते हैं, इसलिए वही सत्य का स्रोत हैं।

विवरण: [Session management](/concepts/session)।

## इनबाउंड बॉडीज़ और इतिहास संदर्भ

OpenClaw **प्रॉम्प्ट बॉडी** को **कमांड बॉडी** से अलग करता है:

- `Body`: एजेंट को भेजा गया प्रॉम्प्ट पाठ। इसमें चैनल एन्वेलप्स और
  वैकल्पिक इतिहास रैपर्स शामिल हो सकते हैं।
- `CommandBody`: निर्देश/कमांड पार्सिंग के लिए कच्चा उपयोगकर्ता पाठ।
- `RawBody`: `CommandBody` के लिए लीगेसी उपनाम (संगतता के लिए रखा गया)।

जब कोई चैनल इतिहास प्रदान करता है, तो वह एक साझा रैपर का उपयोग करता है:

- `[Chat messages since your last reply - for context]`
- `[Current message - respond to this]`

**गैर-डायरेक्ट चैट्स** (समूह/चैनल/रूम) के लिए, **वर्तमान संदेश बॉडी** को
प्रेषक लेबल के साथ उपसर्ग किया जाता है (वही शैली जो इतिहास प्रविष्टियों के लिए
प्रयुक्त होती है)। इससे रीयल-टाइम और कतारबद्ध/इतिहास संदेश एजेंट प्रॉम्प्ट में
संगत रहते हैं।

इतिहास बफ़र **केवल-पेंडिंग** होते हैं: इनमें वे समूह संदेश शामिल होते हैं जिन्होंने
रन ट्रिगर नहीं किया (उदाहरण के लिए, मेंशन-गेटेड संदेश) और **उन संदेशों को बाहर**
रखते हैं जो पहले से सत्र ट्रांसक्रिप्ट में हैं।

डायरेक्टिव स्ट्रिपिंग केवल **वर्तमान संदेश** अनुभाग पर लागू होती है ताकि इतिहास
अक्षुण्ण रहे। जो चैनल इतिहास को रैप करते हैं, उन्हें मूल संदेश पाठ के लिए
`CommandBody` (या `RawBody`) सेट करना चाहिए और संयुक्त प्रॉम्प्ट के रूप में
`Body` रखना चाहिए। इतिहास बफ़र `messages.groupChat.historyLimit` (वैश्विक
डिफ़ॉल्ट) और प्रति-चैनल ओवरराइड्स जैसे `channels.slack.historyLimit` या
`channels.telegram.accounts.<id>.historyLimit` के माध्यम से विन्यस्त होते हैं (अक्षम करने के लिए `0` सेट करें)।

## कतारबद्धता और फॉलोअप्स

यदि कोई रन पहले से सक्रिय है, तो इनबाउंड संदेशों को कतार में रखा जा सकता है,
वर्तमान रन में निर्देशित किया जा सकता है, या फॉलोअप टर्न के लिए एकत्र किया जा सकता है।

- `messages.queue` (और `messages.queue.byChannel`) के माध्यम से विन्यास करें।
- मोड्स: `interrupt`, `steer`, `followup`, `collect`, साथ ही बैकलॉग वेरिएंट्स।

विवरण: [Queueing](/concepts/queue)।

## स्ट्रीमिंग, चंकिंग, और बैचिंग

ब्लॉक स्ट्रीमिंग मॉडल द्वारा टेक्स्ट ब्लॉक्स बनते ही आंशिक उत्तर भेजती है।
चंकिंग चैनल टेक्स्ट सीमाओं का सम्मान करती है और फ़ेंस्ड कोड को विभाजित करने से बचाती है।

मुख्य सेटिंग्स:

- `agents.defaults.blockStreamingDefault` (`on|off`, डिफ़ॉल्ट बंद)
- `agents.defaults.blockStreamingBreak` (`text_end|message_end`)
- `agents.defaults.blockStreamingChunk` (`minChars|maxChars|breakPreference`)
- `agents.defaults.blockStreamingCoalesce` (आइडल-आधारित बैचिंग)
- `agents.defaults.humanDelay` (ब्लॉक उत्तरों के बीच मानव-सदृश विराम)
- चैनल ओवरराइड्स: `*.blockStreaming` और `*.blockStreamingCoalesce` (गैर-Telegram चैनलों के लिए स्पष्ट `*.blockStreaming: true` आवश्यक)

विवरण: [Streaming + chunking](/concepts/streaming)।

## तर्क दृश्यता और टोकन

OpenClaw मॉडल तर्क को प्रदर्शित या छिपा सकता है:

- `/reasoning on|off|stream` दृश्यता को नियंत्रित करता है।
- मॉडल द्वारा उत्पन्न होने पर तर्क सामग्री अभी भी टोकन उपयोग में गिनी जाती है।
- Telegram ड्राफ्ट बबल में तर्क स्ट्रीम का समर्थन करता है।

विवरण: [Thinking + reasoning directives](/tools/thinking) और [Token use](/reference/token-use)।

## उपसर्ग, थ्रेडिंग, और उत्तर

आउटबाउंड संदेश स्वरूपण `messages` में केंद्रीकृत है:

- `messages.responsePrefix`, `channels.<channel>.responsePrefix`, और `channels.<channel>.accounts.<id>.responsePrefix` (आउटबाउंड उपसर्ग कैस्केड), साथ ही `channels.whatsapp.messagePrefix` (WhatsApp इनबाउंड उपसर्ग)
- `replyToMode` और प्रति-चैनल डिफ़ॉल्ट्स के माध्यम से उत्तर थ्रेडिंग

विवरण: [Configuration](/gateway/configuration#messages) और चैनल दस्तावेज़।
