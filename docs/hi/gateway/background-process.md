---
summary: "बैकग्राउंड exec निष्पादन और प्रक्रिया प्रबंधन"
read_when:
  - बैकग्राउंड exec व्यवहार जोड़ते या संशोधित करते समय
  - लंबे समय तक चलने वाले exec कार्यों का डिबग करते समय
title: "बैकग्राउंड Exec और प्रोसेस टूल"
---

# बैकग्राउंड Exec + प्रोसेस टूल

7. OpenClaw शेल कमांड्स को `exec` टूल के माध्यम से चलाता है और लंबे समय तक चलने वाले कार्यों को मेमोरी में रखता है। 8. `process` टूल उन बैकग्राउंड सेशनों को प्रबंधित करता है।

## exec टूल

मुख्य पैरामीटर:

- `command` (आवश्यक)
- `yieldMs` (डिफ़ॉल्ट 10000): इस विलंब के बाद स्वतः बैकग्राउंड
- `background` (bool): तुरंत बैकग्राउंड करें
- `timeout` (सेकंड, डिफ़ॉल्ट 1800): इस टाइमआउट के बाद प्रक्रिया समाप्त करें
- `elevated` (bool): यदि उन्नत मोड सक्षम/अनुमत है तो होस्ट पर चलाएँ
- 9. क्या आपको एक वास्तविक TTY चाहिए? 10. `pty: true` सेट करें।
- `workdir`, `env`

व्यवहार:

- फ़ोरग्राउंड रन सीधे आउटपुट लौटाते हैं।
- जब बैकग्राउंड किया जाता है (स्पष्ट रूप से या टाइमआउट पर), टूल `status: "running"` + `sessionId` और एक छोटा टेल लौटाता है।
- आउटपुट तब तक मेमोरी में रखा जाता है जब तक सत्र को पोल या साफ़ नहीं किया जाता।
- यदि `process` टूल अस्वीकृत है, तो `exec` समकालिक रूप से चलता है और `yieldMs`/`background` को अनदेखा करता है।

## चाइल्ड प्रक्रिया ब्रिजिंग

11. जब exec/process टूल्स के बाहर लंबे समय तक चलने वाली child processes spawn की जाती हैं (उदाहरण के लिए, CLI respawns या gateway helpers), तो child‑process bridge helper को attach करें ताकि termination signals फ़ॉरवर्ड हों और exit/error पर listeners detach हो जाएँ। 12. इससे systemd पर orphaned processes से बचाव होता है और प्लेटफ़ॉर्म्स के बीच shutdown व्यवहार सुसंगत रहता है।

पर्यावरण ओवरराइड्स:

- `PI_BASH_YIELD_MS`: डिफ़ॉल्ट यील्ड (ms)
- `PI_BASH_MAX_OUTPUT_CHARS`: इन‑मेमोरी आउटपुट सीमा (chars)
- `OPENCLAW_BASH_PENDING_MAX_OUTPUT_CHARS`: प्रति स्ट्रीम लंबित stdout/stderr सीमा (chars)
- `PI_BASH_JOB_TTL_MS`: पूर्ण सत्रों के लिए TTL (ms, 1m–3h तक सीमित)

विन्यास (पसंदीदा):

- `tools.exec.backgroundMs` (डिफ़ॉल्ट 10000)
- `tools.exec.timeoutSec` (डिफ़ॉल्ट 1800)
- `tools.exec.cleanupMs` (डिफ़ॉल्ट 1800000)
- `tools.exec.notifyOnExit` (डिफ़ॉल्ट true): जब कोई बैकग्राउंड exec समाप्त होता है तो एक सिस्टम इवेंट कतारबद्ध करें + अनुरोध हार्टबीट।

## process टूल

क्रियाएँ:

- `list`: चल रहे + पूर्ण सत्र
- `poll`: किसी सत्र के लिए नया आउटपुट ड्रेन करें (एग्ज़िट स्टेटस भी रिपोर्ट करता है)
- `log`: समेकित आउटपुट पढ़ें (`offset` + `limit` समर्थित)
- `write`: stdin भेजें (`data`, वैकल्पिक `eof`)
- `kill`: किसी बैकग्राउंड सत्र को समाप्त करें
- `clear`: मेमोरी से किसी पूर्ण सत्र को हटाएँ
- `remove`: यदि चल रहा हो तो kill करें, अन्यथा यदि पूर्ण हो तो साफ़ करें

नोट्स:

- केवल बैकग्राउंड किए गए सत्र ही सूचीबद्ध/मेमोरी में स्थायी रहते हैं।
- प्रक्रिया पुनः आरंभ पर सत्र खो जाते हैं (डिस्क पर स्थायित्व नहीं)।
- सत्र लॉग केवल चैट इतिहास में सहेजे जाते हैं यदि आप `process poll/log` चलाते हैं और टूल परिणाम रिकॉर्ड किया जाता है।
- `process` प्रति एजेंट स्कोप्ड है; यह केवल उसी एजेंट द्वारा शुरू किए गए सत्रों को देखता है।
- `process list` में त्वरित स्कैन के लिए एक व्युत्पन्न `name` (कमांड क्रिया + लक्ष्य) शामिल होता है।
- `process log` लाइन‑आधारित `offset`/`limit` का उपयोग करता है (`offset` को छोड़ दें ताकि अंतिम N पंक्तियाँ प्राप्त हों)।

## उदाहरण

एक लंबा कार्य चलाएँ और बाद में पोल करें:

```json
{ "tool": "exec", "command": "sleep 5 && echo done", "yieldMs": 1000 }
```

```json
{ "tool": "process", "action": "poll", "sessionId": "<id>" }
```

तुरंत बैकग्राउंड में प्रारंभ करें:

```json
{ "tool": "exec", "command": "npm run build", "background": true }
```

stdin भेजें:

```json
{ "tool": "process", "action": "write", "sessionId": "<id>", "data": "y\n" }
```
