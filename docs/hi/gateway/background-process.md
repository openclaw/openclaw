---
summary: "बैकग्राउंड exec निष्पादन और प्रक्रिया प्रबंधन"
read_when:
  - बैकग्राउंड exec व्यवहार जोड़ते या संशोधित करते समय
  - लंबे समय तक चलने वाले exec कार्यों का डिबग करते समय
title: "बैकग्राउंड Exec और प्रोसेस टूल"
x-i18n:
  source_path: gateway/background-process.md
  source_hash: e11a7d74a75000d6
  provider: openai
  model: gpt-5.2-chat-latest
  workflow: v1
  generated_at: 2026-02-08T10:49:17Z
---

# बैकग्राउंड Exec + प्रोसेस टूल

OpenClaw शेल कमांड्स को `exec` टूल के माध्यम से चलाता है और लंबे समय तक चलने वाले कार्यों को मेमोरी में रखता है। `process` टूल उन बैकग्राउंड सत्रों का प्रबंधन करता है।

## exec टूल

मुख्य पैरामीटर:

- `command` (आवश्यक)
- `yieldMs` (डिफ़ॉल्ट 10000): इस विलंब के बाद स्वतः बैकग्राउंड
- `background` (bool): तुरंत बैकग्राउंड करें
- `timeout` (सेकंड, डिफ़ॉल्ट 1800): इस टाइमआउट के बाद प्रक्रिया समाप्त करें
- `elevated` (bool): यदि उन्नत मोड सक्षम/अनुमत है तो होस्ट पर चलाएँ
- वास्तविक TTY चाहिए? `pty: true` सेट करें।
- `workdir`, `env`

व्यवहार:

- फ़ोरग्राउंड रन सीधे आउटपुट लौटाते हैं।
- जब बैकग्राउंड किया जाता है (स्पष्ट रूप से या टाइमआउट पर), टूल `status: "running"` + `sessionId` और एक छोटा टेल लौटाता है।
- आउटपुट तब तक मेमोरी में रखा जाता है जब तक सत्र को पोल या साफ़ नहीं किया जाता।
- यदि `process` टूल अस्वीकृत है, तो `exec` समकालिक रूप से चलता है और `yieldMs`/`background` को अनदेखा करता है।

## चाइल्ड प्रक्रिया ब्रिजिंग

जब exec/process टूल्स के बाहर लंबे समय तक चलने वाली चाइल्ड प्रक्रियाएँ स्पॉन की जाती हैं (उदाहरण के लिए, CLI री-स्पॉन या Gateway सहायक), तो चाइल्ड-प्रोसेस ब्रिज हेल्पर संलग्न करें ताकि टर्मिनेशन सिग्नल फ़ॉरवर्ड हों और एग्ज़िट/त्रुटि पर लिस्नर अलग हो जाएँ। इससे systemd पर अनाथ प्रक्रियाएँ बनने से बचता है और प्लेटफ़ॉर्म्स के बीच शटडाउन व्यवहार सुसंगत रहता है।

पर्यावरण ओवरराइड्स:

- `PI_BASH_YIELD_MS`: डिफ़ॉल्ट यील्ड (ms)
- `PI_BASH_MAX_OUTPUT_CHARS`: इन‑मेमोरी आउटपुट सीमा (chars)
- `OPENCLAW_BASH_PENDING_MAX_OUTPUT_CHARS`: प्रति स्ट्रीम लंबित stdout/stderr सीमा (chars)
- `PI_BASH_JOB_TTL_MS`: पूर्ण सत्रों के लिए TTL (ms, 1m–3h तक सीमित)

विन्यास (पसंदीदा):

- `tools.exec.backgroundMs` (डिफ़ॉल्ट 10000)
- `tools.exec.timeoutSec` (डिफ़ॉल्ट 1800)
- `tools.exec.cleanupMs` (डिफ़ॉल्ट 1800000)
- `tools.exec.notifyOnExit` (डिफ़ॉल्ट true): जब कोई बैकग्राउंड exec समाप्त होता है तो एक सिस्टम इवेंट कतारबद्ध करें + अनुरोध हार्टबीट।

## process टूल

क्रियाएँ:

- `list`: चल रहे + पूर्ण सत्र
- `poll`: किसी सत्र के लिए नया आउटपुट ड्रेन करें (एग्ज़िट स्टेटस भी रिपोर्ट करता है)
- `log`: समेकित आउटपुट पढ़ें (`offset` + `limit` समर्थित)
- `write`: stdin भेजें (`data`, वैकल्पिक `eof`)
- `kill`: किसी बैकग्राउंड सत्र को समाप्त करें
- `clear`: मेमोरी से किसी पूर्ण सत्र को हटाएँ
- `remove`: यदि चल रहा हो तो kill करें, अन्यथा यदि पूर्ण हो तो साफ़ करें

नोट्स:

- केवल बैकग्राउंड किए गए सत्र ही सूचीबद्ध/मेमोरी में स्थायी रहते हैं।
- प्रक्रिया पुनः आरंभ पर सत्र खो जाते हैं (डिस्क पर स्थायित्व नहीं)।
- सत्र लॉग केवल चैट इतिहास में सहेजे जाते हैं यदि आप `process poll/log` चलाते हैं और टूल परिणाम रिकॉर्ड किया जाता है।
- `process` प्रति एजेंट स्कोप्ड है; यह केवल उसी एजेंट द्वारा शुरू किए गए सत्रों को देखता है।
- `process list` में त्वरित स्कैन के लिए एक व्युत्पन्न `name` (कमांड क्रिया + लक्ष्य) शामिल होता है।
- `process log` लाइन‑आधारित `offset`/`limit` का उपयोग करता है (`offset` को छोड़ दें ताकि अंतिम N पंक्तियाँ प्राप्त हों)।

## उदाहरण

एक लंबा कार्य चलाएँ और बाद में पोल करें:

```json
{ "tool": "exec", "command": "sleep 5 && echo done", "yieldMs": 1000 }
```

```json
{ "tool": "process", "action": "poll", "sessionId": "<id>" }
```

तुरंत बैकग्राउंड में प्रारंभ करें:

```json
{ "tool": "exec", "command": "npm run build", "background": true }
```

stdin भेजें:

```json
{ "tool": "process", "action": "write", "sessionId": "<id>", "data": "y\n" }
```
