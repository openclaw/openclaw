---
summary: "WebSocket लिस्नर बाइंड का उपयोग करके Gateway सिंगलटन गार्ड"
read_when:
  - Gateway प्रक्रिया चलाते या डिबग करते समय
  - एकल-इंस्टेंस प्रवर्तन की जाँच करते समय
title: "Gateway लॉक"
---

# Gateway लॉक

अंतिम अपडेट: 2025-12-11

## क्यों

- सुनिश्चित करें कि एक ही होस्ट पर प्रति बेस पोर्ट केवल एक Gateway इंस्टेंस चले; अतिरिक्त Gateway को पृथक प्रोफ़ाइल और अद्वितीय पोर्ट का उपयोग करना चाहिए।
- क्रैश/SIGKILL के बाद भी स्थायी लॉक फ़ाइलें छोड़े बिना सुरक्षित रूप से काम करे।
- नियंत्रण पोर्ट पहले से व्यस्त होने पर स्पष्ट त्रुटि के साथ तुरंत विफल हो।

## तंत्र

- Gateway स्टार्टअप के तुरंत बाद WebSocket लिस्नर (डिफ़ॉल्ट `ws://127.0.0.1:18789`) को एक विशेष TCP लिस्नर का उपयोग करके बाइंड करता है।
- यदि बाइंड `EADDRINUSE` के साथ विफल होता है, तो स्टार्टअप `GatewayLockError("another gateway instance is already listening on ws://127.0.0.1:<port>")` फेंकता है।
- OS किसी भी प्रक्रिया समाप्ति पर—क्रैश और SIGKILL सहित—लिस्नर को स्वचालित रूप से रिलीज़ कर देता है; अलग लॉक फ़ाइल या क्लीनअप चरण की आवश्यकता नहीं होती।
- शटडाउन पर Gateway पोर्ट को शीघ्र मुक्त करने के लिए WebSocket सर्वर और अंतर्निहित HTTP सर्वर को बंद कर देता है।

## त्रुटि सतह

- यदि कोई अन्य प्रक्रिया पोर्ट को होल्ड कर रही है, तो स्टार्टअप `GatewayLockError("another gateway instance is already listening on ws://127.0.0.1:<port>")` फेंकता है।
- अन्य बाइंड विफलताएँ `GatewayLockError("failed to bind gateway socket on ws://127.0.0.1:<port>: …")` के रूप में प्रकट होती हैं।

## परिचालन नोट्स

- यदि पोर्ट किसी _अन्य_ प्रक्रिया द्वारा व्यस्त है, तो त्रुटि वही रहती है; पोर्ट खाली करें या `openclaw gateway --port <port>` के साथ कोई अन्य चुनें।
- macOS ऐप Gateway को स्पॉन करने से पहले अपना स्वयं का हल्का PID गार्ड बनाए रखता है; रनटाइम लॉक WebSocket बाइंड द्वारा प्रवर्तित होता है।
