---
summary: "अनुसंधान नोट्स: Clawd वर्कस्पेस के लिए ऑफ़लाइन मेमोरी सिस्टम (Markdown स्रोत‑ऑफ़‑ट्रुथ + व्युत्पन्न इंडेक्स)"
read_when:
  - दैनिक Markdown लॉग से आगे वर्कस्पेस मेमोरी (~/.openclaw/workspace) डिज़ाइन करते समय
  - Deciding: 42. standalone CLI बनाम deep OpenClaw integration
  - ऑफ़लाइन रिकॉल + रिफ़्लेक्शन (retain/recall/reflect) जोड़ते समय
title: "वर्कस्पेस मेमोरी अनुसंधान"
---

# Workspace Memory v2 (offline): अनुसंधान नोट्स

लक्ष्य: Clawd‑शैली का वर्कस्पेस (`agents.defaults.workspace`, डिफ़ॉल्ट `~/.openclaw/workspace`) जहाँ “मेमोरी” प्रति दिन एक Markdown फ़ाइल (`memory/YYYY-MM-DD.md`) के रूप में संग्रहीत होती है, साथ ही कुछ स्थिर फ़ाइलें (जैसे `memory.md`, `SOUL.md`) होती हैं।

यह दस्तावेज़ एक **offline‑first** मेमोरी आर्किटेक्चर प्रस्तावित करता है जो Markdown को कैनोनिकल, समीक्षा‑योग्य स्रोत‑ऑफ़‑ट्रुथ बनाए रखता है, लेकिन एक व्युत्पन्न इंडेक्स के माध्यम से **संरचित रिकॉल** (खोज, एंटिटी सारांश, कॉन्फ़िडेंस अपडेट) जोड़ता है।

## Why change?

वर्तमान सेटअप (प्रति दिन एक फ़ाइल) इन मामलों में उत्कृष्ट है:

- “append‑only” जर्नलिंग
- मानव द्वारा संपादन
- git‑समर्थित टिकाऊपन + ऑडिटेबिलिटी
- कम घर्षण वाला कैप्चर (“बस लिख दो”)

यह इन मामलों में कमज़ोर है:

- उच्च‑रिकॉल पुनर्प्राप्ति (“हमने X के बारे में क्या तय किया?”, “पिछली बार Y कब आज़माया?”)
- एंटिटी‑केंद्रित उत्तर (“Alice / The Castle / warelay के बारे में बताओ”) बिना कई फ़ाइलें दोबारा पढ़े
- राय/प्राथमिकता की स्थिरता (और बदलने पर प्रमाण)
- 43. समय संबंधी सीमाएँ (“Nov 2025 के दौरान क्या सत्य था?”) 44. और conflict resolution

## Design goals

- **Offline**: नेटवर्क के बिना काम करे; लैपटॉप/Castle पर चल सके; कोई क्लाउड निर्भरता नहीं।
- **Explainable**: प्राप्त आइटम्स को एट्रिब्यूट किया जा सके (फ़ाइल + लोकेशन) और इनफ़ेरेंस से अलग रखा जा सके।
- **Low ceremony**: दैनिक लॉगिंग Markdown ही रहे, भारी स्कीमा काम न हो।
- **Incremental**: v1 केवल FTS के साथ भी उपयोगी; सेमांटिक/वेक्टर और ग्राफ़ वैकल्पिक अपग्रेड हों।
- **Agent‑friendly**: “टोकन बजट के भीतर रिकॉल” को आसान बनाए (तथ्यों के छोटे बंडल लौटाए)।

## North star model (Hindsight × Letta)

दो हिस्सों का संयोजन:

1. **Letta/MemGPT‑शैली कंट्रोल लूप**

- एक छोटा “core” हमेशा कॉन्टेक्स्ट में रखें (persona + प्रमुख उपयोगकर्ता तथ्य)
- बाकी सब कॉन्टेक्स्ट से बाहर रहे और टूल्स के माध्यम से रिकॉल हो
- मेमोरी राइट्स स्पष्ट टूल कॉल्स हों (append/replace/insert), परसिस्ट हों, और अगली बारी में फिर से इंजेक्ट हों

2. **Hindsight‑शैली मेमोरी सब्सट्रेट**

- जो देखा गया बनाम जो माना गया बनाम जो सारांशित है—इनको अलग करें
- retain/recall/reflect का समर्थन
- कॉन्फ़िडेंस‑युक्त राय जो साक्ष्य के साथ विकसित हो सके
- एंटिटी‑अवेयर रिकॉल + टेम्पोरल क्वेरीज़ (पूरे नॉलेज ग्राफ़ के बिना भी)

## Proposed architecture (Markdown source‑of‑truth + derived index)

### Canonical store (git‑friendly)

`~/.openclaw/workspace` को कैनोनिकल, मानव‑पठनीय मेमोरी के रूप में रखें।

सुझाया गया वर्कस्पेस लेआउट:

```
~/.openclaw/workspace/
  memory.md                    # small: durable facts + preferences (core-ish)
  memory/
    YYYY-MM-DD.md              # daily log (append; narrative)
  bank/                        # “typed” memory pages (stable, reviewable)
    world.md                   # objective facts about the world
    experience.md              # what the agent did (first-person)
    opinions.md                # subjective prefs/judgments + confidence + evidence pointers
    entities/
      Peter.md
      The-Castle.md
      warelay.md
      ...
```

नोट्स:

- 45. **Daily log stays daily log**। 46. इसे JSON में बदलने की ज़रूरत नहीं है।
- `bank/` फ़ाइलें **क्यूरेटेड** होती हैं, रिफ़्लेक्शन जॉब्स द्वारा बनाई जाती हैं, और फिर भी हाथ से संपादित की जा सकती हैं।
- `memory.md` “छोटा + core‑ish” बना रहता है: वे चीज़ें जिन्हें आप हर सत्र में Clawd को दिखाना चाहते हैं।

### Derived store (machine recall)

वर्कस्पेस के अंतर्गत एक व्युत्पन्न इंडेक्स जोड़ें (ज़रूरी नहीं कि git में ट्रैक हो):

```
~/.openclaw/workspace/.memory/index.sqlite
```

इसके पीछे:

- तथ्यों + एंटिटी लिंक + राय मेटाडेटा के लिए SQLite स्कीमा
- लेक्सिकल रिकॉल के लिए SQLite **FTS5** (तेज़, छोटा, ऑफ़लाइन)
- सेमांटिक रिकॉल के लिए वैकल्पिक एम्बेडिंग्स टेबल (अब भी ऑफ़लाइन)

यह इंडेक्स हमेशा **Markdown से पुनर्निर्माण‑योग्य** होता है।

## Retain / Recall / Reflect (operational loop)

### Retain: दैनिक लॉग्स को “facts” में नॉर्मलाइज़ करें

Hindsight की मुख्य अंतर्दृष्टि जो यहाँ मायने रखती है: बहुत छोटे स्निपेट्स नहीं, बल्कि **कथात्मक, आत्म‑निहित तथ्य** संग्रहीत करें।

`memory/YYYY-MM-DD.md` के लिए व्यावहारिक नियम:

- दिन के अंत में (या दौरान), एक `## Retain` सेक्शन जोड़ें जिसमें 2–5 बुलेट हों जो:
  - कथात्मक हों (क्रॉस‑टर्न कॉन्टेक्स्ट संरक्षित)
  - आत्म‑निहित हों (बाद में अकेले भी अर्थपूर्ण)
  - प्रकार + एंटिटी मेंशन से टैग किए गए हों

उदाहरण:

```
## Retain
- W @Peter: Currently in Marrakech (Nov 27–Dec 1, 2025) for Andy’s birthday.
- B @warelay: I fixed the Baileys WS crash by wrapping connection.update handlers in try/catch (see memory/2025-11-27.md).
- O(c=0.95) @Peter: Prefers concise replies (&lt;1500 chars) on WhatsApp; long content goes into files.
```

न्यूनतम पार्सिंग:

- प्रकार प्रीफ़िक्स: `W` (world), `B` (experience/biographical), `O` (opinion), `S` (observation/summary; आमतौर पर जेनरेटेड)
- एंटिटीज़: `@Peter`, `@warelay`, आदि (स्लग्स `bank/entities/*.md` से मैप होते हैं)
- राय कॉन्फ़िडेंस: `O(c=0.0..1.0)` वैकल्पिक

यदि आप लेखकों को इस बारे में सोचने नहीं देना चाहते: रिफ़्लेक्ट जॉब बाकी लॉग से इन बुलेट्स को अनुमानित कर सकता है, लेकिन एक स्पष्ट `## Retain` सेक्शन होना सबसे आसान “क्वालिटी लीवर” है।

### Recall: व्युत्पन्न इंडेक्स पर क्वेरीज़

रिकॉल को समर्थन देना चाहिए:

- **lexical**: “सटीक शब्द / नाम / कमांड खोजें” (FTS5)
- **entity**: “X के बारे में बताओ” (एंटिटी पेज + एंटिटी‑लिंक्ड तथ्य)
- **temporal**: “27 नवंबर के आसपास क्या हुआ” / “पिछले हफ़्ते से”
- 47. **opinion**: “Peter क्या पसंद करता है?” 48. (confidence + evidence के साथ)

रिटर्न फ़ॉर्मेट एजेंट‑फ्रेंडली हो और स्रोत उद्धृत करे:

- `kind` (`world|experience|opinion|observation`)
- `timestamp` (स्रोत दिन, या यदि उपलब्ध हो तो निकाली गई समय‑सीमा)
- `entities` (`["Peter","warelay"]`)
- `content` (कथात्मक तथ्य)
- `source` (`memory/2025-11-27.md#L12` आदि)

### Reflect: स्थिर पेज बनाएँ + विश्वास अपडेट करें

रिफ़्लेक्शन एक शेड्यूल्ड जॉब है (दैनिक या हार्टबीट `ultrathink`) जो:

- हालिया तथ्यों से `bank/entities/*.md` अपडेट करता है (एंटिटी सारांश)
- सुदृढीकरण/विरोध के आधार पर `bank/opinions.md` कॉन्फ़िडेंस अपडेट करता है
- वैकल्पिक रूप से `memory.md` (“core‑ish” टिकाऊ तथ्य) में संपादन प्रस्तावित करता है

राय का विकास (सरल, व्याख्येय):

- प्रत्येक राय में होता है:
  - कथन
  - कॉन्फ़िडेंस `c ∈ [0,1]`
  - last_updated
  - साक्ष्य लिंक (समर्थक + विरोधी fact IDs)
- जब नए तथ्य आते हैं:
  - एंटिटी ओवरलैप + समानता के आधार पर उम्मीदवार राय खोजें (पहले FTS, बाद में एम्बेडिंग्स)
  - छोटे डेल्टा से कॉन्फ़िडेंस अपडेट करें; बड़े जंप के लिए मजबूत विरोध + दोहराया गया साक्ष्य आवश्यक हो

## CLI integration: standalone vs deep integration

सिफ़ारिश: **OpenClaw में गहरी एकीकरण**, लेकिन एक अलग किया जा सकने वाला कोर लाइब्रेरी रखें।

### OpenClaw में एकीकृत क्यों करें?

- OpenClaw पहले से जानता है:
  - वर्कस्पेस पाथ (`agents.defaults.workspace`)
  - सत्र मॉडल + हार्टबीट्स
  - लॉगिंग + समस्या‑निवारण पैटर्न
- आप चाहते हैं कि एजेंट स्वयं टूल्स कॉल करे:
  - `openclaw memory recall "…" --k 25 --since 30d`
  - `openclaw memory reflect --since 7d`

### फिर भी लाइब्रेरी अलग क्यों रखें?

- मेमोरी लॉजिक को gateway/runtime के बिना टेस्टेबल रखना
- अन्य संदर्भों से पुनः उपयोग (लोकल स्क्रिप्ट्स, भविष्य का डेस्कटॉप ऐप, आदि)

Shape:
मेमोरी टूलिंग को एक छोटा CLI + लाइब्रेरी लेयर होना चाहिए, लेकिन यह केवल अन्वेषणात्मक है।

## “S‑Collide” / SuCo: कब उपयोग करें (research)

यदि “S‑Collide” से आशय **SuCo (Subspace Collision)** है: यह एक ANN रिकॉल दृष्टिकोण है जो सबस्पेसेज़ में सीखे/संरचित collisions का उपयोग करके मजबूत रिकॉल/लेटेंसी ट्रेड‑ऑफ़ को लक्ष्य करता है (पेपर: arXiv 2411.14754, 2024)।

`~/.openclaw/workspace` के लिए व्यावहारिक निष्कर्ष:

- SuCo से **शुरुआत न करें**।
- SQLite FTS + (वैकल्पिक) सरल एम्बेडिंग्स से शुरू करें; तुरंत अधिकांश UX लाभ मिलेंगे।
- SuCo/HNSW/ScaNN‑क्लास समाधानों पर तभी विचार करें जब:
  - कॉर्पस बड़ा हो (दसियों/सैकड़ों हज़ार चंक्स)
  - ब्रूट‑फ़ोर्स एम्बेडिंग खोज बहुत धीमी हो जाए
  - रिकॉल गुणवत्ता लेक्सिकल खोज से अर्थपूर्ण रूप से बाधित हो

ऑफ़लाइन‑फ्रेंडली विकल्प (जटिलता बढ़ते क्रम में):

- SQLite FTS5 + मेटाडेटा फ़िल्टर्स (शून्य ML)
- एम्बेडिंग्स + ब्रूट फ़ोर्स (कम चंक काउंट पर आश्चर्यजनक रूप से दूर तक काम करता है)
- HNSW इंडेक्स (सामान्य, मज़बूत; लाइब्रेरी बाइंडिंग की आवश्यकता)
- SuCo (रिसर्च‑ग्रेड; आकर्षक यदि एम्बेड करने योग्य ठोस इम्प्लीमेंटेशन हो)

Open question:

- आपकी मशीनों (लैपटॉप + डेस्कटॉप) पर “पर्सनल असिस्टेंट मेमोरी” के लिए **सबसे अच्छा** ऑफ़लाइन एम्बेडिंग मॉडल कौन‑सा है?
  - यदि आपके पास पहले से Ollama है: लोकल मॉडल से एम्बेड करें; अन्यथा टूलचेन में एक छोटा एम्बेडिंग मॉडल शिप करें।

## Smallest useful pilot

यदि आप एक न्यूनतम, फिर भी उपयोगी संस्करण चाहते हैं:

- `bank/` एंटिटी पेज और दैनिक लॉग्स में एक `## Retain` सेक्शन जोड़ें।
- उद्धरणों (पाथ + लाइन नंबर) के साथ रिकॉल के लिए SQLite FTS का उपयोग करें।
- एम्बेडिंग्स केवल तब जोड़ें जब रिकॉल गुणवत्ता या स्केल इसकी माँग करे।

## References

- Letta / MemGPT अवधारणाएँ: “core memory blocks” + “archival memory” + टूल‑ड्रिवन self‑editing memory।
- Hindsight Technical Report: “retain / recall / reflect”, चार‑नेटवर्क मेमोरी, कथात्मक तथ्य निष्कर्षण, राय कॉन्फ़िडेंस का विकास।
- SuCo: arXiv 2411.14754 (2024): “Subspace Collision” approximate nearest neighbor retrieval।
