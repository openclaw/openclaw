---
read_when:
    - 노드 + 운영자 클라이언트를 위한 통합 네트워크 프로토콜 계획
    - 승인, 페어링, TLS 및 기기 간 존재 재작업
summary: 'Clawnet 리팩터링: 네트워크 프로토콜, 역할, 인증, 승인, ID 통합'
title: 클로넷 리팩터링
x-i18n:
    generated_at: "2026-02-08T16:10:29Z"
    model: gtx
    provider: google-translate
    source_hash: 719b219c3b326479658fe6101c80d5273fc56eb3baf50be8535e0d1d2bb7987f
    source_path: refactor/clawnet.md
    workflow: 15
---

# Clawnet 리팩터링(프로토콜 + 인증 통합)

## 안녕

안녕하세요 피터 – 훌륭한 방향; 이를 통해 더 간단한 UX + 더 강력한 보안이 잠금 해제됩니다.

## 목적

다음을 위한 단일하고 엄격한 문서:

- 현재 상태: 프로토콜, 흐름, 신뢰 경계.
- 문제점: 승인, 멀티홉 라우팅, UI 복제.
- 제안된 새로운 상태: 단일 프로토콜, 범위가 지정된 역할, 통합 인증/페어링, TLS 고정.
- 아이덴티티 모델: 안정적인 ID + 귀여운 슬러그.
- 마이그레이션 계획, 위험, 공개 질문.

## 목표(토론에서)

- 모든 클라이언트(mac 앱, CLI, iOS, Android, 헤드리스 노드)를 위한 단일 프로토콜입니다.
- 모든 네트워크 참가자가 인증 + 페어링되었습니다.
- 역할 명확성: 노드 대 운영자.
- 사용자가 있는 곳으로 중앙 승인이 전달됩니다.
- 모든 원격 트래픽에 대한 TLS 암호화 + 선택적 고정.
- 최소한의 코드 중복.
- 단일 머신은 한 번만 나타나야 합니다(UI/노드 중복 항목 없음).

## 논골(명시적)

- 기능 분리를 제거합니다(여전히 최소 권한이 필요함).
- 범위 확인 없이 전체 게이트웨이 제어 영역을 노출합니다.
- 인증이 사람의 레이블에 따라 달라지도록 합니다(슬러그는 비보안 상태로 유지됩니다).

---

# 현재 상태(있는 그대로)

## 두 가지 프로토콜

### 1) 게이트웨이 WebSocket(제어 평면)

- 전체 API 표면: 구성, 채널, 모델, 세션, 에이전트 실행, 로그, 노드 등
- 기본 바인드: 루프백. SSH/Tailscale을 통한 원격 액세스.
- 인증: 토큰/비밀번호 `connect`.
- TLS 고정 없음(루프백/터널에 의존)
- 암호:
  - `src/gateway/server/ws-connection/message-handler.ts`
  - `src/gateway/client.ts`
  - `docs/gateway/protocol.md`

### 2) 브리지(노드 전송)

- 좁은 허용 목록 표면, 노드 ID + 페어링.
- TCP를 통한 JSONL; 선택적 TLS + 인증서 지문 고정.
- TLS는 검색 TXT에 지문을 광고합니다.
- 암호:
  - `src/infra/bridge/server/connection.ts`
  - `src/gateway/server-bridge.ts`
  - `src/node-host/bridge-client.ts`
  - `docs/gateway/bridge-protocol.md`

## 현재 제어 평면 클라이언트

- CLI → 게이트웨이 WS를 통해 `callGateway` (`src/gateway/call.ts`).
- macOS 앱 UI → 게이트웨이 WS(`GatewayConnection`).
- 웹 제어 UI → 게이트웨이 WS.
- ACP → 게이트웨이 WS.
- 브라우저 컨트롤은 자체 HTTP 제어 서버를 사용합니다.

## 오늘의 노드

- 노드 모드의 macOS 앱은 게이트웨이 브리지(`MacNodeBridgeSession`).
- iOS/Android 앱은 게이트웨이 브리지에 연결됩니다.
- 페어링 + 게이트웨이에 저장된 노드별 토큰.

## 현재 승인 흐름(실행)

- 에이전트가 사용하는 것 `system.run` 게이트웨이를 통해.
- 게이트웨이는 브리지를 통해 노드를 호출합니다.
- 노드 런타임이 승인을 결정합니다.
- Mac 앱에 표시되는 UI 프롬프트(노드 == Mac 앱인 경우)
- 노드 반환 `invoke-res` 게이트웨이로.
- 멀티홉, 노드 호스트에 연결된 UI.

## 오늘의 존재 + 정체성

- WS 클라이언트의 게이트웨이 존재 항목입니다.
- 브리지의 노드 존재 항목입니다.
- Mac 앱은 동일한 시스템(UI + 노드)에 대해 두 개의 항목을 표시할 수 있습니다.
- 페어링 저장소에 저장된 노드 ID. UI ID는 별도입니다.

---

# 문제/고충점

- 유지 관리할 프로토콜 스택 2개(WS + 브리지)
- 원격 노드에 대한 승인: 프롬프트는 사용자가 있는 곳이 아닌 노드 호스트에 나타납니다.
- TLS 고정은 브리지에만 존재합니다. WS는 SSH/Tailscale에 의존합니다.
- ID 복제: 동일한 머신이 여러 인스턴스로 표시됩니다.
- 모호한 역할: UI + 노드 + CLI 기능이 명확하게 구분되지 않습니다.

---

# 제안된 새로운 상태(Clawnet)

## 하나의 프로토콜, 두 가지 역할

역할 + 범위가 포함된 단일 WS 프로토콜입니다.

- **역할: 노드** (능력 호스트)
- **역할: 운영자** (제어 평면)
- 선택 과목 **범위** 운영자의 경우:
  - `operator.read` (상태 + 시청 중)
  - `operator.write` (에이전트 실행, 전송)
  - `operator.admin` (구성, 채널, 모델)

### 역할 행동

**마디**

- 기능을 등록할 수 있습니다(`caps`, `commands`, 권한).
- 받을 수 있다 `invoke` 명령(`system.run`, `camera.*`, `canvas.*`, `screen.record`, 등).
- 이벤트를 보낼 수 있습니다: `voice.transcript`, `agent.request`, `chat.subscribe`.
- config/models/channels/sessions/agent 제어 플레인 API를 호출할 수 없습니다.

**연산자**

- 범위별로 관리되는 전체 제어 평면 API입니다.
- 모든 승인을 받습니다.
- OS 작업을 직접 실행하지 않습니다. 노드로의 경로.

### 주요 규칙

역할은 장치별이 아닌 연결별입니다. 장치는 두 역할을 별도로 열 수 있습니다.

---

# 통합인증+페어링

## 클라이언트 신원

모든 클라이언트는 다음을 제공합니다.

- `deviceId` (안정적, 장치 키에서 파생됨)
- `displayName` (인간 이름).
- `role` + `scope` + `caps` + `commands`.

## 페어링 흐름(통합)

- 클라이언트가 인증되지 않은 상태로 연결되었습니다.
- 게이트웨이는 **페어링 요청** 그것을 위해 `deviceId`.
- 교환원은 프롬프트를 받습니다. 승인/거부합니다.
- 게이트웨이는 다음에 바인딩된 자격 증명을 발급합니다.
  - 기기 공개 키
  - 역할
  - 범위
  - 기능/명령
- 클라이언트는 토큰을 유지하고 인증된 후 다시 연결합니다.

## 기기 결합 인증(전달자 토큰 재생 방지)

선호: 장치 키 쌍.

- 장치는 키 쌍을 한 번 생성합니다.
- `deviceId = fingerprint(publicKey)`.
- 게이트웨이는 nonce를 보냅니다. 장치 표시; 게이트웨이가 확인합니다.
- 토큰은 문자열이 아닌 공개 키(소유 증명)로 발급됩니다.

대안:

- mTLS(클라이언트 인증서): 가장 강력하고 운영 복잡성이 더 높습니다.
- 단기 전달자 토큰은 임시 단계로만 수행됩니다(회전 + 조기 취소).

## 자동 승인(SSH 휴리스틱)

약한 연결을 피하기 위해 정확하게 정의하십시오. 다음 중 하나를 선호하세요:

- **로컬 전용**: 클라이언트가 루프백/Unix 소켓을 통해 연결할 때 자동 페어링됩니다.
- **SSH를 통한 챌린지**: 게이트웨이는 nonce를 발행합니다. 클라이언트는 SSH를 가져와 SSH를 증명합니다.
- **실제 존재 창**: 게이트웨이 호스트 UI에서 로컬 승인을 받은 후 짧은 기간(예: 10분) 동안 자동 페어링을 허용합니다.

항상 자동 승인을 기록하고 기록하세요.

---

# 어디서나 TLS(개발자 + 제품)

## 기존 브리지 TLS 재사용

현재 TLS 런타임 + 지문 고정 사용:

- `src/infra/bridge/server/tls.ts`
- 지문인식 로직 `src/node-host/bridge-client.ts`

## WS에 지원하세요

- WS 서버는 동일한 인증서/키 + 지문으로 TLS를 지원합니다.
- WS 클라이언트는 지문을 고정할 수 있습니다(선택 사항).
- Discovery는 모든 엔드포인트에 대해 TLS + 지문을 광고합니다.
  - 검색은 로케이터 힌트일 뿐입니다. 절대로 트러스트 앵커가 아닙니다.

## 왜

- 기밀성을 위해 SSH/Tailscale에 대한 의존도를 줄입니다.
- 기본적으로 원격 모바일 연결을 안전하게 만듭니다.

---

# 승인 재설계(중앙 집중식)

## 현재의

승인은 노드 호스트(mac 앱 노드 런타임)에서 발생합니다. 노드가 실행되는 곳에 프롬프트가 나타납니다.

## 제안됨

승인은 **게이트웨이 호스팅**, 운영자 클라이언트에 UI가 전달되었습니다.

### 새로운 흐름

1. 게이트웨이 수신 `system.run` 의도(에이전트).
2. 게이트웨이가 승인 레코드를 생성합니다. `approval.requested`.
3. 운영자 UI에 프롬프트가 표시됩니다.
4. 승인 결정이 게이트웨이로 전송됨: `approval.resolve`.
5. 승인되면 게이트웨이가 노드 명령을 호출합니다.
6. 노드 실행, 반환 `invoke-res`.

### 승인 의미 체계(강화)

- 모든 운영자에게 방송합니다. 활성 UI에만 모달이 표시됩니다(다른 UI에는 축배가 표시됨).
- 첫 번째 해결 방법이 승리합니다. 게이트웨이는 이미 해결된 후속 해결을 거부합니다.
- 기본 시간 초과: N초(예: 60초) 후 거부하고 이유를 기록합니다.
- 해결 방법에는 다음이 필요합니다. `operator.approvals` 범위.

## 이익

- 사용자가 있는 위치(mac/phone)에 프롬프트가 나타납니다.
- 원격 노드에 대한 일관된 승인.
- 노드 런타임은 헤드리스 상태로 유지됩니다. UI 종속성이 없습니다.

---

# 역할 명확성 예시

## 아이폰 앱

- **노드 역할** 대상: 마이크, 카메라, 음성 채팅, 위치, 눌러서 말하기.
- 선택 과목 **연산자.읽기** 상태 및 채팅 보기용.
- 선택 과목 **운영자.쓰기/관리자** 명시적으로 활성화된 경우에만.

## macOS 앱

- 기본적으로 운영자 역할(제어 UI).
- "Mac 노드"가 활성화된 경우 노드 역할(system.run, 화면, 카메라).
- 두 연결 모두에 대해 동일한 deviceId → 병합된 UI 항목.

## CLI

- 항상 운영자 역할.
- 하위 명령으로 파생된 범위:
  - `status`, `logs` → 읽다
  - `agent`, `message` → 쓰다
  - `config`, `channels` → 관리자
  - 승인 + 페어링 → `operator.approvals` / `operator.pairing`

---

# 아이덴티티 + 슬러그

## 안정적인 ID

인증에 필요합니다. 결코 변하지 않습니다.
우선의:

- 키 쌍 지문(공개 키 해시)입니다.

## 귀여운 민달팽이(랍스터 테마)

인간 라벨만 해당됩니다.

- 예: `scarlet-claw`, `saltwave`, `mantis-pinch`.
- 게이트웨이 레지스트리에 저장되며 편집 가능합니다.
- 충돌 처리: `-2`, `-3`.

## UI 그룹화

같은 `deviceId` 여러 역할 → 단일 "인스턴스" 행:

- 배지: `operator`, `node`.
- 기능 + 마지막으로 확인된 내용을 표시합니다.

---

# 마이그레이션 전략

## 0단계: 문서화 + 정렬

- 이 문서를 게시하세요.
- 모든 프로토콜 호출 + 승인 흐름을 조사합니다.

## 1단계: WS에 역할/범위 추가

- 연장하다 `connect` 매개변수 `role`, `scope`, `deviceId`.
- 노드 역할에 대한 허용 목록 게이팅을 추가합니다.

## 2단계: 브리지 호환성

- 브리지를 계속 운영하세요.
- WS 노드 지원을 병렬로 추가합니다.
- 구성 플래그 뒤에 있는 게이트 기능입니다.

## 3단계: 중앙 승인

- WS에서 승인 요청 추가 + 이벤트 해결.
- 메시지를 표시하고 응답하도록 Mac 앱 UI를 업데이트하세요.
- 노드 런타임이 UI 프롬프트를 중지합니다.

## 4단계: TLS 통합

- 브리지 TLS 런타임을 사용하여 WS용 TLS 구성을 추가합니다.
- 클라이언트에 고정을 추가합니다.

## 5단계: 브릿지 지원 중단

- iOS/Android/mac 노드를 WS로 마이그레이션합니다.
- 브리지를 대체 수단으로 유지합니다. 일단 안정되면 제거하십시오.

## 6단계: 기기 바인딩 인증

- 모든 비로컬 연결에는 키 기반 ID가 필요합니다.
- 해지 + 순환 UI를 추가합니다.

---

# 보안 참고 사항

- 게이트웨이 경계에 역할/허용 목록이 적용됩니다.
- 운영자 범위 없이는 어떤 클라이언트도 "전체" API를 얻지 못합니다.
- 페어링 필요 _모두_ 사이.
- TLS + 고정은 모바일의 MITM 위험을 줄입니다.
- SSH 자동 승인은 편리합니다. 여전히 녹음 + 취소 가능.
- 발견은 결코 트러스트 앵커가 아닙니다.
- 기능 요구 사항은 플랫폼/유형별로 서버 허용 목록을 기준으로 확인됩니다.

# 스트리밍 + 대규모 페이로드(노드 미디어)

WS 제어 평면은 작은 메시지에는 적합하지만 노드는 다음 작업도 수행합니다.

- 카메라 클립
- 화면 녹화
- 오디오 스트림

옵션:

1. WS 바이너리 프레임 + 청킹 + 배압 규칙.
2. 별도의 스트리밍 엔드포인트(여전히 TLS + 인증).
3. 미디어가 많은 명령에 대해서는 브리지를 더 오래 유지하고 마지막으로 마이그레이션하십시오.

드리프트를 방지하려면 구현 전에 하나를 선택하세요.

# 능력+지휘정책

- 노드 보고된 caps/명령은 다음과 같이 처리됩니다. **주장**.
- 게이트웨이는 플랫폼별 허용 목록을 시행합니다.
- 새로운 명령을 내리려면 운영자 승인이나 명시적인 허용 목록 변경이 필요합니다.
- 타임스탬프를 사용하여 변경 사항을 감사합니다.

# 감사 + 비율 제한

- 로그: 페어링 요청, 승인/거부, 토큰 발급/교체/해지.
- 스팸 및 승인 프롬프트를 결합하는 비율 제한.

# 프로토콜 위생

- 명시적인 프로토콜 버전 + 오류 코드.
- 규칙 + 하트비트 정책을 다시 연결합니다.
- 현재 상태 TTL 및 마지막으로 확인된 의미 체계.

---

# 공개 질문

1. 두 역할을 모두 실행하는 단일 장치: 토큰 모델
   - 역할(노드 대 운영자)별로 별도의 토큰을 권장합니다.
   - 동일한 장치 ID입니다. 다양한 범위; 더 명확한 취소.

2. 연산자 범위 세분성
   - 읽기/쓰기/관리 + 승인 + 페어링(최소 실행 가능).
   - 나중에 기능별 범위를 고려하세요.

3. 토큰 순환 + 철회 UX
   - 역할 변경 시 자동 순환됩니다.
   - deviceId + 역할로 취소할 UI입니다.

4. 발견
   - WS TLS 지문 + 역할 힌트를 포함하도록 현재 Bonjour TXT를 확장합니다.
   - 로케이터 힌트로만 처리됩니다.

5. 교차 네트워크 승인
   - 모든 운영자 클라이언트에 방송합니다. 활성 UI에는 모달이 표시됩니다.
   - 첫 번째 응답이 승리합니다. 게이트웨이는 원자성을 시행합니다.

---

# 요약(TL;DR)

- 현재: WS 제어 평면 + 브리지 노드 전송.
- 문제점: 승인 + 중복 + 스택 2개.
- 제안: 명시적인 역할 + 범위, 통합 페어링 + TLS 고정, 게이트웨이 호스팅 승인, 안정적인 장치 ID + 귀여운 슬러그가 포함된 하나의 WS 프로토콜.
- 결과: 더 단순한 UX, 더 강력한 보안, 더 적은 중복, 더 나은 모바일 라우팅.
