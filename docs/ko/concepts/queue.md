---
read_when:
    - 자동 응답 실행 또는 동시성 변경
summary: 인바운드 자동 응답 실행을 직렬화하는 명령 대기열 설계
title: 명령 대기열
x-i18n:
    generated_at: "2026-02-08T15:56:30Z"
    model: gtx
    provider: google-translate
    source_hash: 2104c24d200fb4f9620e52a19255cd614ababe19d78f3ee42936dc6d0499b73b
    source_path: concepts/queue.md
    workflow: 15
---

# 명령 대기열(2026-01-16)

여러 에이전트 실행이 충돌하는 것을 방지하는 동시에 세션 전체에서 안전한 병렬 처리를 허용하기 위해 작은 프로세스 내 대기열을 통해 인바운드 자동 응답 실행(모든 채널)을 직렬화합니다.

## 왜

- 자동 회신 실행은 비용이 많이 들 수 있으며(LLM 호출) 여러 인바운드 메시지가 가까이 도착하면 충돌할 수 있습니다.
- 직렬화는 공유 리소스(세션 파일, 로그, CLI 표준 입력)에 대한 경쟁을 방지하고 업스트림 속도 제한 가능성을 줄입니다.

## 작동 원리

- 레인 인식 FIFO 대기열은 구성 가능한 동시성 한도로 각 레인을 비웁니다(구성되지 않은 레인의 경우 기본값 1, 기본 기본값은 4, 하위 에이전트는 8).
- `runEmbeddedPiAgent` 대기열에 추가 **세션 키** (레인 `session:<key>`) 세션당 하나의 활성 실행만 보장합니다.
- 그런 다음 각 세션 실행이 대기열에 추가됩니다. **글로벌 레인** (`main` 기본적으로) 전체 병렬성은 다음으로 제한됩니다. `agents.defaults.maxConcurrent`.
- 자세한 로깅이 활성화되면 대기열에 있는 실행이 시작되기 전에 ~2초 이상 기다린 경우 짧은 알림을 보냅니다.
- 입력 표시기는 대기열에 추가될 때 즉시 실행되므로(채널에서 지원하는 경우) 차례를 기다리는 동안 사용자 경험은 변경되지 않습니다.

## 대기열 모드(채널당)

인바운드 메시지는 현재 실행을 조정하거나 후속 차례를 기다리거나 두 가지를 모두 수행할 수 있습니다.

- `steer`: 현재 실행에 즉시 삽입합니다(다음 도구 경계 이후 보류 중인 도구 호출을 취소합니다). 스트리밍하지 않는 경우 후속 조치로 돌아갑니다.
- `followup`: 현재 실행이 끝난 후 다음 에이전트 차례를 위해 대기열에 추가됩니다.
- `collect`: 대기 중인 모든 메시지를 하나의 그룹으로 통합합니다. **하나의** 후속 턴(기본값). 메시지가 다른 채널/스레드를 대상으로 하는 경우 라우팅을 유지하기 위해 개별적으로 드레이닝됩니다.
- `steer-backlog` (일명 `steer+backlog`): 지금 조종해 **그리고** 후속 턴을 위해 메시지를 보존하십시오.
- `interrupt` (레거시): 해당 세션에 대한 활성 실행을 중단한 다음 최신 메시지를 실행합니다.
- `queue` (레거시 별칭): 동일 `steer`.

조향 백로그는 조향 실행 후 후속 응답을 얻을 수 있음을 의미합니다.
스트리밍 표면은 중복된 것처럼 보일 수 있습니다. 선호하다 `collect`/`steer` 당신이 원한다면
인바운드 메시지당 하나의 응답.
보내다 `/queue collect` 독립 실행형 명령(세션별) 또는 세트 `messages.queue.byChannel.discord: "collect"`.

기본값(구성에서 설정되지 않은 경우):

- 모든 표면 → `collect`

다음을 통해 전역적으로 또는 채널별로 구성합니다. `messages.queue`:

```json5
{
  messages: {
    queue: {
      mode: "collect",
      debounceMs: 1000,
      cap: 20,
      drop: "summarize",
      byChannel: { discord: "collect" },
    },
  },
}
```

## 대기열 옵션

옵션이 적용됩니다 `followup`, `collect`, 그리고 `steer-backlog` (그리고 `steer` 후속 조치로 되돌아가는 경우):

- `debounceMs`: 후속 턴을 시작하기 전에 조용해질 때까지 기다립니다(“계속, 계속” 방지).
- `cap`: 세션당 대기 중인 최대 메시지 수입니다.
- `drop`: 오버플로 정책(`old`, `new`, `summarize`).

요약은 삭제된 메시지의 짧은 글머리 기호 목록을 유지하고 이를 종합 후속 프롬프트로 삽입합니다.
기본값: `debounceMs: 1000`, `cap: 20`, `drop: summarize`.

## 세션별 ​​재정의

- 보내다 `/queue <mode>` 현재 세션의 모드를 저장하는 독립형 명령으로.
- 옵션을 결합할 수 있습니다: `/queue collect debounce:2s cap:25 drop:summarize`
- `/queue default` 또는 `/queue reset` 세션 재정의를 지웁니다.

## 범위 및 보증

- 게이트웨이 응답 파이프라인(WhatsApp 웹, Telegram, Slack, Discord, Signal, iMessage, 웹 채팅 등)을 사용하는 모든 인바운드 채널에서 실행되는 자동 응답 에이전트에 적용됩니다.
- 기본 차선(`main`)는 인바운드 + 기본 하트비트에 대한 프로세스 전체입니다. 세트 `agents.defaults.maxConcurrent` 여러 세션을 병렬로 허용합니다.
- 추가 차선이 존재할 수 있습니다(예: `cron`, `subagent`) 따라서 인바운드 응답을 차단하지 않고 백그라운드 작업을 병렬로 실행할 수 있습니다.
- 세션별 ​​레인은 한 번에 하나의 에이전트 실행만 지정된 세션에 닿도록 보장합니다.
- 외부 종속성이나 백그라운드 작업자 스레드가 없습니다. 순수 TypeScript + 약속.

## 문제 해결

- 명령이 중단된 것 같으면 자세한 로그를 활성화하고 "queued for ...ms" 줄을 찾아 대기열이 소모되고 있는지 확인하세요.
- 대기열 깊이가 필요한 경우 자세한 로그를 활성화하고 대기열 타이밍 라인을 살펴보세요.
