---
read_when:
    - 아웃바운드 채널에 대한 마크다운 형식 또는 청크를 변경하고 있습니다.
    - 새로운 채널 포맷터 또는 스타일 매핑을 추가하고 있습니다.
    - 채널 전반에 걸쳐 서식 회귀를 디버깅하고 있습니다.
summary: 아웃바운드 채널을 위한 마크다운 형식 지정 파이프라인
title: 마크다운 형식
x-i18n:
    generated_at: "2026-02-08T15:51:17Z"
    model: gtx
    provider: google-translate
    source_hash: f9cbf9b744f9a218860730f29435bcad02d3db80b1847fed5f17c063c97d4820
    source_path: concepts/markdown-formatting.md
    workflow: 15
---

# 마크다운 형식

OpenClaw는 아웃바운드 마크다운을 공유 중간체로 변환하여 형식화합니다.
채널별 출력을 렌더링하기 전의 표현(IR)입니다. IR은 다음을 유지합니다.
스타일/링크 범위를 전달하는 동안 원본 텍스트는 그대로 유지되므로 청크 및 렌더링이 가능합니다.
여러 채널에서 일관성을 유지하세요.

## 목표

- **일관성:** 하나의 구문 분석 단계, 여러 렌더러.
- **안전한 청킹:** 렌더링하기 전에 텍스트를 분할하므로 인라인 서식은 절대 사용되지 않습니다.
  덩어리로 나누어집니다.
- **채널 적합성:** 동일한 IR을 Slack mrkdwn, Telegram HTML 및 Signal에 매핑
  Markdown을 다시 구문 분석하지 않고 스타일 범위를 지정합니다.

## 관로

1. **마크다운 구문 분석 -> IR**
   - IR은 일반 텍스트에 스타일 범위(굵게/기울임꼴/스트라이크/코드/스포일러) 및 링크 범위를 더한 것입니다.
   - 오프셋은 UTF-16 코드 단위이므로 신호 스타일 범위가 해당 API와 일치합니다.
   - 채널이 테이블 변환을 선택한 경우에만 테이블이 구문 분석됩니다.
2. **청크 IR(형식 우선)**
   - 청킹은 렌더링 전에 IR 텍스트에서 발생합니다.
   - 인라인 형식은 여러 청크로 분할되지 않습니다. 스팬은 청크별로 슬라이스됩니다.
3. **채널당 렌더링**
   - **느슨하게:** mrkdwn 토큰(굵게/기울임꼴/strike/코드), 다음과 같은 링크 `<url|label>`.
   - **전보:** HTML 태그(`<b>`, `<i>`, `<s>`, `<code>`, `<pre><code>`, `<a href>`).
   - **신호:** 일반 텍스트 + `text-style` 범위; 링크는 `label (url)` 라벨이 다를 때.

## IR 예시

입력 마크다운:

```markdown
Hello **world** — see [docs](https://docs.openclaw.ai).
```

IR(개략도):

```json
{
  "text": "Hello world — see docs.",
  "styles": [{ "start": 6, "end": 11, "style": "bold" }],
  "links": [{ "start": 19, "end": 23, "href": "https://docs.openclaw.ai" }]
}
```

## 사용되는 곳

- Slack, Telegram 및 Signal 아웃바운드 어댑터는 IR에서 렌더링됩니다.
- 다른 채널(WhatsApp, iMessage, MS Teams, Discord)은 여전히 일반 텍스트 또는
  이전에 Markdown 테이블 변환이 적용된 자체 서식 규칙
  활성화된 경우 청킹.

## 테이블 핸들링

마크다운 테이블은 채팅 클라이언트 전체에서 일관되게 지원되지 않습니다. 사용
`markdown.tables` 채널별(및 계정별) 전환을 제어합니다.

- `code`: 테이블을 코드 블록으로 렌더링합니다(대부분의 채널에 대한 기본값).
- `bullets`: 각 행을 글머리 기호로 변환합니다(Signal + WhatsApp의 경우 기본값).
- `off`: 테이블 구문 분석 및 변환을 비활성화합니다. 원시 테이블 텍스트가 통과됩니다.

구성 키:

```yaml
channels:
  discord:
    markdown:
      tables: code
    accounts:
      work:
        markdown:
          tables: off
```

## 청킹 규칙

- 청크 제한은 채널 어댑터/구성에서 제공되며 IR 텍스트에 적용됩니다.
- 코드 펜스는 후행 개행 문자가 있는 단일 블록으로 유지되므로 채널
  올바르게 렌더링하십시오.
- 목록 접두사 및 블록 인용 접두사는 IR 텍스트의 일부이므로 청킹
  중간 접두사를 분할하지 않습니다.
- 인라인 스타일(굵게/기울임꼴/스트라이크/인라인 코드/스포일러)은 절대로 분할되지 않습니다.
  덩어리; 렌더러는 각 청크 내부의 스타일을 다시 엽니다.

채널 간 청크 동작에 대한 자세한 내용은 다음을 참조하세요.
[스트리밍 + 청킹](/concepts/streaming).

## 링크 정책

- **느슨하게:** `[label](url)` -> `<url|label>`; 베어 URL은 베어 남아 있습니다. 자동링크
  이중 연결을 방지하기 위해 구문 분석 중에는 비활성화됩니다.
- **전보:** `[label](url)` -> `<a href="url">label</a>` (HTML 구문 분석 모드).
- **신호:** `[label](url)` -> `label (url)` 라벨이 URL과 일치하지 않는 한.

## 스포일러

스포일러 마커(`||spoiler||`)은 Signal에 대해서만 구문 분석되며, 여기서는 다음과 매핑됩니다.
스포일러 스타일 범위. 다른 채널에서는 이를 일반 텍스트로 처리합니다.

## 채널 포맷터를 추가하거나 업데이트하는 방법

1. **한 번만 구문 분석하세요.** 공유를 사용 `markdownToIR(...)` 채널에 맞는 도우미
   옵션(자동링크, 제목 스타일, 인용부호 접두어).
2. **세우다:** 렌더러를 구현합니다. `renderMarkdownWithMarkers(...)` 그리고
   스타일 마커 맵(또는 신호 스타일 범위).
3. **큰 덩어리:** 부르다 `chunkMarkdownIR(...)` 렌더링하기 전에; 각 청크를 렌더링합니다.
4. **와이어 어댑터:** 새 청커를 사용하도록 채널 아웃바운드 어댑터 업데이트
   그리고 렌더러.
5. **시험:** 형식 테스트와 아웃바운드 전달 테스트를 추가하거나 업데이트합니다.
   채널은 청킹을 사용합니다.

## 일반적인 문제점

- Slack 꺾쇠 괄호 토큰(`<@U123>`, `<#C123>`, `<https://...>`) 이어야 합니다
  보존; 원시 HTML을 안전하게 탈출하세요.
- 텔레그램 HTML에서는 마크업 손상을 방지하기 위해 태그 외부의 텍스트를 이스케이프 처리해야 합니다.
- 신호 스타일 범위는 UTF-16 오프셋에 따라 다릅니다. 코드 포인트 오프셋을 사용하지 마십시오.
- 울타리로 둘러싸인 코드 블록에 대한 후행 줄 바꿈을 유지하여 닫는 마커가 표시되도록 합니다.
  그들만의 라인.
