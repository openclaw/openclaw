---
summary: "Clawnet ریفیکٹر: نیٹ ورک پروٹوکول، کردار، تصدیق، منظوریوں اور شناخت کا یکجا کرنا"
read_when:
  - نوڈز اور آپریٹر کلائنٹس کے لیے یکساں نیٹ ورک پروٹوکول کی منصوبہ بندی کرتے وقت
  - منظوریوں، جوڑی بنانے، TLS، اور آلات کے درمیان موجودگی کی ازسرِنو تشکیل کے دوران
title: "Clawnet ریفیکٹر"
---

# Clawnet ریفیکٹر (پروٹوکول + تصدیق کا یکجا ہونا)

## Hi

ہیلو پیٹر — بہترین سمت؛ اس سے زیادہ سادہ UX اور مضبوط سکیورٹی ممکن ہوتی ہے۔

## Purpose

ایک واحد، جامع دستاویز برائے:

- موجودہ حالت: پروٹوکولز، فلو، اعتماد کی حدود۔
- مسائل: منظوریوں، ملٹی ہاپ روٹنگ، UI کی دوہری ساخت۔
- مجوزہ نئی حالت: ایک پروٹوکول، محدود کردار، یکجا تصدیق/جوڑی بنانا، TLS پننگ۔
- شناخت ماڈل: مستحکم IDs + دلکش سلگز۔
- مائیگریشن پلان، خطرات، کھلے سوالات۔

## Goals (from discussion)

- تمام کلائنٹس کے لیے ایک پروٹوکول (mac ایپ، CLI، iOS، Android، ہیڈلیس نوڈ)۔
- ہر نیٹ ورک شریک کی تصدیق اور جوڑی بنانا۔
- کرداروں کی وضاحت: نوڈز بمقابلہ آپریٹرز۔
- مرکزی منظوریوں کو وہاں روٹ کرنا جہاں صارف موجود ہو۔
- تمام ریموٹ ٹریفک کے لیے TLS انکرپشن + اختیاری پننگ۔
- کم سے کم کوڈ کی نقل۔
- ایک ہی مشین ایک ہی بار نظر آئے (کوئی UI/نوڈ کی دوہری اندراج نہیں)۔

## Non‑goals (explicit)

- صلاحیتوں کی علیحدگی ختم کرنا (کم سے کم اختیارات بدستور ضروری ہیں)۔
- اسکوپ چیکس کے بغیر مکمل گیٹ وے کنٹرول پلین کو بے نقاب کرنا۔
- تصدیق کو انسانی لیبلز پر منحصر بنانا (سلگز سکیورٹی کے لیے نہیں رہیں گے)۔

---

# Current state (as‑is)

## Two protocols

### 1. Gateway WebSocket (control plane)

- مکمل API سطح: کنفیگ، چینلز، ماڈلز، سیشنز، ایجنٹ رنز، لاگز، نوڈز، وغیرہ۔
- ڈیفالٹ bind: loopback. SSH/Tailscale کے ذریعے ریموٹ رسائی۔
- تصدیق: ٹوکن/پاس ورڈ بذریعہ `connect`۔
- TLS پننگ نہیں (لوپ بیک/ٹنل پر انحصار)۔
- کوڈ:
  - `src/gateway/server/ws-connection/message-handler.ts`
  - `src/gateway/client.ts`
  - `docs/gateway/protocol.md`

### 2. Bridge (node transport)

- محدود اجازت فہرست کی سطح، نوڈ شناخت + جوڑی بنانا۔
- JSONL اوور TCP؛ اختیاری TLS + سرٹیفکیٹ فنگرپرنٹ پننگ۔
- TLS ڈسکوری TXT میں فنگرپرنٹ کا اعلان کرتا ہے۔
- کوڈ:
  - `src/infra/bridge/server/connection.ts`
  - `src/gateway/server-bridge.ts`
  - `src/node-host/bridge-client.ts`
  - `docs/gateway/bridge-protocol.md`

## Control plane clients today

- CLI → Gateway WS بذریعہ `callGateway` (`src/gateway/call.ts`)۔
- macOS ایپ UI → Gateway WS (`GatewayConnection`)۔
- ویب کنٹرول UI → Gateway WS۔
- ACP → Gateway WS۔
- براؤزر کنٹرول اپنا HTTP کنٹرول سرور استعمال کرتا ہے۔

## Nodes today

- macOS ایپ نوڈ موڈ میں Gateway bridge سے جڑتی ہے (`MacNodeBridgeSession`)۔
- iOS/Android ایپس Gateway bridge سے جڑتی ہیں۔
- جوڑی بنانا + ہر نوڈ کا ٹوکن گیٹ وے پر محفوظ ہوتا ہے۔

## Current approval flow (exec)

- ایجنٹ `system.run` کو Gateway کے ذریعے استعمال کرتا ہے۔
- Gateway پل کے ذریعے نوڈ کو کال کرتا ہے۔
- نوڈ رن ٹائم منظوری کا فیصلہ کرتا ہے۔
- UI پرامپٹ mac ایپ دکھاتی ہے (جب نوڈ == mac ایپ)۔
- نوڈ `invoke-res` کو Gateway کو واپس بھیجتا ہے۔
- ملٹی ہاپ، UI نوڈ ہوسٹ سے منسلک۔

## Presence + identity today

- Gateway کی موجودگی WS کلائنٹس سے۔
- نوڈ کی موجودگی پل سے۔
- mac ایپ ایک ہی مشین کے لیے دو اندراجات دکھا سکتی ہے (UI + نوڈ)۔
- نوڈ شناخت جوڑی اسٹور میں؛ UI شناخت الگ۔

---

# Problems / pain points

- دو پروٹوکول اسٹیکس کی دیکھ بھال (WS + Bridge)۔
- ریموٹ نوڈز پر منظوری: پرامپٹ نوڈ ہوسٹ پر آتا ہے، جہاں صارف نہیں۔
- TLS پننگ صرف پل میں؛ WS SSH/Tailscale پر انحصار کرتا ہے۔
- شناخت کی نقل: ایک ہی مشین متعدد مثالوں کے طور پر نظر آتی ہے۔
- مبہم کردار: UI + نوڈ + CLI کی صلاحیتیں واضح طور پر جدا نہیں۔

---

# Proposed new state (Clawnet)

## One protocol, two roles

ایک WS پروٹوکول جس میں کردار + اسکوپ ہو۔

- **Role: node** (صلاحیت ہوسٹ)
- **Role: operator** (کنٹرول پلین)
- آپریٹر کے لیے اختیاری **scope**:
  - `operator.read` (اسٹیٹس + دیکھنا)
  - `operator.write` (ایجنٹ رن، ارسال)
  - `operator.admin` (کنفیگ، چینلز، ماڈلز)

### Role behaviors

**Node**

- صلاحیتیں رجسٹر کر سکتا ہے (`caps`, `commands`, اجازتیں)۔
- `invoke` کمانڈز وصول کر سکتا ہے (`system.run`, `camera.*`, `canvas.*`, `screen.record`, وغیرہ)۔
- ایونٹس بھیج سکتا ہے: `voice.transcript`, `agent.request`, `chat.subscribe`۔
- کنفیگ/ماڈلز/چینلز/سیشنز/ایجنٹ کنٹرول پلین APIs کو کال نہیں کر سکتا۔

**Operator**

- مکمل کنٹرول پلین API، اسکوپ کے ذریعے محدود۔
- تمام منظوریوں کو وصول کرتا ہے۔
- براہِ راست OS ایکشنز انجام نہیں دیتا؛ نوڈز کی طرف روٹ کرتا ہے۔

### Key rule

رول فی کنکشن ہوتا ہے، فی ڈیوائس نہیں۔ ایک ڈیوائس الگ الگ طور پر دونوں رولز کھول سکتی ہے۔

---

# Unified authentication + pairing

## Client identity

ہر کلائنٹ فراہم کرتا ہے:

- `deviceId` (مستحکم، ڈیوائس کی سے اخذ کردہ)۔
- `displayName` (انسانی نام)۔
- `role` + `scope` + `caps` + `commands`۔

## Pairing flow (unified)

- کلائنٹ بغیر تصدیق کے جڑتا ہے۔
- Gateway اس `deviceId` کے لیے **pairing request** بناتا ہے۔
- آپریٹر پرامپٹ وصول کرتا ہے؛ منظور/مسترد کرتا ہے۔
- Gateway اسناد جاری کرتا ہے جو منسلک ہوتی ہیں:
  - ڈیوائس پبلک کی
  - کردار(کردار)
  - اسکوپ(اسکوپس)
  - صلاحیتیں/کمانڈز
- کلائنٹ ٹوکن محفوظ کرتا ہے، تصدیق شدہ حالت میں دوبارہ جڑتا ہے۔

## Device‑bound auth (avoid bearer token replay)

ترجیح: ڈیوائس کی پیئرز۔

- ڈیوائس ایک بار کی پیئر بناتی ہے۔
- `deviceId = fingerprint(publicKey)`۔
- Gateway نانس بھیجتا ہے؛ ڈیوائس سائن کرتی ہے؛ گیٹ وے تصدیق کرتا ہے۔
- ٹوکن پبلک کی کے لیے جاری ہوتے ہیں (proof‑of‑possession)، محض اسٹرنگ نہیں۔

متبادل:

- mTLS (کلائنٹ سرٹس): سب سے مضبوط، مگر آپریشنل پیچیدگی زیادہ۔
- مختصر مدت کے bearer ٹوکن صرف عارضی مرحلے کے طور پر (جلد گردش + منسوخی)۔

## Silent approval (SSH heuristic)

کمزور کڑی سے بچنے کے لیے اسے بالکل درست طور پر متعین کریں۔ ایک کو ترجیح دیں:

- **Local‑only**: جب کلائنٹ لوپ بیک/یونکس ساکٹ کے ذریعے جڑے تو خودکار جوڑی۔
- **Challenge via SSH**: Gateway نانس جاری کرے؛ کلائنٹ SSH کے ذریعے اسے حاصل کر کے ثبوت دے۔
- **Physical presence window**: Gateway ہوسٹ UI پر مقامی منظوری کے بعد مختصر مدت (مثلاً 10 منٹ) کے لیے خودکار جوڑی کی اجازت۔

ہمیشہ لاگ کریں + خودکار منظوریوں کو ریکارڈ کریں۔

---

# TLS everywhere (dev + prod)

## Reuse existing bridge TLS

موجودہ TLS رن ٹائم + فنگرپرنٹ پننگ استعمال کریں:

- `src/infra/bridge/server/tls.ts`
- فنگرپرنٹ تصدیقی منطق `src/node-host/bridge-client.ts` میں

## Apply to WS

- WS سرور وہی سرٹ/کی + فنگرپرنٹ کے ساتھ TLS سپورٹ کرے۔
- WS کلائنٹس فنگرپرنٹ پن کر سکیں (اختیاری)۔
- ڈسکوری تمام اینڈپوائنٹس کے لیے TLS + فنگرپرنٹ کا اعلان کرے۔
  - ڈسکوری صرف لوکیٹر اشارے ہیں؛ کبھی بھی ٹرسٹ اینکر نہیں۔

## Why

- رازداری کے لیے SSH/Tailscale پر انحصار کم کرنا۔
- ریموٹ موبائل کنیکشنز کو بطورِ طے شدہ محفوظ بنانا۔

---

# Approvals redesign (centralized)

## Current

منظوری نوڈ ہوسٹ پر ہوتی ہے (mac app node runtime)۔ پرومپٹ وہیں ظاہر ہوتا ہے جہاں نوڈ چل رہا ہوتا ہے۔

## Proposed

منظوری **Gateway‑hosted** ہو، UI آپریٹر کلائنٹس تک پہنچے۔

### New flow

1. Gateway `system.run` انٹینٹ وصول کرتا ہے (ایجنٹ)۔
2. Gateway منظوری ریکارڈ بناتا ہے: `approval.requested`۔
3. آپریٹر UI(s) پر پرامپٹ دکھایا جاتا ہے۔
4. منظوری کا فیصلہ Gateway کو بھیجا جاتا ہے: `approval.resolve`۔
5. منظوری کی صورت میں Gateway نوڈ کمانڈ چلاتا ہے۔
6. نوڈ عملدرآمد کرتا ہے، `invoke-res` واپس بھیجتا ہے۔

### Approval semantics (hardening)

- تمام آپریٹرز کو براڈکاسٹ؛ صرف فعال UI موڈل دکھائے (دیگر کو ٹوسٹ)۔
- پہلی ریزولوشن مؤثر؛ بعد کی کوششیں Gateway مسترد کرے (پہلے ہی طے شدہ)۔
- ڈیفالٹ ٹائم آؤٹ: N سیکنڈ بعد انکار (مثلاً 60s)، وجہ لاگ کریں۔
- ریزولوشن کے لیے `operator.approvals` اسکوپ درکار۔

## Benefits

- پرامپٹ وہاں ظاہر ہوتا ہے جہاں صارف ہو (mac/فون)۔
- ریموٹ نوڈز کے لیے یکساں منظوری۔
- نوڈ رن ٹائم ہیڈلیس رہتا ہے؛ UI پر انحصار نہیں۔

---

# Role clarity examples

## iPhone app

- **Node role** برائے: مائیک، کیمرہ، وائس چیٹ، لوکیشن، پُش‑ٹو‑ٹاک۔
- اختیاری **operator.read** برائے اسٹیٹس اور چیٹ ویو۔
- اختیاری **operator.write/admin** صرف واضح طور پر فعال کرنے پر۔

## macOS app

- ڈیفالٹ طور پر آپریٹر رول (کنٹرول UI)۔
- “Mac node” فعال ہونے پر نوڈ رول (system.run، اسکرین، کیمرہ)۔
- دونوں کنکشنز کے لیے ایک ہی deviceId → یکجا UI اندراج۔

## CLI

- ہمیشہ آپریٹر رول۔
- اسکوپ سب کمانڈ سے اخذ:
  - `status`, `logs` → read
  - `agent`, `message` → write
  - `config`, `channels` → admin
  - approvals + pairing → `operator.approvals` / `operator.pairing`

---

# Identity + slugs

## Stable ID

تصدیق کے لیے درکار؛ کبھی تبدیل نہیں ہوتا۔
ترجیحی:

- کی پیئر فنگرپرنٹ (پبلک کی ہیش)۔

## Cute slug (lobster‑themed)

صرف انسانی لیبل۔

- مثال: `scarlet-claw`, `saltwave`, `mantis-pinch`۔
- Gateway رجسٹری میں محفوظ، قابلِ ترمیم۔
- ٹکراؤ کا حل: `-2`, `-3`۔

## UI grouping

ایک ہی `deviceId` مختلف کرداروں میں → ایک “Instance” قطار:

- بیج: `operator`, `node`۔
- صلاحیتیں + آخری بار دیکھا گیا دکھاتا ہے۔

---

# Migration strategy

## Phase 0: Document + align

- یہ دستاویز شائع کریں۔
- تمام پروٹوکول کالز + منظوری فلو کی فہرست بنائیں۔

## Phase 1: Add roles/scopes to WS

- `connect` پیرا میٹرز میں `role`, `scope`, `deviceId` شامل کریں۔
- نوڈ رول کے لیے اجازت فہرست گیٹنگ شامل کریں۔

## Phase 2: Bridge compatibility

- پل چلتا رکھیں۔
- متوازی طور پر WS نوڈ سپورٹ شامل کریں۔
- فیچرز کو کنفیگ فلیگ کے پیچھے رکھیں۔

## Phase 3: Central approvals

- WS میں منظوری درخواست + حل ایونٹس شامل کریں۔
- mac ایپ UI کو پرامپٹ + جواب کے لیے اپڈیٹ کریں۔
- نوڈ رن ٹائم UI پرامپٹنگ بند کرے۔

## Phase 4: TLS unification

- پل TLS رن ٹائم استعمال کرتے ہوئے WS کے لیے TLS کنفیگ شامل کریں۔
- کلائنٹس میں پننگ شامل کریں۔

## Phase 5: Deprecate bridge

- iOS/Android/mac نوڈ کو WS پر منتقل کریں۔
- پل کو بطور فال بیک رکھیں؛ مستحکم ہونے پر ہٹا دیں۔

## Phase 6: Device‑bound auth

- تمام غیر مقامی کنیکشنز کے لیے کی‑بیسڈ شناخت لازم کریں۔
- منسوخی + گردش UI شامل کریں۔

---

# Security notes

- کردار/اجازت فہرست گیٹ وے حد پر نافذ۔
- آپریٹر اسکوپ کے بغیر کسی کلائنٹ کو “مکمل” API نہیں ملتا۔
- _تمام_ کنیکشنز کے لیے جوڑی بنانا لازم۔
- TLS + پننگ موبائل کے لیے MITM خطرہ کم کرتے ہیں۔
- SSH silent approval سہولت ہے؛ پھر بھی ریکارڈ + منسوخ کے قابل۔
- ڈسکوری کبھی بھی ٹرسٹ اینکر نہیں۔
- صلاحیت کے دعوے پلیٹ فارم/قسم کے مطابق سرور اجازت فہرست کے خلاف تصدیق ہوتے ہیں۔

# Streaming + large payloads (node media)

WS کنٹرول پلین چھوٹے پیغامات کے لیے موزوں ہے، مگر نوڈز یہ بھی کرتے ہیں:

- کیمرہ کلپس
- اسکرین ریکارڈنگز
- آڈیو اسٹریمز

اختیارات:

1. WS بائنری فریمز + چنکنگ + بیک پریشر قواعد۔
2. علیحدہ اسٹریمنگ اینڈپوائنٹ (اب بھی TLS + تصدیق)۔
3. میڈیا‑بھاری کمانڈز کے لیے پل زیادہ دیر رکھیں، آخر میں مائیگریٹ کریں۔

عملدرآمد سے پہلے ایک کا انتخاب کریں تاکہ ڈرفٹ سے بچا جا سکے۔

# Capability + command policy

- نوڈ کی رپورٹ کردہ صلاحیتیں/کمانڈز **دعویٰ** سمجھی جاتی ہیں۔
- Gateway فی‑پلیٹ فارم اجازت فہرست نافذ کرتا ہے۔
- کسی بھی نئی کمانڈ کے لیے آپریٹر منظوری یا واضح اجازت فہرست تبدیلی درکار۔
- تبدیلیوں کا آڈٹ ٹائم اسٹیمپس کے ساتھ کریں۔

# Audit + rate limiting

- لاگ کریں: جوڑی درخواستیں، منظوری/انکار، ٹوکن اجرا/گردش/منسوخی۔
- جوڑی اسپام اور منظوری پرامپٹس پر ریٹ لمٹنگ۔

# Protocol hygiene

- واضح پروٹوکول ورژن + ایرر کوڈز۔
- ری کنیکٹ قواعد + ہارٹ بیٹ پالیسی۔
- موجودگی TTL اور آخری‑دیکھا گیا معنویت۔

---

# Open questions

1. ایک ہی ڈیوائس پر دونوں کردار: ٹوکن ماڈل
   - ہر کردار کے لیے علیحدہ ٹوکن کی سفارش (نوڈ بمقابلہ آپریٹر)۔
   - ایک ہی deviceId؛ مختلف اسکوپس؛ واضح منسوخی۔

2. آپریٹر اسکوپ کی باریکی
   - read/write/admin + approvals + pairing (کم از کم قابلِ عمل)۔
   - بعد میں فیچر‑سطح کے اسکوپس پر غور کریں۔

3. ٹوکن گردش + منسوخی UX
   - کردار تبدیلی پر خودکار گردش۔
   - deviceId + کردار کے مطابق منسوخی UI۔

4. Discovery
   - موجودہ Bonjour TXT کو WS TLS فنگرپرنٹ + کردار اشاروں کے ساتھ بڑھائیں۔
   - صرف لوکیٹر اشارے سمجھیں۔

5. Cross‑network approval
   - تمام آپریٹر کلائنٹس کو براڈکاسٹ؛ فعال UI موڈل دکھائے۔
   - پہلی ردِعمل مؤثر؛ Gateway ایٹامیسٹی نافذ کرے۔

---

# Summary (TL;DR)

- آج: WS کنٹرول پلین + Bridge نوڈ ٹرانسپورٹ۔
- مسائل: منظوریوں کی پیچیدگی + نقل + دو اسٹیکس۔
- تجویز: ایک WS پروٹوکول واضح کرداروں + اسکوپس کے ساتھ، یکجا جوڑی بنانا + TLS پننگ، گیٹ وے‑ہوسٹڈ منظوریوں، مستحکم ڈیوائس IDs + دلکش سلگز۔
- نتیجہ: سادہ UX، مضبوط سکیورٹی، کم نقل، بہتر موبائل روٹنگ۔
