---
summary: "کمانڈ قطار کا ڈیزائن جو اندر آنے والی آٹو-ریپلائی رنز کو سلسلہ وار بناتا ہے"
read_when:
  - آٹو-ریپلائی کی عمل آوری یا ہم وقتیّت میں تبدیلی
title: "کمانڈ قطار"
x-i18n:
  source_path: concepts/queue.md
  source_hash: 2104c24d200fb4f9
  provider: openai
  model: gpt-5.2-chat-latest
  workflow: v1
  generated_at: 2026-02-08T10:47:19Z
---

# Command Queue (2026-01-16)

ہم اندر آنے والی آٹو-ریپلائی رنز (تمام چینلز) کو ایک چھوٹی اِن-پروسیس قطار کے ذریعے سلسلہ وار بناتے ہیں تاکہ متعدد ایجنٹ رنز کے باہمی تصادم سے بچا جا سکے، جبکہ سیشنز کے درمیان محفوظ متوازی عمل بھی برقرار رہے۔

## Why

- آٹو-ریپلائی رنز مہنگی ہو سکتی ہیں (LLM کالز) اور جب متعدد اندر آنے والے پیغامات قریب قریب وقت میں پہنچیں تو ٹکرا سکتی ہیں۔
- سلسلہ وار بنانا مشترکہ وسائل (سیشن فائلیں، لاگز، CLI stdin) کے لیے مقابلہ کم کرتا ہے اور اپ اسٹریم ریٹ لمٹس کے امکانات گھٹاتا ہے۔

## How it works

- لین سے باخبر FIFO قطار ہر لین کو قابلِ کنفیگ ہم وقتی حد کے ساتھ خالی کرتی ہے (غیر کنفیگر شدہ لینز کے لیے بطورِ طے شدہ 1؛ main بطورِ طے شدہ 4، subagent کے لیے 8)۔
- `runEmbeddedPiAgent` **سیشن کلید** (لین `session:<key>`) کے ذریعے قطار میں ڈالتا ہے تاکہ فی سیشن صرف ایک فعال رن کی ضمانت ہو۔
- پھر ہر سیشن رن کو ایک **عالمی لین** (بطورِ طے شدہ `main`) میں قطار بند کیا جاتا ہے تاکہ مجموعی متوازی عمل `agents.defaults.maxConcurrent` کے ذریعے محدود رہے۔
- جب verbose لاگنگ فعال ہو، تو قطار میں موجود رنز اگر شروع ہونے سے پہلے ~2s سے زیادہ انتظار کریں تو ایک مختصر نوٹس خارج کرتے ہیں۔
- ٹائپنگ اشارے قطار میں ڈالنے پر فوراً فائر ہو جاتے ہیں (جب چینل سپورٹ کرے)، اس طرح باری کے انتظار کے دوران صارف تجربہ برقرار رہتا ہے۔

## Queue modes (per channel)

اندر آنے والے پیغامات موجودہ رن کو steer کر سکتے ہیں، فالو اپ ٹرن کا انتظار کر سکتے ہیں، یا دونوں کر سکتے ہیں:

- `steer`: فوراً موجودہ رن میں داخل کریں (اگلی ٹول باؤنڈری کے بعد زیرِ التواء ٹول کالز منسوخ ہو جاتی ہیں)۔ اگر اسٹریمنگ نہیں ہے تو فالو اپ پر واپس جاتا ہے۔
- `followup`: موجودہ رن کے ختم ہونے کے بعد اگلے ایجنٹ ٹرن کے لیے قطار میں ڈالیں۔
- `collect`: تمام قطار بند پیغامات کو **ایک ہی** فالو اپ ٹرن میں ضم کریں (بطورِ طے شدہ)۔ اگر پیغامات مختلف چینلز/تھریڈز کو ہدف بنائیں تو روٹنگ برقرار رکھنے کے لیے وہ الگ الگ خالی ہوتے ہیں۔
- `steer-backlog` (عرف `steer+backlog`): ابھی steer کریں **اور** پیغام کو فالو اپ ٹرن کے لیے محفوظ رکھیں۔
- `interrupt` (legacy): اس سیشن کے لیے فعال رن کو منسوخ کریں، پھر تازہ ترین پیغام چلائیں۔
- `queue` (legacy alias): `steer` جیسا ہی۔

Steer-backlog کا مطلب یہ ہے کہ steered رن کے بعد آپ کو فالو اپ جواب مل سکتا ہے، اس لیے
اسٹریمنگ سرفیسز پر جوابات نقل جیسے نظر آ سکتے ہیں۔ اگر آپ ہر اندر آنے والے پیغام کے لیے
ایک ہی جواب چاہتے ہیں تو `collect`/`steer` کو ترجیح دیں۔
`/queue collect` کو بطورِ واحد کمانڈ (فی سیشن) بھیجیں یا `messages.queue.byChannel.discord: "collect"` سیٹ کریں۔

Defaults (جب کنفیگ میں سیٹ نہ ہوں):

- تمام سرفیسز → `collect`

`messages.queue` کے ذریعے عالمی یا فی چینل کنفیگر کریں:

```json5
{
  messages: {
    queue: {
      mode: "collect",
      debounceMs: 1000,
      cap: 20,
      drop: "summarize",
      byChannel: { discord: "collect" },
    },
  },
}
```

## Queue options

اختیارات `followup`، `collect`، اور `steer-backlog` پر لاگو ہوتے ہیں (اور `steer` پر بھی جب وہ فالو اپ پر واپس جائے):

- `debounceMs`: فالو اپ ٹرن شروع کرنے سے پہلے خاموشی کا انتظار کریں ( “continue, continue” سے بچاتا ہے)۔
- `cap`: فی سیشن زیادہ سے زیادہ قطار بند پیغامات۔
- `drop`: اوورفلو پالیسی (`old`، `new`، `summarize`)۔

Summarize گرے ہوئے پیغامات کی ایک مختصر بُلٹ فہرست رکھتا ہے اور اسے مصنوعی فالو اپ پرامپٹ کے طور پر داخل کرتا ہے۔
Defaults: `debounceMs: 1000`، `cap: 20`، `drop: summarize`۔

## Per-session overrides

- موجودہ سیشن کے لیے موڈ محفوظ کرنے کو `/queue <mode>` بطورِ واحد کمانڈ بھیجیں۔
- اختیارات یکجا کیے جا سکتے ہیں: `/queue collect debounce:2s cap:25 drop:summarize`
- `/queue default` یا `/queue reset` سیشن اووررائیڈ صاف کر دیتا ہے۔

## Scope and guarantees

- گیٹ وے ریپلائی پائپ لائن استعمال کرنے والے تمام اندر آنے والے چینلز پر آٹو-ریپلائی ایجنٹ رنز پر لاگو ہوتا ہے (WhatsApp web، Telegram، Slack، Discord، Signal، iMessage، webchat، وغیرہ)۔
- بطورِ طے شدہ لین (`main`) اندر آنے والے + main ہارٹ بیٹس کے لیے پروسیس-وائیڈ ہے؛ متعدد سیشنز کو متوازی اجازت دینے کے لیے `agents.defaults.maxConcurrent` سیٹ کریں۔
- اضافی لینز موجود ہو سکتی ہیں (مثلاً `cron`، `subagent`) تاکہ پسِ منظر جابز اندر آنے والے جوابات کو بلاک کیے بغیر متوازی چل سکیں۔
- فی سیشن لینز اس بات کی ضمانت دیتی ہیں کہ کسی مخصوص سیشن کو ایک وقت میں صرف ایک ایجنٹ رن چھوئے۔
- کوئی بیرونی انحصارات یا بیک گراؤنڈ ورکر تھریڈز نہیں؛ خالص TypeScript + promises۔

## Troubleshooting

- اگر کمانڈز رکی ہوئی محسوس ہوں، تو verbose لاگز فعال کریں اور “queued for …ms” والی سطریں دیکھیں تاکہ قطار کے خالی ہونے کی تصدیق ہو۔
- اگر آپ کو قطار کی گہرائی درکار ہو، تو verbose لاگز فعال کریں اور قطار کے ٹائمنگ والی سطروں پر نظر رکھیں۔
