# Исследование: Интеграция мессенджера MAX с платформой OpenClaw

> **Дата:** 2026-02-13
> **Статус:** Исследование
> **Автор:** Research Agent
> **Версия:** 1.0

---

## Содержание

1. [Обзор платформы MAX](#1-обзор-платформы-max)
2. [Developer Platform (dev.max.ru)](#2-developer-platform-devmaxru)
3. [Bot API — Техническая документация](#3-bot-api--техническая-документация)
4. [Официальные SDK](#4-официальные-sdk)
5. [Бизнес-требования для публикации](#5-бизнес-требования-для-публикации)
6. [Варианты интеграции с OpenClaw](#6-варианты-интеграции-с-openclaw)
7. [Архитектура интеграции](#7-архитектура-интеграции)
8. [Примеры кода](#8-примеры-кода)
9. [Риски и ограничения](#9-риски-и-ограничения)
10. [Дорожная карта интеграции](#10-дорожная-карта-интеграции)

---

## 1. Обзор платформы MAX

### 1.1 Общее описание

**MAX** (ранее известный как VK Мессенджер / ICQ New) — российский мессенджер, разработанный и поддерживаемый компанией **VK Group** (Mail.ru Group). Платформа позиционируется как **«суперприложение»** (super app) по аналогии с китайским WeChat, объединяя в себе функционал мессенджера, платформы для мини-приложений, платежной системы и корпоративных коммуникаций.

### 1.2 Ключевые характеристики

| Характеристика | Описание |
|---|---|
| **Разработчик** | VK Group (Mail.ru Group) |
| **Тип** | Мессенджер / Суперприложение |
| **Аналоги** | WeChat (Китай), KakaoTalk (Корея), LINE (Япония) |
| **Целевой рынок** | Российская Федерация, страны СНГ |
| **Модель монетизации** | B2B (бизнес-аккаунты), рекламная платформа, платежи |

### 1.3 Доступность и дистрибуция

MAX доступен на всех основных платформах и каналах распространения:

- **Web-версия** — доступ через браузер без установки
- **RuStore** — российский магазин приложений (приоритетный канал)
- **Google Play** — Android-устройства (международная дистрибуция)
- **App Store** — iOS-устройства (Apple)
- **App Gallery** — устройства Huawei (Harmony OS)

### 1.4 Предустановка на смартфоны

С **1 сентября 2025 года** MAX входит в перечень обязательного предустанавливаемого ПО на смартфоны, продаваемые на территории Российской Федерации. Это обеспечивает:

- **Массовый охват аудитории** — каждый новый смартфон, проданный в РФ, имеет предустановленный MAX
- **Снижение барьера входа** — пользователям не нужно самостоятельно искать и устанавливать приложение
- **Конкурентное преимущество** — гарантированное присутствие на устройствах, в отличие от Telegram и WhatsApp

### 1.5 Интеграция с государственными сервисами

MAX имеет глубокую интеграцию с порталом **Госуслуги** (gosuslugi.ru):

- **Авторизация через ЕСИА** — единая система идентификации и аутентификации
- **Верификация аккаунтов** — подтверждение личности через Госуслуги
- **Уведомления** — получение государственных уведомлений через мессенджер
- **Электронный документооборот** — взаимодействие с государственными органами

Эта интеграция критически важна для бизнес-ботов, так как обеспечивает **верифицированную идентификацию пользователей**.

### 1.6 Устойчивость к блокировкам

В отличие от Telegram, который неоднократно подвергался попыткам блокировки со стороны Роскомнадзора (РКН), MAX **не подвержен рискам блокировки** на территории РФ:

- Разработчик (VK Group) — российская компания, полностью подчиняющаяся законодательству РФ
- Серверная инфраструктура расположена на территории России
- Данные пользователей хранятся в соответствии с ФЗ-152 (о персональных данных)
- Полное соответствие требованиям «закона Яровой» о хранении переписок

### 1.7 Функциональные возможности платформы

MAX поддерживает следующие ключевые механизмы для разработчиков:

- **Мини-приложения (Mini Apps)** — веб-приложения, встроенные в интерфейс мессенджера
- **Боты (Bots)** — автоматизированные аккаунты с API для взаимодействия
- **Каналы (Channels)** — односторонние каналы для публикации контента
- **Группы и чаты** — многопользовательские чаты с поддержкой ботов
- **Платежи** — встроенная платежная система через VK Pay
- **Stickers и медиа** — мультимедийный контент

---

## 2. Developer Platform (dev.max.ru)

### 2.1 Обзор портала разработчика

**Портал разработчика MAX** доступен по адресу **[dev.max.ru](https://dev.max.ru)** и предоставляет полный набор инструментов для создания интеграций:

| Компонент | Назначение | Статус |
|---|---|---|
| **Bot API** | Полный контроль над ботом, отправка/получение сообщений | Стабильный |
| **Mini Apps** | Нативные веб-приложения внутри мессенджера | Стабильный |
| **MAX Bridge** | Интеграция Mini Apps с платформой (платежи, контакты) | Стабильный |
| **MAX UI** | Библиотека готовых UI-компонентов | Стабильный |
| **Документация** | Полная техническая документация API | Актуальная |

### 2.2 Bot API

Bot API — основной инструмент для создания ботов на платформе MAX. Предоставляет:

- **RESTful API** для взаимодействия с платформой
- **Long Polling** для получения обновлений в режиме разработки
- **Webhooks** для получения обновлений в продакшен-режиме
- **Управление сообщениями** — отправка, редактирование, удаление
- **Работа с медиа** — фото, видео, документы, аудио
- **Inline-клавиатуры** — интерактивные кнопки в сообщениях
- **Управление чатами** — создание, настройка, модерация

### 2.3 Mini Apps

Mini Apps — полноценные веб-приложения, работающие внутри интерфейса мессенджера MAX:

- **Технология**: HTML5 + JavaScript + CSS, загружаются через WebView
- **Доступ к API платформы**: через MAX Bridge SDK
- **Платежи**: интеграция с VK Pay для in-app покупок
- **Контакты**: доступ к контактам пользователя (с разрешения)
- **Геолокация**: получение местоположения пользователя
- **Публикация**: через каталог мини-приложений MAX

Mini Apps идеально подходят для создания сложных пользовательских интерфейсов, которые невозможно реализовать исключительно через Bot API (формы, дашборды, визуализация данных).

### 2.4 MAX Bridge

MAX Bridge — JavaScript SDK для интеграции Mini Apps с платформой MAX:

```javascript
import { MaxBridge } from '@max/bridge';

const bridge = new MaxBridge();

// Получение информации о пользователе
const user = await bridge.getUserInfo();

// Инициализация платежа
const payment = await bridge.pay({
  amount: 100,
  description: 'Подписка OpenClaw Pro'
});

// Доступ к контактам
const contacts = await bridge.getContacts();

// Геолокация
const location = await bridge.getGeoLocation();
```

**Основные методы MAX Bridge:**

| Метод | Описание |
|---|---|
| `getUserInfo()` | Информация о текущем пользователе |
| `pay(params)` | Инициализация платежа через VK Pay |
| `getContacts()` | Получение контактов (с разрешения) |
| `getGeoLocation()` | Геолокация пользователя |
| `close()` | Закрытие Mini App |
| `share(params)` | Шаринг контента в чат |
| `openLink(url)` | Открытие внешней ссылки |

### 2.5 MAX UI

MAX UI — библиотека готовых UI-компонентов, обеспечивающая единообразный дизайн Mini Apps в стиле мессенджера MAX:

- **Компоненты форм**: Input, Select, Checkbox, Radio, DatePicker
- **Навигация**: TabBar, NavBar, SegmentedControl
- **Контент**: Card, List, Cell, Badge, Avatar
- **Обратная связь**: Toast, Alert, ActionSheet, Dialog
- **Тема**: автоматическая адаптация к светлой/темной теме MAX

Использование MAX UI **рекомендуется** для прохождения модерации в каталоге мини-приложений.

---

## 3. Bot API — Техническая документация

### 3.1 Базовая конфигурация

| Параметр | Значение |
|---|---|
| **Base URL** | `https://platform-api.max.ru` |
| **Протокол** | HTTPS (TLS 1.2+) |
| **Формат данных** | JSON |
| **Кодировка** | UTF-8 |
| **Rate Limit** | 30 запросов в секунду (rps) |
| **Максимальный размер запроса** | 10 MB |

### 3.2 HTTP-методы

Bot API поддерживает стандартные HTTP-методы:

| Метод | Использование |
|---|---|
| `GET` | Получение данных (сообщения, информация о чате, обновления) |
| `POST` | Создание ресурсов (отправка сообщений, загрузка файлов) |
| `PUT` | Полное обновление ресурса |
| `DELETE` | Удаление ресурсов (сообщения, подписки) |
| `PATCH` | Частичное обновление ресурса (настройки чата) |

### 3.3 Аутентификация

Все запросы к Bot API аутентифицируются через HTTP-заголовок:

```
Authorization: <token>
```

Токен бота выдается при создании бота через **BotFather** в MAX или через портал разработчика `dev.max.ru`. Токен имеет формат:

```
abc123def456ghi789jkl012mno345pqr678stu901
```

**Правила работы с токенами:**

- Токен является секретом и **не должен** попадать в публичные репозитории
- Рекомендуется хранить в переменных окружения (`process.env.MAX_BOT_TOKEN`)
- При компрометации — немедленная ревокация через портал разработчика
- Один токен = один бот

### 3.4 Основные эндпоинты API

#### 3.4.1 Информация о боте

```
GET /me
```

Возвращает информацию о текущем боте (имя, описание, аватар, идентификатор).

**Пример ответа:**

```json
{
  "user_id": 123456789,
  "name": "OpenClaw Bot",
  "username": "openclaw_bot",
  "is_bot": true,
  "avatar_url": "https://cdn.max.ru/avatars/openclaw.jpg",
  "commands": [
    {
      "name": "start",
      "description": "Начать работу с OpenClaw"
    }
  ]
}
```

#### 3.4.2 Работа с сообщениями

| Эндпоинт | Метод | Описание |
|---|---|---|
| `/messages` | `GET` | Получение списка сообщений |
| `/messages` | `POST` | Отправка нового сообщения |
| `/messages` | `PUT` | Редактирование сообщения |
| `/messages` | `DELETE` | Удаление сообщения |
| `/messages/{messageId}` | `GET` | Получение конкретного сообщения по ID |

**Отправка сообщения (POST /messages):**

```json
{
  "chat_id": 123456789,
  "text": "Привет! Добро пожаловать в OpenClaw.",
  "format": "markdown",
  "attachments": [
    {
      "type": "inline_keyboard",
      "payload": {
        "buttons": [
          [
            {
              "type": "callback",
              "text": "Начать",
              "payload": "action_start"
            }
          ]
        ]
      }
    }
  ]
}
```

#### 3.4.3 Ответ на коллбэки

```
POST /answers
```

Используется для ответа на нажатия inline-кнопок (callback queries). Позволяет:

- Отправить уведомление пользователю (toast)
- Обновить сообщение с клавиатурой
- Перенаправить на URL

```json
{
  "callback_id": "abc123",
  "notification": "Действие выполнено!",
  "message": {
    "text": "Обновленный текст сообщения",
    "attachments": []
  }
}
```

#### 3.4.4 Управление подписками (Webhooks)

| Эндпоинт | Метод | Описание |
|---|---|---|
| `/subscriptions` | `GET` | Получить текущие подписки |
| `/subscriptions` | `POST` | Создать новую подписку (webhook) |
| `/subscriptions` | `DELETE` | Удалить подписку |

**Создание webhook-подписки:**

```json
{
  "url": "https://openclaw.example.com/webhook/max",
  "update_types": [
    "message_created",
    "message_callback",
    "bot_started",
    "bot_added",
    "bot_removed"
  ],
  "version": "0.0.1"
}
```

#### 3.4.5 Long Polling

```
GET /updates?limit=100&timeout=30&marker={last_marker}
```

| Параметр | Тип | Описание |
|---|---|---|
| `limit` | integer | Максимальное количество обновлений (1-100) |
| `timeout` | integer | Время ожидания в секундах (0-90) |
| `marker` | integer | Маркер последнего полученного обновления |
| `types` | string[] | Фильтр по типам обновлений |

Long Polling **рекомендуется только для разработки и тестирования**. Для продакшен-среды следует использовать Webhooks.

#### 3.4.6 Загрузка файлов

```
POST /uploads?type={type}
```

Поддерживаемые типы файлов:

| Тип | Описание | Максимальный размер |
|---|---|---|
| `photo` | Изображения (JPEG, PNG, GIF) | 10 MB |
| `video` | Видеофайлы (MP4, MOV) | 50 MB |
| `audio` | Аудиофайлы (MP3, OGG) | 10 MB |
| `file` | Документы (PDF, DOCX, etc.) | 50 MB |

Файлы загружаются через `multipart/form-data`.

#### 3.4.7 Работа с чатами

| Эндпоинт | Метод | Описание |
|---|---|---|
| `/chats/{chatId}` | `GET` | Информация о чате |
| `/chats/{chatId}` | `PATCH` | Обновление настроек чата |
| `/chats/{chatId}` | `DELETE` | Покинуть чат |
| `/chats/{chatId}/members` | `GET` | Список участников чата |
| `/chats/{chatId}/members` | `POST` | Добавить участника |
| `/chats/{chatId}/members` | `DELETE` | Удалить участника |
| `/chats/{chatId}/admins` | `GET` | Список администраторов |
| `/chats/{chatId}/admins` | `POST` | Назначить администратора |
| `/chats/{chatId}/admins` | `DELETE` | Снять администратора |
| `/chats/{chatId}/pin` | `PUT` | Закрепить сообщение |
| `/chats/{chatId}/pin` | `DELETE` | Открепить сообщение |

### 3.5 Коды ответов API

| Код | Значение | Описание |
|---|---|---|
| **200** | OK | Запрос выполнен успешно |
| **400** | Bad Request | Некорректные параметры запроса |
| **401** | Unauthorized | Невалидный или отсутствующий токен |
| **404** | Not Found | Ресурс не найден (чат, сообщение, пользователь) |
| **405** | Method Not Allowed | Неподдерживаемый HTTP-метод для данного эндпоинта |
| **429** | Too Many Requests | Превышен rate limit (30 rps) |
| **503** | Service Unavailable | Платформа временно недоступна |

**Формат ошибки:**

```json
{
  "code": "validation.error",
  "message": "Invalid chat_id parameter",
  "details": {
    "field": "chat_id",
    "reason": "must be a positive integer"
  }
}
```

**Стратегия обработки ошибок:**

- **429**: Реализовать exponential backoff с начальной задержкой 1 секунда
- **503**: Повторить запрос через 5-10 секунд
- **401**: Проверить и обновить токен
- **400**: Логировать и не повторять запрос (ошибка клиента)

### 3.6 Rate Limit

Ограничение составляет **30 запросов в секунду (rps)** на один токен бота. При превышении лимита API возвращает код **429 Too Many Requests**.

**Рекомендации по работе с rate limit:**

1. Реализовать очередь исходящих запросов с контролем скорости
2. Использовать bulk-операции где возможно
3. Кэшировать ответы API (информация о чатах, пользователях)
4. Реализовать token bucket алгоритм для контроля rps
5. Мониторить заголовки `X-RateLimit-Remaining` и `X-RateLimit-Reset`

### 3.7 Форматирование сообщений

MAX Bot API поддерживает два формата форматирования текста:

#### 3.7.1 Markdown (format: "markdown")

```markdown
*italic text*
**bold text**
~~strikethrough text~~
__underline text__
`inline code`
```
code block
```
[link text](https://example.com)
@[user mention](user_id)
```

#### 3.7.2 HTML (format: "html")

```html
<i>italic text</i>
<b>bold text</b>
<del>strikethrough text</del>
<ins>underline text</ins>
<pre>preformatted block</pre>
<code>inline code</code>
<a href="https://example.com">link text</a>
```

**Пример отправки форматированного сообщения:**

```json
{
  "chat_id": 123456789,
  "text": "**OpenClaw** — платформа для работы с _AI-агентами_.\n\nВоспользуйтесь командой `/help` для получения справки.",
  "format": "markdown"
}
```

### 3.8 Клавиатуры (Inline Keyboard)

Inline-клавиатуры позволяют создавать интерактивные кнопки непосредственно внутри сообщений бота.

#### 3.8.1 Структура InlineKeyboardAttachment

```json
{
  "type": "inline_keyboard",
  "payload": {
    "buttons": [
      [
        {"type": "callback", "text": "Кнопка 1", "payload": "btn_1"},
        {"type": "callback", "text": "Кнопка 2", "payload": "btn_2"}
      ],
      [
        {"type": "link", "text": "Открыть сайт", "url": "https://openclaw.example.com"}
      ]
    ]
  }
}
```

#### 3.8.2 Типы кнопок

| Тип | Описание | Параметры |
|---|---|---|
| `callback` | Отправляет коллбэк боту | `text`, `payload` |
| `link` | Открывает URL в браузере | `text`, `url` |
| `request_contact` | Запрашивает контакт пользователя | `text` |
| `request_geo_location` | Запрашивает геолокацию | `text` |
| `open_app` | Открывает Mini App | `text`, `url` |
| `message` | Вставляет текст в поле ввода | `text`, `message_text` |

#### 3.8.3 Лимиты клавиатуры

| Ограничение | Значение |
|---|---|
| Максимум кнопок в сообщении | **210** |
| Максимум рядов | **30** |
| Максимум кнопок в одном ряду | **7** |
| Максимальная длина текста кнопки | **128 символов** |
| Максимальная длина payload | **1024 символа** |

### 3.9 Webhook vs Long Polling

#### 3.9.1 Long Polling

```
GET /updates?limit=100&timeout=30
```

**Преимущества:**
- Простая настройка — не требуется внешний HTTPS-сервер
- Подходит для локальной разработки и отладки
- Работает за NAT и файрволами

**Недостатки:**
- Задержка в получении обновлений (до timeout секунд)
- Нагрузка на сервер из-за постоянных запросов
- Не подходит для продакшена при высокой нагрузке

**Рекомендуемое использование:** разработка, тестирование, прототипирование.

#### 3.9.2 Webhook

```
POST /subscriptions
{
  "url": "https://your-domain.com/webhook/max",
  "update_types": ["message_created", "message_callback"]
}
```

**Преимущества:**
- Мгновенная доставка обновлений (push-модель)
- Низкая нагрузка на сервер
- Масштабируемость
- Подходит для продакшена

**Недостатки:**
- Требуется HTTPS-сертификат (обязательно)
- Требуется белый IP или домен
- Сложнее в настройке для разработки

**Требования к webhook-серверу:**
- Валидный SSL/TLS-сертификат (Let's Encrypt допускается)
- Ответ в течение 5 секунд (иначе MAX повторит запрос)
- Возвращать HTTP 200 для подтверждения получения
- Обработка дублирующих обновлений (идемпотентность)

**Рекомендуемое использование:** продакшен, staging-окружение.

---

## 4. Официальные SDK

### 4.1 TypeScript SDK (основной для OpenClaw)

TypeScript SDK является **основным и рекомендуемым** для интеграции с OpenClaw, так как бэкенд OpenClaw построен на Node.js/TypeScript.

| Параметр | Значение |
|---|---|
| **Пакет** | `@maxhub/max-bot-api` |
| **Установка** | `npm install @maxhub/max-bot-api` |
| **GitHub** | `max-messenger/max-bot-api-client-ts` |
| **Stars** | 85+ |
| **Лицензия** | MIT |
| **Runtime** | Node.js 18+ |

#### 4.1.1 Основной класс Bot

```typescript
import { Bot } from '@maxhub/max-bot-api';

const bot = new Bot(process.env.MAX_BOT_TOKEN);
```

Класс `Bot` является точкой входа для всех взаимодействий с Bot API. Предоставляет:

- **Регистрацию обработчиков** — `bot.command()`, `bot.hears()`, `bot.on()`
- **Запуск бота** — `bot.start()` (инициализирует Long Polling или Webhook)
- **Отправку сообщений** — через контекстный объект `ctx`
- **Обработку ошибок** — `bot.catch()`

#### 4.1.2 Система событий

| Событие | Описание | Триггер |
|---|---|---|
| `bot_started` | Пользователь запустил бота | Нажатие кнопки «Начать» или команда /start |
| `message_created` | Новое сообщение в чате | Любое текстовое сообщение |
| `message_callback` | Нажатие inline-кнопки | Клик по callback-кнопке |
| `message_edited` | Сообщение отредактировано | Редактирование текста |
| `message_removed` | Сообщение удалено | Удаление сообщения |
| `bot_added` | Бот добавлен в чат | Приглашение бота в групповой чат |
| `bot_removed` | Бот удален из чата | Исключение бота из группового чата |
| `user_added` | Пользователь добавлен в чат | Добавление нового участника |
| `user_removed` | Пользователь покинул чат | Выход или исключение участника |
| `chat_title_changed` | Изменено название чата | Обновление title |

#### 4.1.3 Методы обработки сообщений

```typescript
// Обработка команды /start
bot.command('start', async (ctx) => {
  await ctx.reply('Добро пожаловать в OpenClaw!');
});

// Обработка текста по регулярному выражению
bot.hears(/^привет$/i, async (ctx) => {
  await ctx.reply(`Привет, ${ctx.message.sender.name}!`);
});

// Обработка всех текстовых сообщений
bot.on('message_created', async (ctx) => {
  const text = ctx.message.body.text;
  // Маршрутизация к OpenClaw
});

// Обработка нажатий inline-кнопок
bot.on('message_callback', async (ctx) => {
  const payload = ctx.callback.payload;
  await ctx.answerCallback('Обработано!');
});
```

#### 4.1.4 Контекстный объект (ctx)

| Свойство / Метод | Описание |
|---|---|
| `ctx.message` | Объект входящего сообщения |
| `ctx.message.body.text` | Текст сообщения |
| `ctx.message.sender` | Отправитель (user_id, name) |
| `ctx.message.recipient` | Получатель (chat_id) |
| `ctx.reply(text, options?)` | Ответить в текущий чат |
| `ctx.replyWithPhoto(photo)` | Ответить изображением |
| `ctx.replyWithDocument(doc)` | Ответить документом |
| `ctx.answerCallback(text?)` | Ответить на callback-нажатие |
| `ctx.editMessage(messageId, text)` | Редактировать сообщение |
| `ctx.deleteMessage(messageId)` | Удалить сообщение |

#### 4.1.5 Обработка ошибок

```typescript
bot.catch((error, ctx) => {
  console.error(`Ошибка при обработке update ${ctx.update.update_id}:`, error);

  // Логирование для мониторинга
  logger.error({
    error: error.message,
    stack: error.stack,
    update_id: ctx.update.update_id,
    chat_id: ctx.message?.recipient?.chat_id
  });
});
```

#### 4.1.6 Запуск в продакшене с pm2

```bash
# Установка pm2
npm install -g pm2

# Запуск бота
pm2 start dist/bot.js --name "openclaw-max-bot"

# Автоперезапуск при падении
pm2 startup
pm2 save

# Мониторинг
pm2 monit
pm2 logs openclaw-max-bot
```

**Конфигурация pm2 (ecosystem.config.js):**

```javascript
module.exports = {
  apps: [{
    name: 'openclaw-max-bot',
    script: './dist/bot.js',
    instances: 1,
    autorestart: true,
    watch: false,
    max_memory_restart: '512M',
    env: {
      NODE_ENV: 'production',
      MAX_BOT_TOKEN: 'your-token-here'
    },
    error_file: './logs/bot-error.log',
    out_file: './logs/bot-out.log',
    log_date_format: 'YYYY-MM-DD HH:mm:ss Z'
  }]
};
```

### 4.2 Python SDK

| Параметр | Значение |
|---|---|
| **Пакет** | `maxapi` |
| **Установка** | `pip install maxapi` |
| **Python** | 3.9+ |

```python
from maxapi import Bot, Dispatcher

bot = Bot(token="YOUR_TOKEN")
dp = Dispatcher()

@dp.message_handler(commands=["start"])
async def start_handler(message):
    await message.reply("Добро пожаловать в OpenClaw!")

dp.run_polling(bot)
```

### 4.3 Java SDK

| Параметр | Значение |
|---|---|
| **Пакеты** | `max-bot-api-client-java`, `max-bot-sdk-java` |
| **Сборка** | Maven / Gradle |
| **Java** | 11+ |

```xml
<dependency>
    <groupId>ru.max</groupId>
    <artifactId>max-bot-sdk-java</artifactId>
    <version>1.0.0</version>
</dependency>
```

### 4.4 Go SDK

| Параметр | Значение |
|---|---|
| **Пакет** | `max-bot-api-client-go` |
| **Установка** | `go get github.com/max-messenger/max-bot-api-client-go` |
| **Go** | 1.21+ |

```go
package main

import (
    maxbot "github.com/max-messenger/max-bot-api-client-go"
)

func main() {
    bot := maxbot.NewBot(os.Getenv("MAX_BOT_TOKEN"))
    bot.OnCommand("start", func(ctx *maxbot.Context) {
        ctx.Reply("Добро пожаловать в OpenClaw!")
    })
    bot.Start()
}
```

### 4.5 PHP SDK (community)

| Параметр | Значение |
|---|---|
| **Пакет** | `bushlanov-dev/max-bot-api-client-php` |
| **Установка** | `composer require bushlanov-dev/max-bot-api-client-php` |
| **PHP** | 8.1+ |
| **Статус** | Сообщество (не официальный) |

### 4.6 OpenAPI Schema

Для автоматической генерации клиентов на любом языке доступна **OpenAPI-схема**:

- **Репозиторий**: `max-messenger/max-bot-api-schema`
- **Формат**: OpenAPI 3.0 (YAML/JSON)
- **Использование**: генерация клиентов через `openapi-generator`

```bash
# Генерация TypeScript-клиента из OpenAPI
npx openapi-generator-cli generate \
  -i max-bot-api-schema.yaml \
  -g typescript-axios \
  -o ./src/generated/max-api
```

---

## 5. Бизнес-требования для публикации

### 5.1 Верификация юридических лиц

С **августа 2025 года** публикация ботов и мини-приложений в MAX возможна **только через верифицированные юридические лица Российской Федерации**:

| Требование | Описание |
|---|---|
| **Юридическое лицо** | ООО, АО, ИП, зарегистрированные в РФ |
| **ИНН/ОГРН** | Действующий ИНН и ОГРН организации |
| **Верификация через Госуслуги** | Подтверждение через ЕСИА |
| **Контактное лицо** | Ответственный разработчик с верифицированным аккаунтом MAX |
| **Политика конфиденциальности** | Обязательный документ для ботов, работающих с персональными данными |

### 5.2 Процесс регистрации

1. **Регистрация аккаунта MAX** — через приложение или web-версию
2. **Верификация через Госуслуги** — подтверждение личности и привязка к организации
3. **Регистрация бизнес-аккаунта** — через портал разработчика `dev.max.ru`
4. **Создание бота** — через BotFather или API портала
5. **Модерация** — проверка бота на соответствие правилам платформы
6. **Публикация** — размещение в каталоге ботов MAX

### 5.3 Тарифная политика

| Период | Стоимость | Примечание |
|---|---|---|
| **2025** | Бесплатно | Бесплатный бизнес-аккаунт, привлечение разработчиков |
| **2026-2027** | Платные тарифы | Ожидается введение платных тарифов для бизнес-ботов |

**Рекомендация:** Зарегистрировать бизнес-аккаунт как можно скорее. Бесплатный тариф 2025 года мог быть продлён — уточните актуальные условия на [dev.max.ru](https://dev.max.ru). Раннее присутствие на платформе обеспечивает конкурентное преимущество.

### 5.4 Требования для OpenClaw

Для публикации бота OpenClaw в MAX необходимо:

1. **Российское юридическое лицо** — ООО или ИП, зарегистрированное в РФ
2. **Верифицированный аккаунт** разработчика через Госуслуги
3. **Политика конфиденциальности** — на русском языке, описывающая обработку данных пользователей
4. **Пользовательское соглашение** — условия использования бота
5. **Соответствие ФЗ-152** — хранение и обработка персональных данных на территории РФ
6. **Модерация контента** — бот не должен распространять запрещенный контент

---

## 6. Варианты интеграции с OpenClaw

### 6.1 Вариант 1: Bot-as-Interface

**Описание:** Пользователь общается с ботом MAX, который маршрутизирует все запросы к бэкенду OpenClaw. Бот выступает как промежуточный слой (proxy) между пользователем и AI-агентами OpenClaw.

**Схема взаимодействия:**

```
[Пользователь MAX]
       |
       v
[MAX Bot (@openclaw_bot)]
       |
       v (HTTP)
[OpenClaw Backend API]
       |
       v
[AI Agents / LLM]
       |
       v
[Ответ пользователю через Bot API]
```

**Технологический стек:**

- `@maxhub/max-bot-api` — TypeScript SDK
- Express.js / Fastify — HTTP-сервер для webhook
- Redis — хранение сессий пользователей
- OpenClaw SDK — взаимодействие с ядром платформы

**Преимущества:**

- Быстрая реализация (MVP за 1-2 недели)
- Минимальные инфраструктурные требования
- Поддержка inline-клавиатур для базовой навигации
- Работает в групповых чатах

**Ограничения:**

- Ограниченные возможности UI (только текст + кнопки)
- Нет сложных форм и визуализации данных
- Линейный UX (последовательный диалог)

**Подходит для:**

- MVP и начальной интеграции
- Простых команд и запросов к AI
- Уведомлений и алертов

### 6.2 Вариант 2: Mini App интеграция

**Описание:** Полноценное веб-приложение OpenClaw, работающее внутри мессенджера MAX через механизм Mini Apps. Пользователь открывает мини-приложение из чата с ботом или из каталога.

**Схема взаимодействия:**

```
[Пользователь MAX]
       |
       v
[MAX Mini App (WebView)]
       |
       v (MAX Bridge)
[MAX Platform APIs (платежи, контакты, etc.)]
       |
       v (HTTPS)
[OpenClaw Frontend (React/Vue)]
       |
       v (API)
[OpenClaw Backend]
       |
       v
[AI Agents / LLM]
```

**Технологический стек:**

- React / Vue.js — фронтенд Mini App
- MAX Bridge SDK — взаимодействие с платформой
- MAX UI — компоненты интерфейса
- OpenClaw API — бэкенд-интеграция

**Преимущества:**

- Полноценный веб-интерфейс с формами, графиками, таблицами
- Доступ к платформенным функциям (платежи, контакты, геолокация)
- Нативный UX через MAX UI
- Возможность сложной визуализации данных

**Ограничения:**

- Более длительная разработка (4-6 недель)
- Требуется отдельная фронтенд-разработка
- Ограничения WebView (производительность, доступ к API браузера)
- Требуется прохождение модерации в каталоге Mini Apps

**Подходит для:**

- Сложных пользовательских сценариев
- Дашбордов и аналитики
- Форм ввода данных
- Визуализации результатов работы AI-агентов

### 6.3 Вариант 3: Webhook Pipeline

**Описание:** Архитектура на основе event-driven pipeline, где webhook MAX подключается к шине событий OpenClaw. Каждое сообщение обрабатывается как событие в асинхронной очереди.

**Схема взаимодействия:**

```
[MAX Platform]
       |
       v (HTTPS Webhook)
[OpenClaw Webhook Handler]
       |
       v (Event)
[OpenClaw Event Bus (RabbitMQ / Kafka)]
       |
       v
[Message Processor Service]
       |
       v
[AI Agents / LLM]
       |
       v (Bot API)
[Ответ пользователю через MAX Bot API]
```

**Технологический стек:**

- Fastify / Express — webhook-сервер
- RabbitMQ / Kafka — шина событий
- Worker-процессы — обработчики сообщений
- OpenClaw Core — ядро платформы

**Преимущества:**

- Высокая масштабируемость (горизонтальное масштабирование worker-ов)
- Устойчивость к нагрузкам (буферизация через очередь)
- Разделение ответственности (webhook handler != message processor)
- Подходит для высоконагруженных сценариев

**Ограничения:**

- Сложная инфраструктура (требуется message broker)
- Увеличенная задержка ответа (из-за очереди)
- Требуется мониторинг и алертинг

**Подходит для:**

- Высоконагруженных продакшен-сценариев
- Систем с множеством интеграций (не только MAX)
- Сценариев с длительной обработкой запросов (AI-генерация)

### 6.4 Вариант 4: Гибридный подход (рекомендуемый)

**Описание:** Комбинация Bot-as-Interface для быстрых команд и Mini App для сложных интерфейсов. Единый бэкенд OpenClaw обрабатывает оба канала через общий Gateway Service.

**Это рекомендуемый вариант** для OpenClaw, так как он сочетает преимущества всех предыдущих подходов.

**Схема взаимодействия:**

```
[Пользователь MAX]
       |
       +--- [MAX Bot] --- быстрые команды, уведомления
       |                         |
       +--- [Mini App] --- сложные интерфейсы, дашборды
                                 |
                                 v
                    [OpenClaw Gateway Service]
                                 |
                    +------------+------------+
                    |            |            |
              [Auth Service] [Message    [Session
                             Router]     Manager]
                                 |
                                 v
                    [OpenClaw Core Engine]
                                 |
                    +------------+------------+
                    |            |            |
              [AI Agents]  [Knowledge   [Task
                            Base]       Executor]
                                 |
                                 v
                          [LLM Provider]
```

**Распределение функций:**

| Функция | Канал | Обоснование |
|---|---|---|
| Быстрые команды (/help, /status) | Bot | Мгновенный ответ без открытия Mini App |
| AI-чат | Bot | Диалоговый формат естественен для чата |
| Уведомления и алерты | Bot | Push-уведомления через мессенджер |
| Настройки профиля | Mini App | Формы, переключатели, сложный UI |
| Дашборд аналитики | Mini App | Графики, таблицы, визуализация |
| Управление агентами | Mini App | Список, фильтры, drag-and-drop |
| Платежи и подписки | Mini App | VK Pay через MAX Bridge |
| Справка и документация | Bot + Mini App | Краткая справка через бота, полная — в Mini App |

**Преимущества гибридного подхода:**

1. **Оптимальный UX** — каждый канал используется для своих сильных сторон
2. **Постепенное развитие** — можно начать с бота (MVP) и добавить Mini App позже
3. **Единый бэкенд** — не требуется дублирование бизнес-логики
4. **Гибкость** — пользователь выбирает удобный способ взаимодействия
5. **Масштабируемость** — Gateway Service позволяет добавлять новые каналы

---

## 7. Архитектура интеграции

### 7.1 Общая архитектура

```
┌─────────────────────────────────────────────────────────────────┐
│                        MAX Messenger                            │
│                                                                 │
│   ┌───────────────┐       ┌───────────────────────────────┐    │
│   │   MAX Bot      │       │       MAX Mini App            │    │
│   │ (@openclaw_bot)│       │  (openclaw.max.ru)            │    │
│   └───────┬───────┘       └──────────────┬────────────────┘    │
│           │                               │                     │
│           │    MAX Platform API           │   MAX Bridge        │
│           │  (platform-api.max.ru)        │                     │
└───────────┼───────────────────────────────┼─────────────────────┘
            │                               │
            v                               v
┌───────────────────────────────────────────────────────────────┐
│                   OpenClaw Gateway Service                     │
│                                                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐   │
│  │ Webhook       │  │ Auth         │  │ Rate Limiter     │   │
│  │ Handler       │  │ Middleware   │  │ & Validator      │   │
│  └──────┬───────┘  └──────┬───────┘  └────────┬─────────┘   │
│         │                  │                    │              │
│         v                  v                    v              │
│  ┌────────────────────────────────────────────────────────┐   │
│  │              Message Router / Dispatcher                │   │
│  └──────────────────────┬─────────────────────────────────┘   │
│                         │                                     │
└─────────────────────────┼─────────────────────────────────────┘
                          │
                          v
┌───────────────────────────────────────────────────────────────┐
│                     OpenClaw Core Engine                       │
│                                                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────┐   │
│  │ Session       │  │ Agent        │  │ Knowledge        │   │
│  │ Manager       │  │ Orchestrator │  │ Base             │   │
│  └──────────────┘  └──────┬───────┘  └──────────────────┘   │
│                           │                                   │
│  ┌──────────────┐  ┌──────┴───────┐  ┌──────────────────┐   │
│  │ Task          │  │ AI Agents    │  │ Plugin           │   │
│  │ Executor      │  │ (Claude, etc)│  │ System           │   │
│  └──────────────┘  └──────┬───────┘  └──────────────────┘   │
│                           │                                   │
└───────────────────────────┼───────────────────────────────────┘
                            │
                            v
                    ┌──────────────┐
                    │ LLM Provider │
                    │ (API)        │
                    └──────────────┘
```

### 7.2 Компоненты Gateway Service

#### 7.2.1 Webhook Handler

Принимает входящие запросы от MAX Platform API и преобразует их во внутренний формат событий OpenClaw.

```typescript
interface MaxWebhookPayload {
  update_type: string;
  timestamp: number;
  message?: MaxMessage;
  callback?: MaxCallback;
  chat_id?: number;
  user?: MaxUser;
}

interface OpenClawEvent {
  id: string;
  source: 'max' | 'telegram' | 'web';
  type: 'message' | 'callback' | 'command';
  userId: string;
  sessionId: string;
  payload: Record<string, unknown>;
  timestamp: Date;
}
```

#### 7.2.2 Auth Middleware

Проверяет подлинность входящих webhook-запросов и аутентифицирует пользователей.

```typescript
interface AuthMiddleware {
  // Верификация webhook-запроса (подпись от MAX)
  verifyWebhookSignature(req: Request): boolean;

  // Получение или создание пользовательской сессии
  getOrCreateSession(userId: string): Promise<Session>;

  // Проверка прав пользователя
  checkPermissions(userId: string, action: string): Promise<boolean>;
}
```

#### 7.2.3 Rate Limiter

Контроль входящих запросов для защиты бэкенда от перегрузки.

```typescript
interface RateLimiterConfig {
  maxRequestsPerUser: number;     // 10 rps на пользователя
  maxRequestsTotal: number;       // 100 rps общий лимит
  windowMs: number;               // 1000 ms (1 секунда)
  burstAllowance: number;         // 5 дополнительных запросов при burst
}
```

#### 7.2.4 Message Router

Маршрутизирует обработанные события к соответствующим обработчикам в OpenClaw Core.

```typescript
interface MessageRouter {
  // Маршрутизация по типу события
  route(event: OpenClawEvent): Promise<OpenClawResponse>;

  // Регистрация обработчиков
  registerHandler(eventType: string, handler: EventHandler): void;

  // Маршрутизация команд к AI-агентам
  routeToAgent(event: OpenClawEvent, agentId: string): Promise<AgentResponse>;
}
```

### 7.3 Поток обработки сообщения

Детальное описание обработки одного сообщения от пользователя:

```
1. Пользователь отправляет сообщение боту в MAX
          |
          v
2. MAX Platform доставляет webhook на OpenClaw Gateway
          |
          v
3. Webhook Handler:
   - Парсит JSON-тело запроса
   - Верифицирует подпись (HMAC)
   - Преобразует в OpenClawEvent
          |
          v
4. Auth Middleware:
   - Проверяет пользователя в базе
   - Создает/восстанавливает сессию
   - Проверяет лимиты
          |
          v
5. Message Router:
   - Определяет тип запроса (команда, текст, коллбэк)
   - Маршрутизирует к соответствующему обработчику
          |
          v
6. OpenClaw Core:
   - Session Manager загружает контекст диалога
   - Agent Orchestrator выбирает AI-агента
   - AI Agent обрабатывает запрос через LLM
          |
          v
7. Формирование ответа:
   - Текст ответа форматируется для MAX (markdown/html)
   - Добавляются inline-клавиатуры при необходимости
   - Ответ отправляется через Bot API
          |
          v
8. MAX Platform доставляет ответ пользователю
```

### 7.4 Управление сессиями

Поскольку MAX Bot API **не имеет встроенной Finite State Machine (FSM)**, необходима кастомная реализация управления сессиями.

```typescript
interface UserSession {
  id: string;
  userId: string;
  chatId: number;
  state: SessionState;
  context: ConversationContext;
  createdAt: Date;
  updatedAt: Date;
  expiresAt: Date;
}

enum SessionState {
  IDLE = 'idle',
  AWAITING_INPUT = 'awaiting_input',
  PROCESSING = 'processing',
  AWAITING_CONFIRMATION = 'awaiting_confirmation',
  IN_MINI_APP = 'in_mini_app'
}

interface ConversationContext {
  messages: Array<{role: 'user' | 'assistant'; content: string}>;
  currentAgent: string;
  metadata: Record<string, unknown>;
}
```

**Хранение сессий:**

| Хранилище | Назначение | TTL |
|---|---|---|
| **Redis** | Активные сессии, кэш | 30 минут |
| **PostgreSQL** | Персистентные данные пользователей | Без ограничения |
| **In-Memory** | Горячий кэш текущих запросов | 5 минут |

---

## 8. Примеры кода

### 8.1 Базовый бот на TypeScript

```typescript
import { Bot } from '@maxhub/max-bot-api';

// Инициализация бота
const bot = new Bot(process.env.MAX_BOT_TOKEN!);

// Обработка команды /start
bot.command('start', async (ctx) => {
  await ctx.reply(
    '**Добро пожаловать в OpenClaw!** \n\n' +
    'Я — AI-ассистент, который поможет вам работать с интеллектуальными агентами.\n\n' +
    'Доступные команды:\n' +
    '`/help` — справка\n' +
    '`/ask` — задать вопрос AI\n' +
    '`/agents` — список агентов\n' +
    '`/status` — статус системы',
    { format: 'markdown' }
  );
});

// Обработка текстовых сообщений — маршрутизация к AI
bot.on('message_created', async (ctx) => {
  const userMessage = ctx.message.body.text;

  if (!userMessage) return;

  // Маршрутизация к бэкенду OpenClaw
  const response = await openclawService.processMessage({
    userId: ctx.message.sender.user_id.toString(),
    text: userMessage,
    chatId: ctx.message.recipient.chat_id.toString()
  });

  await ctx.reply(response.text, {
    format: 'markdown',
    attachments: response.keyboard ? [{
      type: 'inline_keyboard',
      payload: { buttons: response.keyboard }
    }] : undefined
  });
});

// Запуск бота
bot.start();
console.log('OpenClaw MAX Bot запущен');
```

### 8.2 Бот с inline-клавиатурами

```typescript
import { Bot } from '@maxhub/max-bot-api';

const bot = new Bot(process.env.MAX_BOT_TOKEN!);

// Главное меню с inline-клавиатурой
bot.command('menu', async (ctx) => {
  await ctx.reply('**Главное меню OpenClaw**\n\nВыберите действие:', {
    format: 'markdown',
    attachments: [{
      type: 'inline_keyboard',
      payload: {
        buttons: [
          [
            { type: 'callback', text: 'Задать вопрос AI', payload: 'action:ask' },
            { type: 'callback', text: 'Мои агенты', payload: 'action:agents' }
          ],
          [
            { type: 'callback', text: 'История', payload: 'action:history' },
            { type: 'callback', text: 'Настройки', payload: 'action:settings' }
          ],
          [
            { type: 'open_app', text: 'Открыть дашборд', url: 'https://openclaw.max.ru/dashboard' }
          ],
          [
            { type: 'link', text: 'Документация', url: 'https://docs.openclaw.example.com' }
          ]
        ]
      }
    }]
  });
});

// Обработка нажатий inline-кнопок
bot.on('message_callback', async (ctx) => {
  const payload = ctx.callback.payload;

  switch (payload) {
    case 'action:ask':
      await ctx.answerCallback('Введите ваш вопрос:');
      await sessionManager.setState(ctx.callback.user.user_id, 'awaiting_question');
      break;

    case 'action:agents':
      const agents = await openclawService.getAgents(ctx.callback.user.user_id);
      const agentButtons = agents.map(agent => ([{
        type: 'callback' as const,
        text: `${agent.name} (${agent.status})`,
        payload: `agent:${agent.id}`
      }]));

      await ctx.reply('**Ваши AI-агенты:**', {
        format: 'markdown',
        attachments: [{
          type: 'inline_keyboard',
          payload: { buttons: agentButtons }
        }]
      });
      break;

    case 'action:history':
      const history = await openclawService.getHistory(ctx.callback.user.user_id);
      await ctx.reply(formatHistory(history), { format: 'markdown' });
      break;

    case 'action:settings':
      await ctx.answerCallback('Откройте Mini App для настроек');
      break;

    default:
      if (payload.startsWith('agent:')) {
        const agentId = payload.split(':')[1];
        await handleAgentAction(ctx, agentId);
      }
      break;
  }
});
```

### 8.3 Интеграция с OpenClaw Backend

```typescript
import axios, { AxiosInstance } from 'axios';

interface OpenClawServiceConfig {
  baseUrl: string;
  apiKey: string;
  timeout: number;
}

interface ProcessMessageRequest {
  userId: string;
  text: string;
  chatId: string;
  context?: Record<string, unknown>;
}

interface ProcessMessageResponse {
  text: string;
  format: 'markdown' | 'html' | 'plain';
  keyboard?: Array<Array<InlineButton>>;
  attachments?: Array<Attachment>;
}

class OpenClawService {
  private client: AxiosInstance;

  constructor(config: OpenClawServiceConfig) {
    this.client = axios.create({
      baseURL: config.baseUrl,
      headers: {
        'Authorization': `Bearer ${config.apiKey}`,
        'Content-Type': 'application/json'
      },
      timeout: config.timeout
    });
  }

  async processMessage(request: ProcessMessageRequest): Promise<ProcessMessageResponse> {
    try {
      const response = await this.client.post('/api/v1/messages/process', {
        user_id: request.userId,
        message: request.text,
        chat_id: request.chatId,
        source: 'max',
        context: request.context
      });

      return {
        text: response.data.reply,
        format: response.data.format || 'markdown',
        keyboard: response.data.actions?.map(this.mapToInlineButton),
        attachments: response.data.attachments
      };
    } catch (error) {
      console.error('Ошибка обработки сообщения OpenClaw:', error);
      return {
        text: 'Произошла ошибка при обработке запроса. Попробуйте позже.',
        format: 'plain'
      };
    }
  }

  async getAgents(userId: string) {
    const response = await this.client.get(`/api/v1/agents?user_id=${userId}`);
    return response.data.agents;
  }

  async getHistory(userId: string, limit: number = 10) {
    const response = await this.client.get(
      `/api/v1/history?user_id=${userId}&limit=${limit}`
    );
    return response.data.messages;
  }

  private mapToInlineButton(action: any) {
    return [{
      type: 'callback' as const,
      text: action.label,
      payload: `action:${action.id}`
    }];
  }
}

export const openclawService = new OpenClawService({
  baseUrl: process.env.OPENCLAW_API_URL || 'http://localhost:3000',
  apiKey: process.env.OPENCLAW_API_KEY || '',
  timeout: 30000
});
```

### 8.4 Управление сессиями (кастомная FSM)

```typescript
import Redis from 'ioredis';

interface SessionData {
  userId: string;
  chatId: string;
  state: string;
  context: Record<string, unknown>;
  history: Array<{ role: string; content: string }>;
  updatedAt: number;
}

class SessionManager {
  private redis: Redis;
  private readonly prefix = 'max:session:';
  private readonly ttl = 1800; // 30 минут

  constructor(redisUrl: string) {
    this.redis = new Redis(redisUrl);
  }

  async getSession(userId: string): Promise<SessionData | null> {
    const data = await this.redis.get(`${this.prefix}${userId}`);
    return data ? JSON.parse(data) : null;
  }

  async createSession(userId: string, chatId: string): Promise<SessionData> {
    const session: SessionData = {
      userId,
      chatId,
      state: 'idle',
      context: {},
      history: [],
      updatedAt: Date.now()
    };

    await this.redis.setex(
      `${this.prefix}${userId}`,
      this.ttl,
      JSON.stringify(session)
    );

    return session;
  }

  async getOrCreateSession(userId: string, chatId: string): Promise<SessionData> {
    const existing = await this.getSession(userId);
    if (existing) {
      // Продлить TTL при обращении
      await this.redis.expire(`${this.prefix}${userId}`, this.ttl);
      return existing;
    }
    return this.createSession(userId, chatId);
  }

  async setState(userId: string, state: string): Promise<void> {
    const session = await this.getSession(userId);
    if (!session) return;

    session.state = state;
    session.updatedAt = Date.now();

    await this.redis.setex(
      `${this.prefix}${userId}`,
      this.ttl,
      JSON.stringify(session)
    );
  }

  async addToHistory(
    userId: string,
    role: 'user' | 'assistant',
    content: string
  ): Promise<void> {
    const session = await this.getSession(userId);
    if (!session) return;

    session.history.push({ role, content });

    // Ограничиваем историю последними 20 сообщениями
    if (session.history.length > 20) {
      session.history = session.history.slice(-20);
    }

    session.updatedAt = Date.now();

    await this.redis.setex(
      `${this.prefix}${userId}`,
      this.ttl,
      JSON.stringify(session)
    );
  }

  async clearSession(userId: string): Promise<void> {
    await this.redis.del(`${this.prefix}${userId}`);
  }
}

export const sessionManager = new SessionManager(
  process.env.REDIS_URL || 'redis://localhost:6379'
);
```

### 8.5 Webhook-сервер для продакшена

```typescript
import Fastify from 'fastify';
import { Bot } from '@maxhub/max-bot-api';
import { sessionManager } from './session-manager';
import { openclawService } from './openclaw-service';

const app = Fastify({ logger: true });
const bot = new Bot(process.env.MAX_BOT_TOKEN!);

// Health check endpoint
app.get('/health', async () => {
  return { status: 'ok', service: 'openclaw-max-bot' };
});

// MAX Webhook endpoint
app.post('/webhook/max', async (request, reply) => {
  try {
    const update = request.body as any;

    // Верификация запроса (если MAX предоставляет подпись)
    // verifySignature(request.headers, request.body);

    // Обработка обновления
    await processUpdate(update);

    // Возвращаем 200 OK для подтверждения получения
    return { ok: true };
  } catch (error) {
    app.log.error(error, 'Ошибка обработки webhook');
    reply.status(500);
    return { ok: false, error: 'Internal server error' };
  }
});

async function processUpdate(update: any): Promise<void> {
  const { update_type } = update;

  switch (update_type) {
    case 'bot_started':
      await handleBotStarted(update);
      break;
    case 'message_created':
      await handleMessageCreated(update);
      break;
    case 'message_callback':
      await handleMessageCallback(update);
      break;
    default:
      app.log.warn(`Неизвестный тип обновления: ${update_type}`);
  }
}

async function handleBotStarted(update: any): Promise<void> {
  const userId = update.user.user_id.toString();
  const chatId = update.chat_id.toString();

  await sessionManager.createSession(userId, chatId);

  await bot.sendMessage(update.chat_id, {
    text: '**Добро пожаловать в OpenClaw!**\n\nВведите `/help` для справки.',
    format: 'markdown'
  });
}

async function handleMessageCreated(update: any): Promise<void> {
  const userId = update.message.sender.user_id.toString();
  const chatId = update.message.recipient.chat_id.toString();
  const text = update.message.body.text;

  if (!text) return;

  const session = await sessionManager.getOrCreateSession(userId, chatId);
  await sessionManager.addToHistory(userId, 'user', text);

  const response = await openclawService.processMessage({
    userId,
    text,
    chatId,
    context: { history: session.history }
  });

  await sessionManager.addToHistory(userId, 'assistant', response.text);

  await bot.sendMessage(Number(chatId), {
    text: response.text,
    format: response.format,
    attachments: response.keyboard ? [{
      type: 'inline_keyboard',
      payload: { buttons: response.keyboard }
    }] : undefined
  });
}

async function handleMessageCallback(update: any): Promise<void> {
  const callbackId = update.callback.callback_id;
  const payload = update.callback.payload;
  const userId = update.callback.user.user_id.toString();

  // Обработка callback через OpenClaw
  const response = await openclawService.processMessage({
    userId,
    text: `[callback:${payload}]`,
    chatId: update.message.recipient.chat_id.toString()
  });

  await bot.answerCallback(callbackId, {
    notification: 'Обработано',
    message: {
      text: response.text,
      format: response.format
    }
  });
}

// Запуск сервера
const start = async () => {
  try {
    const port = parseInt(process.env.PORT || '3001');
    await app.listen({ port, host: '0.0.0.0' });
    app.log.info(`Webhook-сервер запущен на порту ${port}`);

    // Регистрация webhook в MAX
    await registerWebhook(`https://${process.env.WEBHOOK_DOMAIN}/webhook/max`);
  } catch (err) {
    app.log.error(err);
    process.exit(1);
  }
};

async function registerWebhook(url: string): Promise<void> {
  try {
    await bot.subscribe({
      url,
      update_types: [
        'bot_started',
        'message_created',
        'message_callback',
        'message_edited',
        'message_removed'
      ]
    });
    console.log(`Webhook зарегистрирован: ${url}`);
  } catch (error) {
    console.error('Ошибка регистрации webhook:', error);
  }
}

start();
```

### 8.6 Mini App (React) — пример компонента

```typescript
// mini-app/src/App.tsx
import React, { useEffect, useState } from 'react';
// MAX Bridge для взаимодействия с платформой
// MAX UI компоненты для единообразного дизайна

interface Agent {
  id: string;
  name: string;
  status: 'active' | 'inactive' | 'processing';
  description: string;
}

const OpenClawMiniApp: React.FC = () => {
  const [agents, setAgents] = useState<Agent[]>([]);
  const [loading, setLoading] = useState(true);
  const [userInfo, setUserInfo] = useState<any>(null);

  useEffect(() => {
    initApp();
  }, []);

  const initApp = async () => {
    try {
      // Получение информации о пользователе через MAX Bridge
      // const bridge = new MaxBridge();
      // const user = await bridge.getUserInfo();
      // setUserInfo(user);

      // Загрузка агентов из OpenClaw API
      const response = await fetch(
        `${process.env.REACT_APP_OPENCLAW_API}/api/v1/agents`,
        {
          headers: {
            'Authorization': `Bearer ${getAccessToken()}`
          }
        }
      );
      const data = await response.json();
      setAgents(data.agents);
    } catch (error) {
      console.error('Ошибка инициализации:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleAgentAction = async (agentId: string, action: string) => {
    try {
      await fetch(
        `${process.env.REACT_APP_OPENCLAW_API}/api/v1/agents/${agentId}/${action}`,
        { method: 'POST' }
      );
      await initApp(); // Перезагрузка данных
    } catch (error) {
      console.error('Ошибка действия с агентом:', error);
    }
  };

  if (loading) {
    return <div className="loading">Загрузка OpenClaw...</div>;
  }

  return (
    <div className="openclaw-app">
      <header className="app-header">
        <h1>OpenClaw</h1>
        <p>Управление AI-агентами</p>
      </header>

      <main className="app-content">
        <section className="agents-list">
          <h2>Ваши агенты ({agents.length})</h2>
          {agents.map(agent => (
            <div key={agent.id} className="agent-card">
              <div className="agent-info">
                <h3>{agent.name}</h3>
                <p>{agent.description}</p>
                <span className={`status status-${agent.status}`}>
                  {agent.status}
                </span>
              </div>
              <div className="agent-actions">
                {agent.status === 'inactive' && (
                  <button
                    onClick={() => handleAgentAction(agent.id, 'activate')}
                  >
                    Активировать
                  </button>
                )}
                {agent.status === 'active' && (
                  <button
                    onClick={() => handleAgentAction(agent.id, 'deactivate')}
                  >
                    Деактивировать
                  </button>
                )}
              </div>
            </div>
          ))}
        </section>
      </main>
    </div>
  );
};

function getAccessToken(): string {
  // Получение токена из MAX Bridge или localStorage
  return localStorage.getItem('openclaw_token') || '';
}

export default OpenClawMiniApp;
```

---

## 9. Риски и ограничения

### 9.1 Технические ограничения

| Ограничение | Описание | Влияние | Митигация |
|---|---|---|---|
| **Нет встроенной FSM** | MAX Bot API не предоставляет механизм конечного автомата для управления состояниями диалога | Высокое | Кастомная реализация FSM на базе Redis |
| **Rate Limit 30 rps** | Ограничение на 30 запросов в секунду на бота | Среднее | Очередь запросов, кэширование, token bucket |
| **Нет URL-кнопок в формате Telegram** | Inline-кнопки работают иначе, чем в Telegram Bot API | Низкое | Использование типа `link` для внешних ссылок |
| **Ограниченная экосистема** | Меньше библиотек и примеров по сравнению с Telegram | Среднее | Использование OpenAPI-схемы для генерации клиентов |
| **Нет middleware-цепочки в SDK** | SDK не поддерживает цепочки промежуточного ПО (middleware) | Среднее | Реализация собственной middleware-архитектуры |
| **WebView ограничения Mini Apps** | Mini Apps работают в WebView с ограниченным доступом к API браузера | Среднее | Использование MAX Bridge для доступа к нативным функциям |

### 9.2 Бизнес-риски

| Риск | Вероятность | Влияние | Митигация |
|---|---|---|---|
| **Обязательная верификация юрлица РФ** | Гарантированный | Высокое | Заблаговременная регистрация юрлица и верификация |
| **Введение платных тарифов (2026-2027)** | Высокая | Среднее | Запуск в 2025 году на бесплатном тарифе, бюджетирование |
| **Изменение API без обратной совместимости** | Средняя | Высокое | Абстракция интеграции через Gateway Service, версионирование |
| **Зависимость от одного вендора (VK)** | Низкая | Высокое | Мультиканальная архитектура (MAX + Telegram + Web) |
| **Модерация контента** | Средняя | Среднее | Фильтрация исходящего контента, соответствие правилам |
| **Ограниченная аудитория** | Средняя | Среднее | Параллельная интеграция с другими мессенджерами |

### 9.3 Инфраструктурные риски

| Риск | Описание | Митигация |
|---|---|---|
| **Необходимость хранения данных в РФ** | ФЗ-152 требует хранения ПД на территории РФ | Использование российских облачных провайдеров (Yandex Cloud, VK Cloud, SberCloud) |
| **Доступность платформы MAX** | Возможные перебои в работе API | Circuit breaker, fallback-механизмы, мониторинг |
| **Масштабируемость** | Рост числа пользователей после предустановки на смартфоны | Горизонтальное масштабирование через Kubernetes |
| **Безопасность токенов** | Компрометация Bot API токена | Хранение в Vault/KMS, ротация токенов, аудит доступа |

### 9.4 Сравнение с Telegram Bot API

| Функция | MAX Bot API | Telegram Bot API |
|---|---|---|
| **Сообщения** | Текст, медиа, файлы | Текст, медиа, файлы, стикеры, polls |
| **Inline-кнопки** | 210 кнопок, 30 рядов | Без жестких ограничений |
| **FSM** | Нет (кастомная) | Нет (кастомная / aiogram FSM) |
| **Webhooks** | HTTPS обязательно | HTTPS обязательно |
| **Long Polling** | GET /updates | getUpdates |
| **Rate Limit** | 30 rps | ~30 rps (неофициально) |
| **Mini Apps** | MAX Mini Apps | Telegram Web Apps |
| **Платежи** | VK Pay (через Mini Apps) | Telegram Payments |
| **SDK (TypeScript)** | @maxhub/max-bot-api | telegraf / grammY |
| **Экосистема** | Развивающаяся | Зрелая, обширная |
| **Документация** | dev.max.ru | core.telegram.org |
| **Блокировка в РФ** | Нет риска | Потенциальный риск |
| **Предустановка** | Да (с 09.2025) | Нет |
| **Верификация** | Через Госуслуги | Нет |

---

## 10. Дорожная карта интеграции

### 10.1 Общий план

```
                          Дорожная карта интеграции MAX + OpenClaw
                          ========================================

  Phase 1 (MVP)           Phase 2              Phase 3             Phase 4
  [2-3 недели]            [3-4 недели]         [4-6 недель]        [непрерывно]

  ┌──────────────┐   ┌──────────────────┐  ┌──────────────┐  ┌──────────────┐
  │ Базовый бот  │   │ Inline keyboards │  │  Mini App    │  │  Продакшен   │
  │ + AI-чат     │──>│ + Callbacks      │─>│  + Dashboard │─>│  + Мониторинг│
  │              │   │ + Sessions       │  │  + VK Pay    │  │  + Scaling   │
  └──────────────┘   └──────────────────┘  └──────────────┘  └──────────────┘
```

### 10.2 Phase 1: MVP — Базовый бот (2-3 недели)

**Цель:** Запустить работающего бота в MAX, который принимает текстовые сообщения и маршрутизирует их к AI-агентам OpenClaw.

**Задачи:**

| # | Задача | Оценка | Приоритет |
|---|---|---|---|
| 1.1 | Регистрация бота через BotFather / dev.max.ru | 1 день | P0 |
| 1.2 | Настройка проекта: TypeScript, @maxhub/max-bot-api | 1 день | P0 |
| 1.3 | Реализация базовых команд (/start, /help, /status) | 2 дня | P0 |
| 1.4 | Интеграция с OpenClaw Backend API | 3 дня | P0 |
| 1.5 | Обработка текстовых сообщений (AI-чат) | 3 дня | P0 |
| 1.6 | Базовое управление сессиями (Redis) | 2 дня | P1 |
| 1.7 | Логирование и обработка ошибок | 1 день | P1 |
| 1.8 | Тестирование через Long Polling | 2 дня | P0 |

**Результат Phase 1:**
- Работающий бот, отвечающий на текстовые сообщения через AI
- Базовые команды навигации
- Логирование и обработка ошибок
- Тесты на основные сценарии

**Технологический стек Phase 1:**

```json
{
  "runtime": "Node.js 20 LTS",
  "language": "TypeScript 5.x",
  "framework": "@maxhub/max-bot-api",
  "storage": "Redis 7",
  "testing": "Vitest",
  "ci": "GitHub Actions"
}
```

### 10.3 Phase 2: Inline Keyboards + Callback Handling (3-4 недели)

**Цель:** Добавить интерактивный UI через inline-клавиатуры, обработку коллбэков и управление состояниями диалога.

**Задачи:**

| # | Задача | Оценка | Приоритет |
|---|---|---|---|
| 2.1 | Проектирование UI потоков (user flows) | 2 дня | P0 |
| 2.2 | Реализация inline-клавиатур для основных действий | 3 дня | P0 |
| 2.3 | Callback handler с маршрутизацией по payload | 3 дня | P0 |
| 2.4 | Кастомная FSM для управления состояниями диалога | 4 дня | P0 |
| 2.5 | Меню выбора AI-агента | 2 дня | P1 |
| 2.6 | Пагинация результатов (inline buttons) | 2 дня | P1 |
| 2.7 | Кэширование ответов API | 2 дня | P1 |
| 2.8 | Интеграционные тесты | 3 дня | P0 |

**Результат Phase 2:**
- Полноценный интерактивный бот с кнопками
- Управление состояниями диалога (FSM)
- Навигация по функциям OpenClaw через inline-клавиатуры
- Выбор и переключение AI-агентов

### 10.4 Phase 3: Mini App с веб-интерфейсом OpenClaw (4-6 недель)

**Цель:** Создать Mini App для сложных интерфейсов — дашборд, настройки, визуализация данных, платежи.

**Задачи:**

| # | Задача | Оценка | Приоритет |
|---|---|---|---|
| 3.1 | Проектирование UI/UX Mini App (Figma) | 5 дней | P0 |
| 3.2 | Настройка проекта: React + MAX UI + MAX Bridge | 3 дня | P0 |
| 3.3 | Реализация дашборда (агенты, статистика) | 5 дней | P0 |
| 3.4 | Страница управления агентами | 4 дня | P0 |
| 3.5 | Интеграция VK Pay для подписок | 4 дня | P1 |
| 3.6 | История диалогов и аналитика | 3 дня | P1 |
| 3.7 | Настройки профиля и предпочтений | 2 дня | P2 |
| 3.8 | Адаптация к светлой/темной теме MAX | 2 дня | P1 |
| 3.9 | Кнопка open_app в боте для перехода в Mini App | 1 день | P0 |
| 3.10 | Прохождение модерации в каталоге Mini Apps | 3 дня | P0 |

**Результат Phase 3:**
- Полноценное веб-приложение внутри MAX
- Дашборд с визуализацией данных
- Управление агентами через UI
- Интеграция платежей через VK Pay
- Бесшовный переход между ботом и Mini App

### 10.5 Phase 4: Продакшен + Мониторинг (непрерывно)

**Цель:** Перевести интеграцию в промышленную эксплуатацию с полным мониторингом, масштабированием и поддержкой.

**Задачи:**

| # | Задача | Оценка | Приоритет |
|---|---|---|---|
| 4.1 | Переход с Long Polling на Webhook | 2 дня | P0 |
| 4.2 | Настройка HTTPS-сертификата (Let's Encrypt) | 1 день | P0 |
| 4.3 | Деплой на Kubernetes (Yandex Cloud / VK Cloud) | 3 дня | P0 |
| 4.4 | Настройка мониторинга (Prometheus + Grafana) | 3 дня | P0 |
| 4.5 | Алертинг (PagerDuty / Telegram-уведомления) | 2 дня | P1 |
| 4.6 | Настройка pm2 / Docker для автоперезапуска | 1 день | P0 |
| 4.7 | Rate limiter на уровне Gateway | 2 дня | P0 |
| 4.8 | Circuit breaker для внешних вызовов | 2 дня | P1 |
| 4.9 | A/B тестирование UX-потоков | 3 дня | P2 |
| 4.10 | Документирование runbook и SOP | 2 дня | P1 |
| 4.11 | Нагрузочное тестирование (k6 / Artillery) | 3 дня | P1 |
| 4.12 | Настройка CI/CD pipeline | 2 дня | P0 |

**Метрики мониторинга:**

| Метрика | Порог алерта | Описание |
|---|---|---|
| **Latency p95** | > 3 секунды | 95-й перцентиль времени ответа |
| **Error rate** | > 1% | Процент ошибочных ответов |
| **Uptime** | < 99.5% | Доступность сервиса |
| **Messages/min** | > 1000 | Скорость обработки сообщений |
| **Active sessions** | Информационная | Количество активных сессий |
| **Rate limit hits** | > 10/min | Частота превышения лимитов |
| **Memory usage** | > 80% | Использование оперативной памяти |
| **CPU usage** | > 70% | Загрузка процессора |

**Результат Phase 4:**
- Промышленная эксплуатация с SLA 99.5%+
- Полный мониторинг и алертинг
- Автоматическое масштабирование
- Документированные процедуры эксплуатации

### 10.6 Сводная временная шкала

```
2025 Q3      |  2025 Q4          |  2026 Q1          |  2026 Q2+
─────────────|───────────────────|───────────────────|──────────────
Phase 1      |  Phase 2          |  Phase 3          |  Phase 4
(MVP Bot)    |  (Keyboards+FSM)  |  (Mini App)       |  (Production)
             |                   |                   |
Регистрация  |  Интерактивный UI |  Веб-дашборд      |  Масштабирование
юрлица       |  Сессии           |  VK Pay           |  Мониторинг
Бот-прототип |  AI-навигация     |  Модерация        |  Непрерывное
             |                   |                   |  улучшение
```

---

## Приложения

### Приложение A: Полезные ссылки

| Ресурс | URL |
|---|---|
| Портал разработчика MAX | https://dev.max.ru |
| Bot API документация | https://dev.max.ru/docs/bot-api |
| Mini Apps документация | https://dev.max.ru/docs/mini-apps |
| MAX Bridge SDK | https://dev.max.ru/docs/bridge |
| MAX UI компоненты | https://dev.max.ru/docs/ui |
| TypeScript SDK (GitHub) | https://github.com/max-messenger/max-bot-api-client-ts |
| OpenAPI Schema | https://github.com/max-messenger/max-bot-api-schema |
| Python SDK (PyPI) | https://pypi.org/project/maxapi/ |

### Приложение B: Переменные окружения

```bash
# MAX Bot Configuration
MAX_BOT_TOKEN=your-bot-token-here
MAX_WEBHOOK_URL=https://your-domain.com/webhook/max
MAX_WEBHOOK_SECRET=your-webhook-secret

# OpenClaw Backend
OPENCLAW_API_URL=http://localhost:3000
OPENCLAW_API_KEY=your-api-key

# Redis (Session Storage)
REDIS_URL=redis://localhost:6379

# Server
PORT=3001
NODE_ENV=production

# Logging
LOG_LEVEL=info
LOG_FORMAT=json
```

### Приложение C: Структура проекта

```
src/
  max-integration/
    bot/
      index.ts              # Точка входа бота
      commands/
        start.ts            # Команда /start
        help.ts             # Команда /help
        agents.ts           # Команда /agents
        status.ts           # Команда /status
      handlers/
        message.ts          # Обработчик текстовых сообщений
        callback.ts         # Обработчик inline-кнопок
        error.ts            # Обработчик ошибок
      keyboards/
        main-menu.ts        # Главное меню
        agent-list.ts       # Список агентов
        confirmation.ts     # Кнопки подтверждения
    gateway/
      server.ts             # Webhook-сервер (Fastify)
      middleware/
        auth.ts             # Аутентификация
        rate-limiter.ts     # Ограничение запросов
        validator.ts        # Валидация входных данных
      router.ts             # Маршрутизатор сообщений
    services/
      openclaw-client.ts    # Клиент OpenClaw API
      session-manager.ts    # Управление сессиями (Redis)
      message-formatter.ts  # Форматирование сообщений для MAX
    types/
      max-api.ts            # Типы MAX Bot API
      events.ts             # Типы событий OpenClaw
      sessions.ts           # Типы сессий
    config/
      bot.config.ts         # Конфигурация бота
      api.config.ts         # Конфигурация API
    mini-app/
      src/
        App.tsx             # Корневой компонент Mini App
        components/         # React-компоненты
        pages/              # Страницы
        hooks/              # React hooks
        services/           # API-клиенты
tests/
  max-integration/
    bot/
      commands.test.ts      # Тесты команд
      handlers.test.ts      # Тесты обработчиков
    gateway/
      webhook.test.ts       # Тесты webhook
      middleware.test.ts    # Тесты middleware
    services/
      session.test.ts       # Тесты сессий
      openclaw.test.ts      # Тесты OpenClaw клиента
    e2e/
      bot-flow.test.ts      # End-to-end тесты
```

### Приложение D: Глоссарий

| Термин | Определение |
|---|---|
| **MAX** | Мессенджер от VK Group, суперприложение для РФ |
| **Bot API** | REST API для создания и управления ботами в MAX |
| **Mini App** | Веб-приложение, работающее внутри мессенджера MAX |
| **MAX Bridge** | SDK для взаимодействия Mini Apps с платформой MAX |
| **MAX UI** | Библиотека UI-компонентов в стиле MAX |
| **OpenClaw** | Платформа для работы с AI-агентами |
| **Gateway Service** | Промежуточный сервис для маршрутизации запросов |
| **FSM** | Finite State Machine — конечный автомат для управления состояниями |
| **Webhook** | HTTP-коллбэк для получения обновлений от платформы |
| **Long Polling** | Метод получения обновлений через периодические HTTP-запросы |
| **ЕСИА** | Единая система идентификации и аутентификации (Госуслуги) |
| **VK Pay** | Платежная система VK Group |
| **Rate Limit** | Ограничение количества запросов к API в единицу времени |
| **rps** | Requests per second — запросов в секунду |

---

> **Заключение:** Интеграция мессенджера MAX с платформой OpenClaw представляет стратегическую возможность для выхода на российский рынок. Рекомендуется использовать гибридный подход (Bot + Mini App) с поэтапным развитием. Учитывая обязательную предустановку MAX на смартфоны с сентября 2025 года и интеграцию с Госуслугами, платформа имеет потенциал стать основным каналом взаимодействия с пользователями на территории РФ. Критически важно зарегистрировать бизнес-аккаунт и начать разработку MVP в 2025 году, пока действует бесплатный тариф.
