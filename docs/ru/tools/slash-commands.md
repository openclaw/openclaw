---
summary: "Slash-команды: текстовые и нативные, конфигурация и поддерживаемые команды"
read_when:
  - При использовании или настройке команд чата
  - При отладке маршрутизации команд или прав доступа
title: "Slash-команды"
---

# Slash-команды

Команды обрабатываются Gateway (шлюзом). Большинство команд должно отправляться как **отдельное** сообщение, начинающееся с `/`.
Команда bash-чата только для хоста использует `! <cmd>` (с `/bash <cmd>` в качестве алиаса).

Существует две связанные системы:

- **Команды**: отдельные сообщения `/...`.
- **Директивы**: `/think`, `/verbose`, `/reasoning`, `/elevated`, `/exec`, `/model`, `/queue`.
  - Директивы удаляются из сообщения до того, как его увидит модель.
  - В обычных сообщениях чата (не только из директив) они рассматриваются как «встроенные подсказки» и **не** сохраняют настройки сеанса.
  - В сообщениях, состоящих только из директив (сообщение содержит только директивы), они сохраняются в сеансе и отвечают подтверждением.
  - Директивы применяются только для **авторизованных отправителей** (списки разрешённых каналов/сопряжение плюс `commands.useAccessGroups`).
    Для неавторизованных отправителей директивы обрабатываются как обычный текст.

Также есть несколько **встроенных сокращений** (только для отправителей из списка разрешённых/авторизованных): `/help`, `/commands`, `/status`, `/whoami` (`/id`).
Они выполняются немедленно, удаляются до того, как модель увидит сообщение, а оставшийся текст проходит обычный конвейер обработки.

## Конфигурация

```json5
{
  commands: {
    native: "auto",
    nativeSkills: "auto",
    text: true,
    bash: false,
    bashForegroundMs: 2000,
    config: false,
    debug: false,
    restart: false,
    useAccessGroups: true,
  },
}
```

- `commands.text` (по умолчанию `true`) включает разбор `/...` в сообщениях чата.
  - На поверхностях без нативных команд (WhatsApp/WebChat/Signal/iMessage/Google Chat/MS Teams) текстовые команды продолжают работать, даже если установить это значение в `false`.
- `commands.native` (по умолчанию `"auto"`) регистрирует нативные команды.
  - Auto: включено для Discord/Telegram; выключено для Slack (пока вы не добавите slash-команды); игнорируется для провайдеров без нативной поддержки.
  - Установите `channels.discord.commands.native`, `channels.telegram.commands.native` или `channels.slack.commands.native`, чтобы переопределить поведение для конкретного провайдера (bool или `"auto"`).
  - `false` очищает ранее зарегистрированные команды в Discord/Telegram при запуске. Команды Slack управляются в приложении Slack и автоматически не удаляются.
- `commands.nativeSkills` (по умолчанию `"auto"`) регистрирует нативные команды **Skills**, когда это поддерживается.
  - Auto: включено для Discord/Telegram; выключено для Slack (Slack требует создания отдельной slash-команды для каждого skill).
  - Установите `channels.discord.commands.nativeSkills`, `channels.telegram.commands.nativeSkills` или `channels.slack.commands.nativeSkills`, чтобы переопределить для конкретного провайдера (bool или `"auto"`).
- `commands.bash` (по умолчанию `false`) включает `! <cmd>` для запуска команд оболочки хоста (`/bash <cmd>` — алиас; требуются allowlist’ы `tools.elevated`).
- `commands.bashForegroundMs` (по умолчанию `2000`) управляет тем, сколько bash ждёт перед переключением в фоновый режим (`0` переводит в фон немедленно).
- `commands.config` (по умолчанию `false`) включает `/config` (чтение/запись `openclaw.json`).
- `commands.debug` (по умолчанию `false`) включает `/debug` (переопределения только во время выполнения).
- `commands.useAccessGroups` (по умолчанию `true`) принудительно применяет списки разрешённых/политики для команд.

## Список команд

Текстовые + нативные (когда включено):

- `/help`
- `/commands`
- `/skill <name> [input]` (запуск skill по имени)
- `/status` (показ текущего статуса; включает использование/квоту провайдера для текущего провайдера модели, когда доступно)
- `/allowlist` (список/добавление/удаление записей allowlist)
- `/approve <id> allow-once|allow-always|deny` (разрешение запросов на подтверждение выполнения)
- `/context [list|detail|json]` (объяснение «контекста»; `detail` показывает размер по файлам + инструментам + skills + системному prompt’у)
- `/whoami` (показ вашего sender id; алиас: `/id`)
- `/subagents list|stop|log|info|send` (просмотр, остановка, логирование или отправка сообщений подзадачам агента для текущего сеанса)
- `/config show|get|set|unset` (сохранение конфига на диск, только для владельца; требуется `commands.config: true`)
- `/debug show|set|unset|reset` (переопределения во время выполнения, только для владельца; требуется `commands.debug: true`)
- `/usage off|tokens|full|cost` (футер использования на ответ или локальная сводка стоимости)
- `/tts off|always|inbound|tagged|status|provider|limit|summary|audio` (управление TTS; см. [/tts](/tts))
  - Discord: нативная команда — `/voice` (Discord резервирует `/tts`); текстовая `/tts` продолжает работать.
- `/stop`
- `/restart`
- `/dock-telegram` (алиас: `/dock_telegram`) (переключить ответы в Telegram)
- `/dock-discord` (алиас: `/dock_discord`) (переключить ответы в Discord)
- `/dock-slack` (алиас: `/dock_slack`) (переключить ответы в Slack)
- `/activation mention|always` (только группы)
- `/send on|off|inherit` (только для владельца)
- `/reset` или `/new [model]` (необязательная подсказка модели; остальное передаётся дальше)
- `/think <off|minimal|low|medium|high|xhigh>` (динамические варианты по модели/провайдеру; алиасы: `/thinking`, `/t`)
- `/verbose on|full|off` (алиас: `/v`)
- `/reasoning on|off|stream` (алиас: `/reason`; при включении отправляет отдельное сообщение с префиксом `Reasoning:`; `stream` = только черновик Telegram)
- `/elevated on|off|ask|full` (алиас: `/elev`; `full` пропускает подтверждения выполнения)
- `/exec host=<sandbox|gateway|node> security=<deny|allowlist|full> ask=<off|on-miss|always> node=<id>` (отправьте `/exec`, чтобы показать текущее)
- `/model <name>` (алиас: `/models`; или `/<alias>` из `agents.defaults.models.*.alias`)
- `/queue <mode>` (плюс параметры, такие как `debounce:2s cap:25 drop:summarize`; отправьте `/queue`, чтобы увидеть текущие настройки)
- `/bash <command>` (только для хоста; алиас для `! <command>`; требуются allowlist’ы `commands.bash: true` + `tools.elevated`)

Только текстовые:

- `/compact [instructions]` (см. [/concepts/compaction](/concepts/compaction))
- `! <command>` (только для хоста; по одному за раз; используйте `!poll` + `!stop` для длительных задач)
- `!poll` (проверка вывода/статуса; принимает необязательный `sessionId`; также работает `/bash poll`)
- `!stop` (остановка выполняющейся bash-задачи; принимает необязательный `sessionId`; также работает `/bash stop`)

Примечания:

- Команды принимают необязательный `:` между командой и аргументами (например, `/think: high`, `/send: on`, `/help:`).
- `/new <model>` принимает алиас модели, `provider/model` или имя провайдера (нечёткое сопоставление); если совпадение не найдено, текст трактуется как тело сообщения.
- Для полного разбиения использования по провайдерам используйте `openclaw status --usage`.
- `/allowlist add|remove` требует `commands.config=true` и учитывает канал `configWrites`.
- `/usage` управляет футером использования на ответ; `/usage cost` печатает локальную сводку стоимости из логов сеанса OpenClaw.
- `/restart` по умолчанию отключено; установите `commands.restart: true`, чтобы включить.
- `/verbose` предназначено для отладки и дополнительной видимости; держите **выключенным** при обычном использовании.
- `/reasoning` (и `/verbose`) рискованны в групповых настройках: они могут раскрыть внутренние рассуждения или вывод инструментов, которые вы не планировали показывать. Предпочтительно оставлять их выключенными, особенно в групповых чатах.
- **Быстрый путь:** сообщения, состоящие только из команд, от отправителей из списка разрешённых обрабатываются немедленно (обход очереди + модели).
- **Ограничение по упоминаниям в группах:** сообщения, состоящие только из команд, от отправителей из списка разрешённых обходят требования упоминаний.
- **Встроенные сокращения (только для отправителей из списка разрешённых):** некоторые команды также работают, будучи встроенными в обычное сообщение, и удаляются до того, как модель увидит оставшийся текст.
  - Пример: `hey /status` вызывает ответ со статусом, а оставшийся текст продолжает обычную обработку.
- В настоящее время: `/help`, `/commands`, `/status`, `/whoami` (`/id`).
- Неавторизованные сообщения, состоящие только из команд, молча игнорируются, а встроенные токены `/...` обрабатываются как обычный текст.
- **Команды Skills:** skills `user-invocable` публикуются как slash-команды. Имена приводятся к виду `a-z0-9_` (макс. 32 символа); при коллизиях добавляются числовые суффиксы (например, `_2`).
  - `/skill <name> [input]` запускает skill по имени (полезно, когда ограничения нативных команд не позволяют иметь команды для каждого skill).
  - По умолчанию команды skills пересылаются модели как обычный запрос.
  - Skills могут опционально объявлять `command-dispatch: tool`, чтобы направлять команду напрямую инструменту (детерминированно, без модели).
  - Пример: `/prose` (плагин OpenProse) — см. [OpenProse](/prose).
- **Аргументы нативных команд:** Discord использует автодополнение для динамических параметров (и кнопочные меню, когда вы пропускаете обязательные аргументы). Telegram и Slack показывают кнопочное меню, когда команда поддерживает варианты выбора и вы пропускаете аргумент.

## Поверхности использования (что где отображается)

- **Использование/квота провайдера** (пример: «Claude: осталось 80%») отображается в `/status` для текущего провайдера модели, когда включён учёт использования.
- **Токены/стоимость на ответ** управляются через `/usage off|tokens|full` (добавляется к обычным ответам).
- `/model status` относится к **моделям/аутентификации/эндпоинтам**, а не к использованию.

## Выбор модели (`/model`)

`/model` реализован как директива.

Примеры:

```
/model
/model list
/model 3
/model openai/gpt-5.2
/model opus@anthropic:default
/model status
```

Примечания:

- `/model` и `/model list` показывают компактный нумерованный выбор (семейство моделей + доступные провайдеры).
- `/model <#>` выбирает из этого списка (и по возможности предпочитает текущего провайдера).
- `/model status` показывает детализированный вид, включая настроенный эндпоинт провайдера (`baseUrl`) и режим API (`api`), когда доступно.

## Debug overrides

`/debug` позволяет задавать переопределения конфига **только во время выполнения** (в памяти, не на диске). Только для владельца. По умолчанию отключено; включается через `commands.debug: true`.

Примеры:

```
/debug show
/debug set messages.responsePrefix="[openclaw]"
/debug set channels.whatsapp.allowFrom=["+1555","+4477"]
/debug unset messages.responsePrefix
/debug reset
```

Примечания:

- Переопределения применяются немедленно к новым чтениям конфига, но **не** записываются в `openclaw.json`.
- Используйте `/debug reset`, чтобы очистить все переопределения и вернуться к конфигу на диске.

## Обновления конфига

`/config` записывает изменения в конфиг на диске (`openclaw.json`). Только для владельца. По умолчанию отключено; включается через `commands.config: true`.

Примеры:

```
/config show
/config show messages.responsePrefix
/config get messages.responsePrefix
/config set messages.responsePrefix="[openclaw]"
/config unset messages.responsePrefix
```

Примечания:

- Конфигурация валидируется перед записью; недопустимые изменения отклоняются.
- Обновления `/config` сохраняются между перезапусками.

## Примечания по поверхностям

- **Текстовые команды** выполняются в обычном сеансе чата (личные сообщения разделяют `main`, у групп — свой собственный сеанс).
- **Нативные команды** используют изолированные сеансы:
  - Discord: `agent:<agentId>:discord:slash:<userId>`
  - Slack: `agent:<agentId>:slack:slash:<userId>` (префикс настраивается через `channels.slack.slashCommand.sessionPrefix`)
  - Telegram: `telegram:slash:<userId>` (нацеливается на сеанс чата через `CommandTargetSessionKey`)
- **`/stop`** нацелен на активный сеанс чата, поэтому может прервать текущий запуск.
- **Slack:** `channels.slack.slashCommand` по-прежнему поддерживается для одной команды в стиле `/openclaw`. Если вы включаете `commands.native`, необходимо создать одну Slack slash-команду для каждой встроенной команды (с теми же именами, что и `/help`). Меню аргументов команд для Slack доставляются в виде эфемерных кнопок Block Kit.
