---
summary: "Субагенты: запуск изолированных агентных прогонов, которые объявляют результаты обратно в чат инициатора"
read_when:
  - Вам нужна фоновая/параллельная работа через агента
  - Вы изменяете sessions_spawn или политику инструментов субагентов
title: "Субагенты"
x-i18n:
  source_path: tools/subagents.md
  source_hash: 3c83eeed69a65dbb
  provider: openai
  model: gpt-5.2-chat-latest
  workflow: v1
  generated_at: 2026-02-08T10:56:15Z
---

# Субагенты

Субагенты — это фоновые прогоны агентов, запускаемые из существующего прогона агента. Они работают в собственной сессии (`agent:<agentId>:subagent:<uuid>`) и по завершении **объявляют** свой результат обратно в канал чата инициатора.

## Slash-команда

Используйте `/subagents` для просмотра или управления прогонами субагентов для **текущей сессии**:

- `/subagents list`
- `/subagents stop <id|#|all>`
- `/subagents log <id|#> [limit] [tools]`
- `/subagents info <id|#>`
- `/subagents send <id|#> <message>`

`/subagents info` показывает метаданные прогона (статус, временные метки, id сессии, путь к транскрипту, очистка).

Основные цели:

- Параллелизовать работу типа «исследование / длительная задача / медленный инструмент» без блокировки основного прогона.
- По умолчанию изолировать субагентов (разделение сессий + необязательное sandboxing).
- Сделать поверхность инструментов трудной для неправильного использования: по умолчанию субагенты **не** получают инструменты сессии.
- Избежать вложенного fan-out: субагенты не могут порождать субагентов.

Примечание о стоимости: у каждого субагента есть **собственный** контекст и расход токенов. Для тяжёлых или повторяющихся задач задавайте более дешёвую модель для субагентов и оставляйте основной агент на модели более высокого качества. Это можно настроить через `agents.defaults.subagents.model` или переопределения для каждого агента.

## Инструмент

Используйте `sessions_spawn`:

- Запускает прогон субагента (`deliver: false`, глобальная полоса: `subagent`)
- Затем выполняет шаг объявления и публикует ответ объявления в канал чата инициатора
- Модель по умолчанию: наследуется от вызывающего, если не задано `agents.defaults.subagents.model` (или переопределение для агента `agents.list[].subagents.model`); явное `sessions_spawn.model` всё равно имеет приоритет.
- Уровень «thinking» по умолчанию: наследуется от вызывающего, если не задано `agents.defaults.subagents.thinking` (или переопределение для агента `agents.list[].subagents.thinking`); явное `sessions_spawn.thinking` всё равно имеет приоритет.

Параметры инструмента:

- `task` (обязательно)
- `label?` (необязательно)
- `agentId?` (необязательно; запуск под другим id агента, если разрешено)
- `model?` (необязательно; переопределяет модель субагента; некорректные значения пропускаются, и субагент запускается на модели по умолчанию с предупреждением в результате инструмента)
- `thinking?` (необязательно; переопределяет уровень thinking для прогона субагента)
- `runTimeoutSeconds?` (по умолчанию `0`; при установке прогон субагента прерывается через N секунд)
- `cleanup?` (`delete|keep`, по умолчанию `keep`)

Список разрешённых:

- `agents.list[].subagents.allowAgents`: список id агентов, на которые можно нацеливаться через `agentId` (`["*"]` — чтобы разрешить любые). По умолчанию: только агент-инициатор.

Discovery:

- Используйте `agents_list`, чтобы увидеть, какие id агентов в данный момент разрешены для `sessions_spawn`.

Автоархивация:

- Сессии субагентов автоматически архивируются через `agents.defaults.subagents.archiveAfterMinutes` (по умолчанию: 60).
- Архивация использует `sessions.delete` и переименовывает транскрипт в `*.deleted.<timestamp>` (та же папка).
- `cleanup: "delete"` архивирует сразу после объявления (при этом транскрипт сохраняется через переименование).
- Автоархивация выполняется по принципу best-effort; ожидающие таймеры теряются при перезапуске Gateway (шлюз).
- `runTimeoutSeconds` **не** выполняет автоархивацию; он только останавливает прогон. Сессия остаётся до автоархивации.

## Аутентификация

Аутентификация субагента определяется **id агента**, а не типом сессии:

- Ключ сессии субагента — `agent:<agentId>:subagent:<uuid>`.
- Хранилище аутентификации загружается из `agentDir` этого агента.
- Профили аутентификации основного агента добавляются как **fallback**; профили агента имеют приоритет над профилями основного агента при конфликтах.

Примечание: объединение аддитивное, поэтому профили основного агента всегда доступны как fallback. Полностью изолированная аутентификация для каждого агента пока не поддерживается.

## Объявление

Субагенты отчитываются через шаг объявления:

- Шаг объявления выполняется внутри сессии субагента (не сессии инициатора).
- Если субагент отвечает ровно `ANNOUNCE_SKIP`, ничего не публикуется.
- В противном случае ответ объявления публикуется в канал чата инициатора через последующий вызов `agent` (`deliver=true`).
- Ответы объявления сохраняют маршрутизацию тредов/тем, где это доступно (треды Slack, темы Telegram, треды Matrix).
- Сообщения объявления нормализуются к стабильному шаблону:
  - `Status:`, полученный из результата прогона (`success`, `error`, `timeout` или `unknown`).
  - `Result:` — сводное содержимое шага объявления (или `(not available)`, если отсутствует).
  - `Notes:` — детали ошибок и другой полезный контекст.
- `Status` не выводится из ответа модели; он берётся из сигналов результата выполнения.

Полезные нагрузки объявления включают строку статистики в конце (даже при обёртывании):

- Время выполнения (например, `runtime 5m12s`)
- Расход токенов (вход/выход/всего)
- Оценка стоимости при настроенном ценообразовании модели (`models.providers.*.models[].cost`)
- `sessionKey`, `sessionId` и путь к транскрипту (чтобы основной агент мог получить историю через `sessions_history` или проверить файл на диске)

## Политика инструментов (инструменты субагента)

По умолчанию субагенты получают **все инструменты, кроме инструментов сессии**:

- `sessions_list`
- `sessions_history`
- `sessions_send`
- `sessions_spawn`

Переопределение через конфиг:

```json5
{
  agents: {
    defaults: {
      subagents: {
        maxConcurrent: 1,
      },
    },
  },
  tools: {
    subagents: {
      tools: {
        // deny wins
        deny: ["gateway", "cron"],
        // if allow is set, it becomes allow-only (deny still wins)
        // allow: ["read", "exec", "process"]
      },
    },
  },
}
```

## Параллелизм

Субагенты используют выделенную внутрипроцессную полосу очереди:

- Имя полосы: `subagent`
- Параллелизм: `agents.defaults.subagents.maxConcurrent` (по умолчанию `8`)

## Остановка

- Отправка `/stop` в чате инициатора прерывает сессию инициатора и останавливает все активные прогоны субагентов, запущенные из неё.

## Ограничения

- Объявление субагента выполняется по принципу **best-effort**. Если Gateway (шлюз) перезапускается, ожидающая работа «объявить обратно» теряется.
- Субагенты по-прежнему разделяют ресурсы одного и того же процесса Gateway (шлюз); рассматривайте `maxConcurrent` как предохранительный клапан.
- `sessions_spawn` всегда неблокирующий: он немедленно возвращает `{ status: "accepted", runId, childSessionKey }`.
- Контекст субагента внедряет только `AGENTS.md` + `TOOLS.md` (без `SOUL.md`, `IDENTITY.md`, `USER.md`, `HEARTBEAT.md` или `BOOTSTRAP.md`).
