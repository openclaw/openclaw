---
summary: "Подтверждения exec, списки разрешённых и запросы выхода из sandbox"
read_when:
  - Настройка подтверждений exec или списков разрешённых
  - Реализация UX подтверждений exec в приложении для macOS
  - Анализ запросов выхода из sandbox и их последствий
title: "Подтверждения Exec"
---

# Утверждения Exec

Подтверждения exec — это **ограничитель на уровне сопутствующего приложения / хоста узла**, который позволяет изолированному (sandboxed) агенту выполнять
команды на реальном хосте (`gateway` или `node`). Это можно представить как предохранительную блокировку:
команды разрешаются только тогда, когда совпадают политика + список разрешённых + (необязательное) подтверждение пользователя.
Подтверждения exec действуют **в дополнение** к политике инструментов и повышенному режиму (если только elevated не установлен в `full`, что пропускает подтверждения).
Эффективная политика — это **более строгая** из `tools.exec.*` и значений по умолчанию подтверждений; если поле подтверждений опущено, используется значение `tools.exec`.

Если UI сопутствующего приложения **недоступен**, любой запрос, требующий запроса пользователю,
разрешается через **ask fallback** (по умолчанию: запрет).

## Где применяется

Подтверждения exec применяются локально на хосте выполнения:

- **gateway host** → процесс `openclaw` на машине Gateway
- **node host** → runner узла (сопутствующее приложение для macOS или headless node host)

Разделение на macOS:

- **служба node host** пересылает `system.run` в **приложение для macOS** по локальному IPC.
- **приложение для macOS** применяет подтверждения + выполняет команду в контексте UI.

## Настройки и хранение

Подтверждения хранятся в локальном JSON‑файле на хосте выполнения:

`~/.openclaw/exec-approvals.json`

Пример схемы:

```json
{
  "version": 1,
  "socket": {
    "path": "~/.openclaw/exec-approvals.sock",
    "token": "base64url-token"
  },
  "defaults": {
    "security": "deny",
    "ask": "on-miss",
    "askFallback": "deny",
    "autoAllowSkills": false
  },
  "agents": {
    "main": {
      "security": "allowlist",
      "ask": "on-miss",
      "askFallback": "deny",
      "autoAllowSkills": true,
      "allowlist": [
        {
          "id": "B0C8C0B3-2C2D-4F8A-9A3C-5A4B3C2D1E0F",
          "pattern": "~/Projects/**/bin/rg",
          "lastUsedAt": 1737150000000,
          "lastUsedCommand": "rg -n TODO",
          "lastResolvedPath": "/Users/user/Projects/.../bin/rg"
        }
      ]
    }
  }
}
```

## Регуляторы политики

### Безопасность (`exec.security`)

- **deny**: блокировать все запросы exec на хосте.
- **allowlist**: разрешать только команды из списка разрешённых.
- **full**: разрешать всё (эквивалент elevated).

### Ask (`exec.ask`)

- **off**: никогда не запрашивать.
- **on-miss**: запрашивать только если список разрешённых не совпал.
- **always**: запрашивать для каждой команды.

### Ask fallback (`askFallback`)

Если требуется запрос, но UI недоступен, fallback определяет поведение:

- **deny**: блокировать.
- **allowlist**: разрешать только при совпадении со списком разрешённых.
- **full**: разрешать.

## Список разрешённых (для каждого агента)

Списки разрешённых являются **для каждого агента**. Если существует несколько агентов, переключайте,
какого агента вы редактируете, в приложении для macOS. Шаблоны — это **регистронезависимые glob‑совпадения**.
Шаблоны должны разрешаться в **пути к бинарным файлам** (записи только с basename игнорируются).
Устаревшие записи `agents.default` при загрузке мигрируются в `agents.main`.

Примеры:

- `~/Projects/**/bin/peekaboo`
- `~/.local/bin/*`
- `/opt/homebrew/bin/rg`

Каждая запись списка разрешённых отслеживает:

- **id** — стабильный UUID для идентификации в UI (необязательно)
- **last used** — временная метка последнего использования
- **last used command** — последняя использованная команда
- **last resolved path** — последний разрешённый путь

## Авто‑разрешение CLI Skills

Когда включено **Auto-allow skill CLIs**, исполняемые файлы, на которые ссылаются известные Skills,
рассматриваются как разрешённые на узлах (узел macOS или headless node host). Для этого используется
`skills.bins` по RPC шлюза Gateway для получения списка бинарников Skills. Отключите это, если требуется строгий ручной список разрешённых.

## Safe bins (только stdin)

`tools.exec.safeBins` определяет небольшой список бинарников **только для stdin** (например, `jq`),
которые могут выполняться в режиме allowlist **без** явных записей в списке разрешённых. Safe bins
отклоняют позиционные аргументы файлов и токены, похожие на пути, поэтому они могут работать
только с входящим потоком.
Цепочки shell и перенаправления не разрешаются автоматически в режиме allowlist.

Цепочки shell (`&&`, `||`, `;`) разрешены, когда каждый верхнеуровневый сегмент
соответствует списку разрешённых (включая safe bins или авто‑разрешение Skills). Перенаправления по‑прежнему
не поддерживаются в режиме allowlist.
Подстановка команд (`$()` / обратные кавычки) отклоняется
при разборе allowlist, включая случаи внутри двойных кавычек; используйте одинарные кавычки,
если вам нужен буквальный текст `$()`.

Safe bins по умолчанию: `jq`, `grep`, `cut`, `sort`, `uniq`, `head`, `tail`, `tr`, `wc`.

## Редактирование через Control UI

Используйте карточку **Control UI → Nodes → Exec approvals** для редактирования значений по умолчанию,
переопределений для агентов и списков разрешённых. Выберите область (Defaults или агент), настройте политику,
добавьте/удалите шаблоны списка разрешённых и нажмите **Save**. UI показывает метаданные **last used**
для каждого шаблона, чтобы список оставался аккуратным.

Селектор цели выбирает **Gateway** (локальные подтверждения) или **Node**. Узлы
должны объявлять `system.execApprovals.get/set` (приложение для macOS или headless node host).
Если узел ещё не объявляет подтверждения exec, отредактируйте его локальный
`~/.openclaw/exec-approvals.json` напрямую.

CLI: `openclaw approvals` поддерживает редактирование Gateway или узла (см. [Approvals CLI](/cli/approvals)).

## Поток подтверждения

Когда требуется запрос, шлюз рассылает `exec.approval.requested` клиентам операторов.
Control UI и приложение для macOS обрабатывают его через `exec.approval.resolve`, после чего шлюз пересылает
одобренный запрос на хост узла.

Когда требуются подтверждения, инструмент exec немедленно возвращает идентификатор подтверждения. Используйте этот id,
чтобы сопоставлять последующие системные события (`Exec finished` / `Exec denied`). Если решение
не поступает до истечения тайм‑аута, запрос считается истёкшим по подтверждению и отображается как отказ.

Диалог подтверждения включает:

- команду + аргументы
- cwd
- id агента
- разрешённый путь к исполняемому файлу
- хост + метаданные политики

Действия:

- **Allow once** → выполнить сейчас
- **Always allow** → добавить в список разрешённых + выполнить
- **Deny** → заблокировать

## Пересылка подтверждений в чат‑каналы

Вы можете пересылать запросы подтверждения exec в любой чат‑канал (включая каналы плагинов) и одобрять
их с помощью `/approve`. Используется стандартный конвейер исходящей доставки.

Конфигурация:

```json5
{
  approvals: {
    exec: {
      enabled: true,
      mode: "session", // "session" | "targets" | "both"
      agentFilter: ["main"],
      sessionFilter: ["discord"], // substring or regex
      targets: [
        { channel: "slack", to: "U12345678" },
        { channel: "telegram", to: "123456789" },
      ],
    },
  },
}
```

Ответ в чате:

```
/approve <id> allow-once
/approve <id> allow-always
/approve <id> deny
```

### Поток macOS IPC

```
Gateway -> Node Service (WS)
                 |  IPC (UDS + token + HMAC + TTL)
                 v
             Mac App (UI + approvals + system.run)
```

Примечания по безопасности:

- Режим Unix‑сокета `0600`, токен хранится в `exec-approvals.json`.
- Проверка одноимённого UID для peer.
- Challenge/response (nonce + HMAC‑токен + хеш запроса) + короткий TTL.

## Системные события

Жизненный цикл exec отображается как системные сообщения:

- `Exec running` (только если команда превышает порог уведомления о выполнении)
- `Exec finished`
- `Exec denied`

Они публикуются в сеансе агента после того, как узел сообщает о событии.
Подтверждения exec на Gateway‑хосте порождают те же события жизненного цикла, когда команда завершается
(и при необходимости — когда выполняется дольше порога).
Exec с подтверждением использует идентификатор подтверждения как `runId` в этих сообщениях для удобной корреляции.

## Последствия

- **full** — мощный режим; по возможности предпочитайте списки разрешённых.
- **ask** позволяет оставаться в курсе, сохраняя быстрые подтверждения.
- Списки разрешённых для каждого агента предотвращают «утечки» подтверждений между агентами.
- Подтверждения применяются только к запросам exec на хосте от **авторизованных отправителей**. Неавторизованные отправители не могут вызывать `/exec`.
- `/exec security=full` — это удобство на уровне сеанса для авторизованных операторов и по замыслу пропускает подтверждения.
  Чтобы жёстко заблокировать exec на хосте, установите безопасность подтверждений в `deny` или запретите инструмент `exec` через политику инструментов.

Связанное:

- [Exec tool](/tools/exec)
- [Elevated mode](/tools/elevated)
- [Skills](/tools/skills)
