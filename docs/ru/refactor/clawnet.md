---
summary: "Рефакторинг Clawnet: унификация сетевого протокола, ролей, аутентификации, подтверждений и идентификации"
read_when:
  - Планирование единого сетевого протокола для узлов и клиентских приложений операторов
  - Переработка подтверждений, сопряжения, TLS и присутствия между устройствами
title: "Рефакторинг Clawnet"
---

# Рефакторинг Clawnet (унификация протокола + аутентификации)

## Привет

Привет, Питер — отличное направление; это открывает путь к более простому UX и более сильной безопасности.

## Назначение

Единый, строгий документ для:

- Текущего состояния: протоколы, потоки, границы доверия.
- Болевых точек: подтверждения, многошаговая маршрутизация, дублирование UI.
- Предлагаемого нового состояния: один протокол, ограниченные роли, единая аутентификация/сопряжение, TLS‑пиннинг.
- Модели идентификации: стабильные ID + «милые» слаги.
- Плана миграции, рисков и открытых вопросов.

## Цели (из обсуждения)

- Один протокол для всех клиентов (приложение для macOS, CLI, iOS, Android, headless‑узел).
- Каждый участник сети аутентифицирован и сопряжён.
- Чёткое разделение ролей: узлы vs операторы.
- Централизованные подтверждения, доставляемые туда, где находится пользователь.
- TLS‑шифрование + опциональный пиннинг для всего удалённого трафика.
- Минимальное дублирование кода.
- Одна машина отображается один раз (без дублирования UI/узла).

## Не цели (явно)

- Убрать разделение возможностей (по‑прежнему нужен принцип наименьших привилегий).
- Открыть полный control plane Gateway без проверок областей доступа.
- Делать аутентификацию зависящей от человекочитаемых меток (слаги не являются элементом безопасности).

---

# Текущее состояние (as‑is)

## Два протокола

### 1. Gateway WebSocket (control plane)

- Полная поверхность API: конфиг, каналы, модели, сеансы, запуски агентов, логи, узлы и т. д.
- Привязка по умолчанию: loopback. Удалённый доступ через SSH/Tailscale.
- Аутентификация: токен/пароль через `connect`.
- Нет TLS‑пиннинга (опора на loopback/туннель).
- Код:
  - `src/gateway/server/ws-connection/message-handler.ts`
  - `src/gateway/client.ts`
  - `docs/gateway/protocol.md`

### 2. Bridge (транспорт узлов)

- Узкая поверхность allowlist, идентификация узла + сопряжение.
- JSONL поверх TCP; опциональный TLS + пиннинг отпечатка сертификата.
- TLS объявляет отпечаток в discovery TXT.
- Код:
  - `src/infra/bridge/server/connection.ts`
  - `src/gateway/server-bridge.ts`
  - `src/node-host/bridge-client.ts`
  - `docs/gateway/bridge-protocol.md`

## Клиенты control plane сегодня

- CLI → Gateway WS через `callGateway` (`src/gateway/call.ts`).
- UI приложения для macOS → Gateway WS (`GatewayConnection`).
- Web Control UI → Gateway WS.
- ACP → Gateway WS.
- Браузерное управление использует собственный HTTP‑сервер управления.

## Узлы сегодня

- Приложение для macOS в режиме узла подключается к Gateway bridge (`MacNodeBridgeSession`).
- Приложения iOS/Android подключаются к Gateway bridge.
- Сопряжение + токен на узел хранятся на Gateway.

## Текущий поток подтверждений (exec)

- Агент использует `system.run` через Gateway.
- Gateway вызывает узел через bridge.
- Среда выполнения узла принимает решение о подтверждении.
- UI‑запрос показывается приложением для macOS (когда узел == приложение для macOS).
- Узел возвращает `invoke-res` в Gateway.
- Многошаговость, UI привязан к хосту узла.

## Присутствие + идентификация сегодня

- Записи присутствия Gateway из WS‑клиентов.
- Записи присутствия узлов из bridge.
- Приложение для macOS может показывать две записи для одной машины (UI + узел).
- Идентификация узла хранится в хранилище сопряжений; идентификация UI — отдельно.

---

# Проблемы / болевые точки

- Два стека протоколов для поддержки (WS + Bridge).
- Подтверждения на удалённых узлах: запрос появляется на хосте узла, а не там, где пользователь.
- TLS‑пиннинг есть только у bridge; WS зависит от SSH/Tailscale.
- Дублирование идентичности: одна машина отображается как несколько экземпляров.
- Неоднозначные роли: возможности UI + узла + CLI чётко не разделены.

---

# Предлагаемое новое состояние (Clawnet)

## Один протокол, две роли

Единый WS‑протокол с ролью и областью доступа.

- **Роль: node** (хост возможностей)
- **Роль: operator** (control plane)
- Опциональная **область (scope)** для оператора:
  - `operator.read` (статус + просмотр)
  - `operator.write` (запуск агента, отправки)
  - `operator.admin` (конфиг, каналы, модели)

### Поведение ролей

**Node**

- Может регистрировать возможности (`caps`, `commands`, разрешения).
- Может получать команды `invoke` (`system.run`, `camera.*`, `canvas.*`, `screen.record` и т. д.).
- Может отправлять события: `voice.transcript`, `agent.request`, `chat.subscribe`.
- Не может вызывать API control plane для конфига/моделей/каналов/сеансов/агентов.

**Operator**

- Полный API control plane, ограниченный областью доступа.
- Получает все подтверждения.
- Не выполняет напрямую действия ОС; маршрутизирует их к узлам.

### Ключевое правило

Роль задаётся на уровне соединения, а не устройства. Одно устройство может открывать оба типа ролей, отдельно.

---

# Унифицированная аутентификация + сопряжение

## Идентификация клиента

Каждый клиент предоставляет:

- `deviceId` (стабильный, производный от ключа устройства).
- `displayName` (человекочитаемое имя).
- `role` + `scope` + `caps` + `commands`.

## Поток сопряжения (унифицированный)

- Клиент подключается без аутентификации.
- Gateway создаёт **запрос на сопряжение** для данного `deviceId`.
- Оператор получает запрос; одобряет или отклоняет.
- Gateway выдаёт учётные данные, привязанные к:
  - публичному ключу устройства
  - роли(ям)
  - охват(ы)
  - возможностям/командам
- Клиент сохраняет токен и переподключается аутентифицированным.

## Аутентификация, привязанная к устройству (избежать повторного использования bearer‑токенов)

Предпочтительно: ключевые пары устройств.

- Устройство генерирует пару ключей один раз.
- `deviceId = fingerprint(publicKey)`.
- Gateway отправляет nonce; устройство подписывает; Gateway проверяет.
- Токены выдаются на публичный ключ (proof‑of‑possession), а не на строку.

Альтернативы:

- mTLS (клиентские сертификаты): максимально надёжно, больше операционной сложности.
- Короткоживущие bearer‑токены — только как временная фаза (частая ротация + ранний отзыв).

## Тихое одобрение (эвристика SSH)

Определить точно, чтобы избежать слабого места. Предпочтительно одно из:

- **Только локально**: автосопряжение при подключении клиента через loopback/Unix‑сокет.
- **Вызов через SSH**: Gateway выдаёт nonce; клиент доказывает SSH, получив его.
- **Окно физического присутствия**: после локального одобрения в UI хоста Gateway разрешить автосопряжение на короткое время (например, 10 минут).

Всегда логировать и фиксировать авто‑одобрения.

---

# TLS везде (dev + prod)

## Повторное использование существующего TLS bridge

Использовать текущую TLS‑реализацию + пиннинг отпечатка:

- `src/infra/bridge/server/tls.ts`
- логика проверки отпечатка в `src/node-host/bridge-client.ts`

## Применение к WS

- WS‑сервер поддерживает TLS с тем же сертификатом/ключом + отпечатком.
- WS‑клиенты могут пиннить отпечаток (опционально).
- Discovery объявляет TLS + отпечаток для всех эндпоинтов.
  - Discovery — только подсказки для локализации; никогда не якорь доверия.

## Зачем

- Снизить зависимость от SSH/Tailscale для конфиденциальности.
- Сделать удалённые мобильные подключения безопасными по умолчанию.

---

# Переработка подтверждений (централизация)

## Текущее

Подтверждение происходит на хосте узла (runtime узла приложения для macOS). Запрос появляется там, где запущен узел.

## Предлагаемое

Подтверждение **размещено на Gateway**, UI доставляется клиентам‑операторам.

### Новый поток

1. Gateway получает intent `system.run` (агент).
2. Gateway создаёт запись подтверждения: `approval.requested`.
3. UI операторов показывает запрос.
4. Решение отправляется в Gateway: `approval.resolve`.
5. Gateway вызывает команду узла при одобрении.
6. Узел выполняет и возвращает `invoke-res`.

### Семантика подтверждений (усиление)

- Широковещание всем операторам; только активный UI показывает модальное окно (остальные — toast).
- Первое решение считается окончательным; Gateway отклоняет последующие как уже разрешённые.
- Тайм‑аут по умолчанию: отказ через N секунд (например, 60 с) с логированием причины.
- Для решения требуется область доступа `operator.approvals`.

## Преимущества

- Запрос появляется там, где находится пользователь (mac/телефон).
- Единообразные подтверждения для удалённых узлов.
- Runtime узла остаётся headless; без зависимости от UI.

---

# Примеры чёткого разделения ролей

## Приложение iPhone

- **Роль node** для: микрофона, камеры, голосового чата, геолокации, push‑to‑talk.
- Опционально **operator.read** для статуса и просмотра чата.
- Опционально **operator.write/admin** только при явном включении.

## Приложение для macOS

- Роль operator по умолчанию (UI управления).
- Роль node при включении «Mac node» (system.run, экран, камера).
- Один и тот же deviceId для обоих соединений → объединённая запись в UI.

## CLI

- Всегда роль operator.
- Области, полученные по подкоманде:
  - `status`, `logs` → read
  - `agent`, `message` → write
  - `config`, `channels` → admin
  - подтверждения + сопряжение → `operator.approvals` / `operator.pairing`

---

# Идентификация + слаги

## Стабильный ID

Требуется для аутентификации; никогда не меняется.
Предпочтительно:

- Отпечаток ключевой пары (хэш публичного ключа).

## Милый слаг (в стиле лобстеров)

Только человекочитаемая метка.

- Примеры: `scarlet-claw`, `saltwave`, `mantis-pinch`.
- Хранится в реестре Gateway, редактируемый.
- Обработка коллизий: `-2`, `-3`.

## Группировка в UI

Один и тот же `deviceId` для разных ролей → одна строка «Экземпляр»:

- Бейдж: `operator`, `node`.
- Показывает возможности + время последнего появления.

---

# Стратегия миграции

## Фаза 0: Документация + выравнивание

- Опубликовать этот документ.
- Инвентаризировать все вызовы протоколов и потоки подтверждений.

## Фаза 1: Добавить роли/области в WS

- Расширить параметры `connect` с `role`, `scope`, `deviceId`.
- Добавить gating по allowlist для роли node.

## Фаза 2: Совместимость с bridge

- Оставить bridge работающим.
- Добавить поддержку узлов через WS параллельно.
- Функции врат позади флага конфигурации.

## Фаза 3: Централизованные подтверждения

- Добавить события запроса и разрешения подтверждений в WS.
- Обновить UI приложения для macOS для отображения и ответа.
- Runtime узла перестаёт показывать UI‑запросы.

## Фаза 4: Унификация TLS

- Добавить TLS‑конфигурацию для WS, используя TLS‑runtime bridge.
- Добавить пиннинг в клиенты.

## Фаза 5: Устаревание bridge

- Перевести iOS/Android/mac узлы на WS.
- Оставить bridge как fallback; удалить после стабилизации.

## Фаза 6: Аутентификация, привязанная к устройству

- Требовать ключевую идентификацию для всех нелокальных соединений.
- Добавить UI для отзыва и ротации.

---

# Примечания по безопасности

- Роли/allowlist применяются на границе Gateway.
- Ни один клиент не получает «полный» API без области operator.
- Сопряжение требуется для _всех_ соединений.
- TLS + пиннинг снижают риск MITM для мобильных.
- Тихое одобрение через SSH — удобство; всё равно логируется и может быть отозвано.
- Discovery никогда не является якорем доверия.
- Заявленные возможности проверяются сервером по allowlist с учётом платформы/типа.

# Потоковая передача + большие полезные нагрузки (медиа узлов)

WS control plane подходит для небольших сообщений, но узлы также выполняют:

- клипы с камеры
- записи экрана
- аудиопотоки

Варианты:

1. Бинарные кадры WS + чанкинг + правила backpressure.
2. Отдельный streaming‑эндпоинт (всё ещё TLS + auth).
3. Дольше сохранять bridge для медиа‑нагруженных команд, мигрировать в последнюю очередь.

Выбрать один вариант до реализации, чтобы избежать расхождений.

# Политика возможностей + команд

- Возможности/команды, заявленные узлом, рассматриваются как **утверждения**.
- Gateway применяет allowlist по платформам.
- Любая новая команда требует одобрения оператора или явного изменения allowlist.
- Аудит изменений с временными метками.

# Аудит + ограничение частоты

- Логировать: запросы сопряжения, одобрения/отказы, выдачу/ротацию/отзыв токенов.
- Ограничивать частоту спама сопряжений и запросов подтверждений.

# Гигиена протокола

- Явная версия протокола + коды ошибок.
- Правила переподключения + политика heartbeat.
- TTL присутствия и семантика last‑seen.

---

# Открытые вопросы

1. Одно устройство с обеими ролями: модель токенов
   - Рекомендуется отдельные токены на роль (node vs operator).
   - Один deviceId; разные области; более понятный отзыв.

2. Гранулярность областей оператора
   - read/write/admin + approvals + pairing (минимально жизнеспособно).
   - Позже рассмотреть более детальные области.

3. UX ротации + отзыва токенов
   - Авто‑ротация при смене роли.
   - UI для отзыва по deviceId + роли.

4. Discovery
   - Расширить текущий Bonjour TXT, добавив WS TLS‑отпечаток + подсказки ролей.
   - Рассматривать только как подсказки локализации.

5. Подтверждения между сетями
   - Широковещание всем операторам; активный UI показывает модальное окно.
   - Первое решение выигрывает; Gateway обеспечивает атомарность.

---

# Краткое резюме (TL;DR)

- Сегодня: WS control plane + Bridge для транспорта узлов.
- Боль: подтверждения + дублирование + два стека.
- Предложение: один WS‑протокол с явными ролями + областями, унифицированное сопряжение + TLS‑пиннинг, подтверждения на Gateway, стабильные ID устройств + милые слаги.
- Итог: более простой UX, более сильная безопасность, меньше дублирования, лучшая маршрутизация для мобильных.
