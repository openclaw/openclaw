```markdown
---
summary: "리서치 노트: Clawd 워크스페이스의 오프라인 메모리 시스템 (Markdown 소스 오브 트루스 + 파생 인덱스)"
read_when:
  - 일일 Markdown 로그를 넘어 워크스페이스 메모리 (~/.openclaw/workspace) 설계
  - 독립형 CLI와 OpenClaw 깊은 통합 중 결정을 내릴 때
  - 오프라인 회상 + 반영 추가하기 (유지/회상/반영)
title: "워크스페이스 메모리 연구"
---

# 워크스페이스 메모리 v2 (오프라인): 연구 노트

목표: Clawd 스타일 워크스페이스 (`agents.defaults.workspace`, 기본 `~/.openclaw/workspace`)에서 "메모리"를 하루에 하나의 Markdown 파일 (`memory/YYYY-MM-DD.md`)과 소수의 안정된 파일들 (예: `memory.md`, `SOUL.md`)로 저장.

이 문서는 Markdown을 검토 가능한 진실의 소스로 유지하되, 파생 인덱스를 통해 **구조화된 회상**(검색, 엔티티 요약, 신뢰도 업데이트)을 추가하는 **오프라인 우선** 메모리 아키텍처를 제안합니다.

## 왜 변경이 필요한가?

현재 설정 (하루에 하나의 파일)은 다음에 뛰어납니다:

- “추가 전용” 저널링
- 사용자 편집
- git 기반의 내구성 + 감사 가능성
- 저마찰 캡처 ("그냥 적어놓는다")

약한 점은:

- 고회상 조회 ("X에 대해 우리가 어떤 결정을 내렸지?", "마지막으로 Y를 시도했을 때?")
- 엔티티 중심 답변 ("앨리스/성/warelay에 대해 말해줘")을 위한 여러 파일을 다시 읽지 않음
- 의견/선호 안정성 (변경 시 증거)
- 시간 제약 ("2025년 11월 동안 무엇이 사실이었지?") 및 갈등 해결

## 설계 목표

- **오프라인**: 네트워크 없이 작동; 노트북/성에서 실행 가능; 클라우드 의존 없음.
- **설명 가능**: 가져온 항목은 (파일 + 위치)로 기여 및 추론에서 분리 가능.
- **저 의식**: 일일 로그는 Markdown 유지, 무거운 스키마 작업 없음.
- **점진적**: v1은 FTS만으로 유용함; 의미/벡터, 그래프는 선택적 업그레이드.
- **에이전트 친화적**: "토큰 예산 내 회상" 쉽게 만들기 (작은 사실 다발 반환).

## 북극성 모델 (Hindsight × Letta)

두 가지를 혼합:

1. **Letta/MemGPT 스타일 제어 루프**

- 작은 "핵심"을 항상 문맥에 유지 (페르소나 + 주요 사용자 사실들)
- 나머지는 문맥을 벗어난 도구를 통해 검색
- 메모리 작성은 명시적 도구 호출 (추가/교체/삽입), 지속, 다음 턴에 다시 주입

2. **Hindsight 스타일 메모리 기판**

- 관측된 것과 믿어진 것, 요약된 것을 분리
- 유지/회상/반영 지원
- 증거와 함께 진화할 수 있는 자신 있는 의견
- 엔티티 인식 검색 + 시간 쿼리 지원

## 제안 아키텍처 (Markdown 소스 오브 트루스 + 파생 인덱스)

### 정식 스토어 (git 친화적)

`~/.openclaw/workspace`를 사람이 읽을 수 있는 정식 메모리로 유지.

제안된 워크스페이스 레이아웃:
```

~/.openclaw/workspace/
memory.md # 작고: 내구성 있는 사실 + 선호 (핵심 중)
memory/
YYYY-MM-DD.md # 일일 로그 (추가; 서사적 내러티브)
bank/ # "타입" 메모리 페이지 (안정적, 검토 가능)
world.md # 세계에 대한 객관적 사실
experience.md # 에이전트가 했던 일 (1인칭)
opinions.md # 주관적 선호/판단 + 신뢰도 + 증거 포인터
entities/
Peter.md
The-Castle.md
warelay.md
...

```

노트:

- **일일 로그는 일일 로그로 유지**. JSON으로 변환할 필요 없음.
- `bank/` 파일은 **큐레이션**되어, 반영 작업으로 생성되고 여전히 수작업 편집 가능.
- `memory.md`는 "작고 핵심 중"으로 유지: Clawd가 모든 세션에서 보고 싶어 하는 항목들.

### 파생 스토어 (머신 회상)

워크스페이스 아래에 파생 인덱스를 추가 (반드시 git 추적할 필요는 없음):

```

~/.openclaw/workspace/.memory/index.sqlite

```

다음으로 지원:

- 사실 + 엔티티 링크 + 의견 메타데이터 위한 SQLite 스키마
- SQLite **FTS5** Lexical 회상(빠르고, 작으며, 오프라인)
- 의미 회상을 위한 선택적 임베딩 테이블(여전히 오프라인)

인덱스는 항상 **Markdown에서 재구성 가능**.

## 유지 / 회상 / 반영 (운영 루프)

### 유지: 일일 로그를 “사실”로 정규화

Hindsight의 중요한 통찰력: **서사적, 독립형 사실**을 저장, 작은 스니펫이 아닌 것이 중요합니다.

`memory/YYYY-MM-DD.md`에 대한 실용적인 규칙:

- 하루 끝(또는 진행 중)에, 다음과 같은 2-5 개의 목록과 함께 `## Retain` 섹션을 추가하세요:
  - 서사적 (턴 간의 문맥 보존)
  - 독립형 (나중에 유의미함)
  - 타입 및 엔티티 언급으로 태그

예:

```

## Retain

- W @Peter: 현재 말라케시(2025년 11월 27일–12월 1일)에서 Andy의 생일을 위해.
- B @warelay: Baileys WS 충돌을 try/catch로 connection.update 핸들러를 감싸 해결 (memory/2025-11-27.md 참조).
- O(c=0.95) @Peter: WhatsApp에서 간결한 회신을 선호 (&lt;1500자); 긴 내용은 파일에 저장.

```

최소한의 구문 분석:

- 타입 접두사: `W` (세계), `B` (경험/전기), `O` (의견), `S` (관찰/요약; 주로 생성)
- 엔티티: `@Peter`, `@warelay` 등 (슬러그가 `bank/entities/*.md`로 매핑)
- 의견 신뢰도: `O(c=0.0..1.0)` 선택 가능

저자가 이에 대해 생각하지 않기를 원할 경우: reflect 작업은 로그의 나머지에서 이러한 목록을 추론할 수 있지만, 명시적인 `## Retain` 섹션을 두는 것이 가장 쉬운 "품질 레버"입니다.

### 회상: 파생 인덱스에 대한 쿼리

회상은 다음을 지원해야 합니다:

- **Lexical**: "정확한 용어/이름/명령 찾기" (FTS5)
- **Entity**: "X에 대해 말해줘" (엔티티 페이지 + 엔티티 연관된 사실들)
- **Temporal**: "11월 27일 근처에 무슨 일이 있었나" / "지난 주이후"
- **Opinion**: "Peter는 무엇을 선호하나요?" (신뢰도 + 증거와 함께)

반환 형식은 에이전트 친화적이어야 하며 출처를 인용해야 합니다:

- `kind` (`world|experience|opinion|observation`)
- `timestamp` (출처 날짜, 또는 나타난 시간 범위)
- `entities` (`["Peter","warelay"]`)
- `content` (서사적 사실)
- `source` (`memory/2025-11-27.md#L12` 등)

### 반영: 안정적인 페이지 생성 + 믿음 업데이트

Reflection은 예약 작업 (일일 또는 하트비트 `울트라싱크`)으로:

- 최근 사실에서 `bank/entities/*.md` 업데이트 (엔티티 요약)
- 강화/모순에 기초한 `bank/opinions.md` 신뢰도 업데이트
- 선택적으로 `memory.md` 편집 제안 ("핵심 중" 내구성 있는 사실)

의견 진화 (간단하고 설명 가능):

- 각 의견은 다음을 가집니다:
  - 진술문
  - 신뢰도 `c ∈ [0,1]`
  - 마지막 업데이트
  - 증거 링크 (지원하는 + 모순되는 사실 ID)
- 새로운 사실이 도착하면:
  - 엔티티 중복 + 유사도로 후보 의견 찾기 (먼저 FTS, 나중에 임베딩)
  - 작은 변화로 신뢰도 업데이트; 큰 변화는 강한 모순 + 반복된 증거 필요

## CLI 통합: 독립형 vs 깊은 통합

추천: **OpenClaw에 깊은 통합**, 그러나 분리 가능한 핵심 라이브러리를 유지.

### OpenClaw에 통합하는 이유?

- OpenClaw는 이미 알고 있습니다:
  - 워크스페이스 경로 (`agents.defaults.workspace`)
  - 세션 모델 + 하트비트
  - 로깅 + 문제 해결 패턴
- 에이전트 자체가 도구를 호출하기 원할 것입니다:
  - `openclaw memory recall "…" --k 25 --since 30d`
  - `openclaw memory reflect --since 7d`

### 라이브러리를 여전히 나누는 이유?

- 게이트웨이/런타임 없이 메모리 논리를 테스트 가능하게 유지
- 다른 컨텍스트 (로컬 스크립트, 미래 데스크탑 앱 등)에서 재사용

형태:
메모리 도구는 작은 CLI + 라이브러리 레이어로 의도되지만, 이는 탐색적일 뿐입니다.

## “S-Collide” / SuCo: 사용할 때 (연구)

“S-Collide”가 **SuCo (Subspace Collision)**를 의미한다면: 이는 학습/구조화된 서브스페이스에서 충돌을 사용하여 강력한 회상/대기 시간 절충을 목표로 하는 ANN 회수 접근법입니다 (논문: arXiv 2411.14754, 2024).

`~/.openclaw/workspace`에 대한 실용적인 접근:

- **SuCo로 시작하지 마세요.**
- SQLite FTS + (선택적) 간단한 임베딩으로 시작; 대부분의 UX 승리 즉시 얻을 수 있습니다.
- SuCo/HNSW/ScaNN 등급 솔루션은 오직 다음일 때 고려:
  - 코퍼스가 큼 (수텐/수십만 청크)
  - 임베딩 검색이 너무 느려짐
  - 회상 품질이 중요한 텍스트 검색에 의해 병목이됨

오프라인 친화적 대안 (복잡도 증가 순):

- SQLite FTS5 + 메타데이터 필터 (제로 ML)
- 임베딩 + 브루트 포스 (청크 수가 낮다면 놀랍도록 잘 작동)
- HNSW 인덱스 (일반적, 견고함; 라이브러리 바인딩 필요)
- SuCo (연구 등급; 내장할 수 있는 확고한 구현이 있다면 매력적)

열린 질문:

- 귀하의 머신(노트북 + 데스크탑)에서 "개인 비서 메모리"에 대한 **최상의** 오프라인 임베딩 모델이 무엇인가?
  - 이미 Ollama가 있다면: 로컬 모델로 임베드; 그렇지 않으면 도구 체인에 소형 임베딩 모델을 포함하세요.

## 가장 작은 유용한 파일럿

최소한으로, 여전히 유용한 버전을 원한다면:

- `bank/` 엔티티 페이지와 일일 로그에 `## Retain` 섹션을 추가.
- SQLite FTS를 사용하여 인용 (경로 + 줄 번호)과 함께 회상.
- 회상 품질이나 스케일이 요구될 경우에만 임베딩 추가.

## 참고문헌

- Letta / MemGPT 개념: “핵심 메모리 블록” + “아카이브 메모리” + 도구 기반의 자기 편집 메모리.
- Hindsight 기술 보고서: “유지 / 회상 / 반영”, 네트워크 4개 메모리, 서사적 사실 추출, 의견 신뢰도 진화.
- SuCo: arXiv 2411.14754 (2024): “서브스페이스 충돌” 근사 최근접 이웃 검색.
```
