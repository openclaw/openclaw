---
summary: "컨텍스트: 모델이 보는 것, 구축 방법 및 검사 방법"
read_when:
  - OpenClaw에서 "컨텍스트"가 무엇을 의미하는지 이해하고 싶을 때
  - 모델이 왜 무언가를 "알고" 있는지(혹은 잊어버렸는지) 디버깅할 때
  - 컨텍스트 오버헤드를 줄이고 싶을 때 (/context, /status, /compact)
title: "컨텍스트"
---

# 컨텍스트

"컨텍스트"는 **OpenClaw가 실행 시 모델에 보내는 모든 것**입니다. 이는 모델의 **컨텍스트 윈도우**(토큰 제한)에 의해 제한됩니다.

초보자용 사고 모델:

- **시스템 프롬프트**(OpenClaw가 구축): 규칙, 도구, 스킬 목록, 시간/런타임 및 주입된 워크스페이스 파일.
- **대화 역사**: 사용자의 메시지 + 이 세션에 대한 비서의 메시지.
- **도구 호출/결과 + 첨부파일**: 명령어 출력, 파일 읽기, 이미지/오디오 등.

컨텍스트는 "메모리"와 _같지 않습니다_: 메모리는 디스크에 저장되고 나중에 다시 불러올 수 있지만, 컨텍스트는 모델의 현재 창 안에 있는 것입니다.

## 빠른 시작 (컨텍스트 검사)

- `/status` → 내 윈도우가 얼마나 찼는지 빠르게 확인하고 세션 설정을 볼 수 있습니다.
- `/context list` → 주입된 것과 대략적인 크기(파일별 + 총합).
- `/context detail` → 파일별, 도구 스키마 사이즈별, 스킬 항목 크기별, 시스템 프롬프트 크기에 대한 더 깊은 분석.
- `/usage tokens` → 일반 응답에 대한 사용 후미를 추가합니다.
- `/compact` → 오래된 히스토리를 요약하여 윈도우 공간을 확보합니다.

참조: [슬래시 명령어](/ko-KR/tools/slash-commands), [토큰 사용 및 비용](/ko-KR/reference/token-use), [요약](/ko-KR/concepts/compaction).

## 예제 출력

값은 모델, 프로바이더, 도구 정책 및 워크스페이스 내용에 따라 달라집니다.

### `/context list`

```
🧠 컨텍스트 분해
워크스페이스: <workspaceDir>
부트스트랩 최대/파일: 20,000 문자
샌드박스: mode=non-main sandboxed=false
시스템 프롬프트 (실행): 38,412 문자 (~9,603 tok) (프로젝트 컨텍스트 23,901 문자 (~5,976 tok))

주입된 워크스페이스 파일:
- AGENTS.md: OK | 원본 1,742 문자 (~436 tok) | 주입됨 1,742 문자 (~436 tok)
- SOUL.md: OK | 원본 912 문자 (~228 tok) | 주입됨 912 문자 (~228 tok)
- TOOLS.md: 잘림 | 원본 54,210 문자 (~13,553 tok) | 주입됨 20,962 문자 (~5,241 tok)
- IDENTITY.md: OK | 원본 211 문자 (~53 tok) | 주입됨 211 문자 (~53 tok)
- USER.md: OK | 원본 388 문자 (~97 tok) | 주입됨 388 문자 (~97 tok)
- HEARTBEAT.md: 없음 | 원본 0 | 주입됨 0
- BOOTSTRAP.md: OK | 원본 0 문자 (~0 tok) | 주입됨 0 문자 (~0 tok)

스킬 목록 (시스템 프롬프트 텍스트): 2,184 문자 (~546 tok) (12 스킬)
도구: read, edit, write, exec, process, browser, message, sessions_send, …
도구 목록 (시스템 프롬프트 텍스트): 1,032 문자 (~258 tok)
도구 스키마 (JSON): 31,988 문자 (~7,997 tok) (컨텍스트에 포함됨; 텍스트로 표시되지 않음)
도구: (위와 동일)

세션 토큰 (캐시됨): 총 14,250개 / ctx=32,000
```

### `/context detail`

```
🧠 컨텍스트 분해 (세부)
…
최고 스킬 (프롬프트 항목 크기):
- frontend-design: 412 문자 (~103 tok)
- oracle: 401 문자 (~101 tok)
… (+10개 더 많은 스킬)

최고 도구 (스키마 크기):
- browser: 9,812 문자 (~2,453 tok)
- exec: 6,240 문자 (~1,560 tok)
… (+N개 더 많은 도구)
```

## 컨텍스트 윈도우에 포함되는 것들

모델이 받는 모든 것들이 포함됩니다:

- 시스템 프롬프트 (모든 섹션).
- 대화 역사.
- 도구 호출 + 도구 결과.
- 첨부파일/전사본 (이미지/오디오/파일).
- 요약 및 가지치기 아티팩트.
- 프로바이더 "랩퍼" 또는 숨겨진 헤더 (보이지 않지만, 여전히 계산됨).

## OpenClaw가 시스템 프롬프트를 구축하는 방법

시스템 프롬프트는 **OpenClaw 소유**이며 매 실행 시 다시 구축됩니다. 포함된 것들은:

- 도구 목록 + 짧은 설명.
- 스킬 목록 (메타데이터만; 아래 참조).
- 워크스페이스 위치.
- 시간 (UTC + 설정 시 변환된 사용자 시간).
- 런타임 메타데이터 (호스트/OS/모델/생각).
- **프로젝트 컨텍스트** 아래의 주입된 워크스페이스 부트스트랩 파일.

전체 분석: [시스템 프롬프트](/ko-KR/concepts/system-prompt).

## 주입된 워크스페이스 파일 (프로젝트 컨텍스트)

기본적으로, OpenClaw는 (존재하는 경우) 고정된 워크스페이스 파일 집합을 주입합니다:

- `AGENTS.md`
- `SOUL.md`
- `TOOLS.md`
- `IDENTITY.md`
- `USER.md`
- `HEARTBEAT.md`
- `BOOTSTRAP.md` (첫 실행 시에만)

큰 파일은 `agents.defaults.bootstrapMaxChars` (기본 `20000` 문자)을 사용하여 파일별로 잘립니다. OpenClaw는 `agents.defaults.bootstrapTotalMaxChars` (기본 `150000` 문자)를 사용하여 파일 전체의 총 부트스트랩 주입 제한도 시행합니다. `/context`는 **원본 대 주입** 크기와 잘림 여부를 보여줍니다.

## 스킬: 주입된 것 vs 필요 시 로드된 것

시스템 프롬프트에는 압축된 **스킬 목록**(이름 + 설명 + 위치)이 포함되어 있습니다. 이 목록은 실제 오버헤드를 가집니다.

스킬 지침은 기본적으로 포함되지 _않습니다_. 모델은 **필요할 때만** 스킬의 `SKILL.md`를 `읽어야` 합니다.

## 도구: 두 가지 비용

도구는 두 가지 방식으로 컨텍스트에 영향을 미칩니다:

1. 시스템 프롬프트에 포함된 **도구 목록 텍스트**(“도구화”로 보이는 것들).
2. **도구 스키마** (JSON). 이는 모델이 도구를 호출할 수 있도록 모델에 전송됩니다. 이는 일반 텍스트로 보이지 않더라도 컨텍스트에 포함됩니다.

`/context detail`은 가장 큰 도구 스키마를 분해하여 무엇이 주를 이루는지 보여줍니다.

## 명령어, 지시어, "인라인 단축키"

슬래시 명령어는 게이트웨이에 의해 처리됩니다. 몇 가지 다른 동작이 있습니다:

- **독립형 명령어**: 오직 `/...`로만 이루어진 메시지는 명령어로 실행됩니다.
- **지시어**: `/think`, `/verbose`, `/reasoning`, `/elevated`, `/model`, `/queue`는 모델이 메시지를 보기 전에 제거됩니다.
  - 지시어만 있는 메시지는 세션 설정을 유지합니다.
  - 일반 메시지에 있는 인라인 지시어는 메시지별 힌트로 작동합니다.
- **인라인 단축키**(허용된 발신자만): 일반 메시지 내부의 특정 `/...` 토큰은 즉시 실행될 수 있으며(예: "hey /status"), 모델이 나머지 텍스트를 보기 전에 제거됩니다.

세부 사항: [슬래시 명령어](/ko-KR/tools/slash-commands).

## 세션, 요약, 가지치기 (지속되는 것)

메시지 간 지속되는 것은 메커니즘에 따라 다릅니다:

- **일반 역사**는 정책에 의해 축약/가지치기될 때까지 세션 전사본에 유지됩니다.
- **요약**은 텍스트 요약을 전사본에 지속시키며 최근 메시지를 온전히 유지합니다.
- **가지치기**는 실행 시 _메모리 내_ 프롬프트에서 오래된 도구 결과를 제거하지만, 전사본을 다시 작성하지 않습니다.

문서: [세션](/ko-KR/concepts/session), [요약](/ko-KR/concepts/compaction), [세션 가지치기](/ko-KR/concepts/session-pruning).

## `/context`가 실제로 보고하는 것

`/context`는 가능할 경우 최신 **실행 빌드** 시스템 프롬프트 보고서를 선호합니다:

- `System prompt (run)` = 마지막에 임베드된(도구 사용 가능) 실행에서 캡처되어 세션 저장소에 유지됩니다.
- `System prompt (estimate)` = 실행 보고서가 없을 때 یا 보고서를 생성하지 않는 CLI 백엔드를 통해 실행될 때 대략적으로 계산됩니다.

어느 쪽이든, 이를 통해 크기와 주요 기여자를 보고하며, 전체 시스템 프롬프트나 도구 스키마를 덤프하지 **않습니다**.