---
summary: "Clawnet のリファクタリング: ネットワークプロトコル、ロール、認証、承認、アイデンティティの統合"
read_when:
  - ノード + オペレータークライアント向けの統合ネットワークプロトコルを計画しているとき
  - デバイス間での承認、ペアリング、TLS、プレゼンスを再設計しているとき
title: "Clawnet リファクタ"
---

# Clawnet リファクタ（プロトコル + 認証の統合）

## Hi

こんにちは Peter — 素晴らしい方向性です。これにより、よりシンプルな UX と、より強固なセキュリティが実現します。

## 目的

厳格な文書:

- 現状: プロトコル、フロー、信頼境界。
- 課題: 承認、マルチホップルーティング、UI の重複。
- 提案する新しい状態: 単一プロトコル、スコープ化されたロール、統合認証・ペアリング、TLS ピンニング。
- アイデンティティモデル: 安定 ID + 可愛いスラッグ。
- 移行計画、リスク、未解決の質問。

## ゴール（議論より）

- すべてのクライアント（mac アプリ、CLI、iOS、Android、ヘッドレスノード）で単一プロトコル。
- すべてのネットワーク参加者が認証済みかつペアリング済み。
- ロールの明確化: ノード vs オペレーター。
- 中央集約された承認を、ユーザーがいる場所にルーティング。
- すべてのリモート通信に TLS 暗号化 + オプションのピンニング。
- コード重複を最小化。
- 単一のマシンは UI 上で一度だけ表示（UI / ノードの重複なし）。

## 非ゴール（明示）

- 機能分離の撤廃（最小権限は引き続き必要）。
- スコープチェックなしでゲートウェイ制御プレーン全体を公開。
- 認証を人間向けラベルに依存させること（スラッグは非セキュリティ用途のまま）。

---

# 現状（as-is）

## 2 つのプロトコル

### 1. Gateway WebSocket（制御プレーン）

- 完全な API サーフェス: 設定、チャンネル、モデル、セッション、エージェント実行、ログ、ノードなど。
- Default bind: loopback. デフォルトのバインド: loopback。リモートアクセスは SSH / Tailscale 経由。
- 認証: トークン / パスワード（`connect`）。
- TLS ピンニングなし（loopback / トンネルに依存）。
- コード:
  - `src/gateway/server/ws-connection/message-handler.ts`
  - `src/gateway/client.ts`
  - `docs/gateway/protocol.md`

### 2. Bridge（ノード転送）

- 限定された許可リストのサーフェス、ノード ID とペアリング。
- TCP 上の JSONL。オプションで TLS + 証明書フィンガープリントのピンニング。
- TLS はディスカバリ TXT でフィンガープリントを通知。
- コード:
  - `src/infra/bridge/server/connection.ts`
  - `src/gateway/server-bridge.ts`
  - `src/node-host/bridge-client.ts`
  - `docs/gateway/bridge-protocol.md`

## 今日のコントロールプレーンクライアント数

- CLI → Gateway WS（`callGateway`、`src/gateway/call.ts`）。
- macOS アプリ UI → Gateway WS（`GatewayConnection`）。
- Web Control UI → Gateway WS。
- ACP → Gateway WS。
- ブラウザ制御は独自の HTTP 制御サーバーを使用。

## 現在のノード

- ノードモードの macOS アプリが Gateway bridge に接続（`MacNodeBridgeSession`）。
- iOS / Android アプリが Gateway bridge に接続。
- ペアリング + ノードごとのトークンはゲートウェイに保存。

## 現在の承認フロー（exec）

- エージェントが Gateway 経由で `system.run` を使用。
- Gateway が bridge 経由でノードを呼び出し。
- ノードランタイムが承認を判断。
- ノード == mac アプリの場合、mac アプリが UI プロンプトを表示。
- ノードが `invoke-res` を Gateway に返却。
- マルチホップで、UI がノードホストに結び付けられている。

## 現在のプレゼンス + アイデンティティ

- WS クライアント由来の Gateway プレゼンスエントリ。
- bridge 由来のノードプレゼンスエントリ。
- mac アプリは同一マシンに対して 2 エントリ（UI + ノード）を表示する可能性。
- ノード ID はペアリングストアに保存、UI の ID は別管理。

---

# 問題点 / ペインポイント

- 2 つのプロトコルスタック（WS + Bridge）の保守。
- リモートノードでの承認: プロンプトがユーザーのいる場所ではなくノードホストに表示される。
- TLS ピンニングは bridge のみ。WS は SSH / Tailscale に依存。
- アイデンティティの重複: 同一マシンが複数インスタンスとして表示される。
- ロールが曖昧: UI / ノード / CLI の権限分離が不明確。

---

# 提案する新しい状態（Clawnet）

## 単一プロトコル、2 つのロール

ロール + スコープを持つ単一の WS プロトコル。

- **ロール: node**（機能ホスト）
- **ロール: operator**（制御プレーン）
- operator のオプション **スコープ**:
  - `operator.read`（ステータス + 閲覧）
  - `operator.write`（エージェント実行、送信）
  - `operator.admin`（設定、チャンネル、モデル）

### ロールの動作

**Node**

- 機能を登録可能（`caps`、`commands`、権限）。
- `invoke` コマンドを受信可能（`system.run`、`camera.*`、`canvas.*`、`screen.record` など）。
- イベントを送信可能: `voice.transcript`、`agent.request`、`chat.subscribe`。
- 設定 / モデル / チャンネル / セッション / エージェント制御プレーン API は呼び出せない。

**Operator**

- スコープで制御された完全な制御プレーン API。
- すべての承認を受信。
- OS 操作は直接実行せず、ノードにルーティング。

### 重要なルール

ロールはデバイスごとではなく、パーコネクションです。 ロールはデバイス単位ではなく、接続単位です。1 台のデバイスが、別々に両ロールを開くことができます。

---

# 統合認証 + ペアリング

## クライアントアイデンティティ

すべてのクライアントは以下を提供します。

- `deviceId`（デバイスキーから導出される安定 ID）。
- `displayName`（人間向け名称）。
- `role` + `scope` + `caps` + `commands`。

## ペアリングフロー（統合）

- クライアントは未認証で接続。
- Gateway が 해당 `deviceId` に対する **ペアリングリクエスト** を作成。
- Operator がプロンプトを受信し、承認 / 拒否。
- Gateway が以下に紐付いた資格情報を発行:
  - デバイス公開鍵
  - ロール
  - スコープ
  - 機能 / コマンド
- クライアントはトークンを永続化し、認証済みで再接続。

## デバイスバインド認証（ベアラートークン再利用の回避）

優先：デバイスのキーペア。

- デバイスは一度だけ鍵ペアを生成。
- `deviceId = fingerprint(publicKey)`。
- Gateway がノンスを送信し、デバイスが署名、Gateway が検証。
- トークンは文字列ではなく公開鍵に発行（所持証明）。

代替案:

- mTLS（クライアント証明書）: 最強だが運用が複雑。
- 短命なベアラートークンは一時的なフェーズのみ（頻繁なローテーション + 早期失効）。

## サイレント承認（SSH ヒューリスティック）

弱いリンクを避けるために正確に定義してください。 優先順位：

- **ローカル限定**: loopback / Unix socket 経由接続時に自動ペアリング。
- **SSH チャレンジ**: Gateway がノンスを発行し、クライアントが SSH 経由で取得して証明。
- **物理的存在ウィンドウ**: Gateway ホスト UI でのローカル承認後、短時間（例: 10 分）自動ペアリングを許可。

常にログを残し、自動承認を記録します。

---

# TLS をすべてに（dev + prod）

## 既存 bridge TLS の再利用

現在の TLS ランタイム + フィンガープリントピンニングを使用。

- `src/infra/bridge/server/tls.ts`
- `src/node-host/bridge-client.ts` 内のフィンガープリント検証ロジック

## WS への適用

- WS サーバーは同一の証明書 / キー + フィンガープリントで TLS をサポート。
- WS クライアントはフィンガープリントをピン可能（オプション）。
- ディスカバリはすべてのエンドポイントに対して TLS + フィンガープリントを通知。
  - Discoveryはロケータヒントのみです; トラストアンカーではありません。

## 理由

- 機密性を SSH / Tailscale への依存から減らす。
- モバイルからのリモート接続をデフォルトで安全にする。

---

# 承認の再設計（中央集約）

## 現在

承認はノードホスト（mac アプリのノードランタイム）で行われ、プロンプトはノードが動作する場所に表示されます。 ノードの実行位置にプロンプトが表示されます。

## 提案

承認は **Gateway ホスト** で行い、UI はオペレータークライアントに配信します。

### 新しいフロー

1. Gateway がエージェントから `system.run` の意図を受信。
2. Gateway が承認レコードを作成: `approval.requested`。
3. Operator UI がプロンプトを表示。
4. 承認判断が Gateway に送信: `approval.resolve`。
5. 承認されれば Gateway がノードコマンドを実行。
6. ノードが実行し、`invoke-res` を返却。

### 承認セマンティクス（強化）

- すべてのオペレーターにブロードキャストし、アクティブな UI のみがモーダル表示（他はトースト）。
- 最初の解決が成功します; ゲートウェイは既に解決済みと同様にその後の解決を拒否します。
- デフォルトタイムアウト: N 秒後に拒否（例: 60 秒）、理由をログ。
- 解決には `operator.approvals` スコープが必要。

## 利点

- プロンプトがユーザーのいる場所（mac / スマートフォン）に表示。
- リモートノードでも一貫した承認。
- ノードランタイムはヘッドレスのまま、UI 依存なし。

---

# ロール明確化の例

## iPhone アプリ

- **Node ロール**: マイク、カメラ、音声チャット、位置情報、プッシュトゥトーク。
- オプション **operator.read**: ステータスとチャット閲覧。
- 明示的に有効化した場合のみ **operator.write / admin**。

## macOS アプリ

- デフォルトで Operator ロール（制御 UI）。
- 「Mac ノード」有効時に Node ロール（system.run、画面、カメラ）。
- 両接続で同一 deviceId → UI では 1 エントリに統合。

## CLI

- 常に Operator ロール。
- スコープはサブコマンドから導出:
  - `status`、`logs` → read
  - `agent`、`message` → write
  - `config`、`channels` → admin
  - 承認 + ペアリング → `operator.approvals` / `operator.pairing`

---

# アイデンティティ + スラッグ

## 安定 ID

認証に必須で、変更不可。
推奨:
推奨：

- 鍵ペアのフィンガープリント（公開鍵ハッシュ）。

## 可愛いスラッグ（ロブスター風）

人間向けラベルのみ。

- 例: `scarlet-claw`、`saltwave`、`mantis-pinch`。
- Gateway レジストリに保存、編集可能。
- 衝突処理: `-2`、`-3`。

## UI グルーピング

ロールを跨いで同一 `deviceId` → 単一の「Instance」行:

- バッジ: `operator`、`node`。
- 最後に見られた機能 + を表示します。

---

# 移行戦略

## フェーズ 0: ドキュメント化 + 整合

- 本ドキュメントを公開。
- すべてのプロトコル呼び出し + 承認フローを棚卸し。

## フェーズ 1: WS にロール / スコープ追加

- `connect` パラメータを `role`、`scope`、`deviceId` で拡張。
- Node ロール向け許可リスト制御を追加。

## フェーズ 2: Bridge 互換

- Bridge を維持。
- 並行して WS ノードサポートを追加。
- 設定フラグの背後にあるゲート機能。

## フェーズ 3: 中央承認

- WS に承認リクエスト + 解決イベントを追加。
- mac アプリ UI を更新し、プロンプト表示 + 応答。
- ノードランタイムは UI プロンプトを停止。

## フェーズ 4: TLS 統合

- Bridge TLS ランタイムを用いて WS 用 TLS 設定を追加。
- クライアントにピンニングを追加。

## フェーズ 5: Bridge 廃止

- iOS / Android / mac ノードを WS に移行。
- Bridge はフォールバックとして残し、安定後に削除。

## フェーズ 6: デバイスバインド認証

- 非ローカル接続では鍵ベース ID を必須化。
- 失効 + ローテーション UI を追加。

---

# セキュリティ注記

- ロール / 許可リストは Gateway 境界で強制。
- Operator スコープなしに「フル」API を取得するクライアントは存在しない。
- _すべて_ の接続でペアリング必須。
- TLS + ピンニングによりモバイルでの MITM リスクを低減。
- SSH サイレント承認は利便性機能であり、記録・失効可能。
- ディスカバリは決して信頼アンカーではない。
- 機能クレームは、プラットフォーム / 種別ごとのサーバー許可リストで検証。

# ストリーミング + 大容量ペイロード（ノードメディア）

WS 制御プレーンは小さなメッセージには十分ですが、ノードは以下も扱います。

- カメラクリップ
- 画面録画
- 音声ストリーム

選択肢:

1. WS バイナリフレーム + チャンク化 + バックプレッシャールール。
2. 分離されたストリーミングエンドポイント（TLS + 認証は維持）。
3. メディア負荷の高いコマンドでは bridge を長く維持し、最後に移行。

ドリフトを避けるために実装の前に1つを選択してください。

# 機能 + コマンドポリシー

- ノード報告されたキャップ/コマンドは **要求**として扱われます。
- Gateway がプラットフォームごとの許可リストを強制。
- 新しいコマンドはオペレーター承認、または明示的な許可リスト変更が必要。
- 変更はタイムスタンプ付きで監査。

# 監査 + レート制限

- ログ: ペアリングリクエスト、承認 / 拒否、トークン発行 / ローテーション / 失効。
- ペアリングスパムや承認プロンプトにレート制限。

# プロトコル衛生

- 明示的なプロトコルバージョン + エラーコード。
- 再接続ルール + ハートビートポリシー。
- Presence TTL and last‐seen semantics.

---

# Open questions

1. 両ロールを実行する単一デバイス: トークンモデル
   - ロールごと（node / operator）に別トークンを推奨。
   - 同一 deviceId、異なるスコープで、失効が明確。

2. Operator スコープ粒度
   - read / write / admin + 承認 + ペアリング（最小構成）。
   - 機能ごとのスコープは後で検討してください。

3. トークンローテーション + 失効 UX
   - ロール変更時に自動ローテーション。
   - deviceId + ロール単位で失効できる UI。

4. 検出
   - 既存 Bonjour TXT を拡張し、WS TLS フィンガープリント + ロールヒントを含める。
   - ロケータヒントとしてのみ扱う。

5. クロスネットワーク承認
   - すべての Operator クライアントにブロードキャストし、アクティブ UI がモーダル表示。
   - 最初の応答が勝利します。ゲートウェイはアトミシティーを強化します。

---

# まとめ（TL;DR）

- 現在: WS 制御プレーン + Bridge ノード転送。
- 痛み:承認+重複+2スタック。
- 提案: 明示的なロール + スコープを持つ単一 WS プロトコル、統合ペアリング + TLS ピンニング、Gateway ホスト型承認、安定したデバイス ID + 可愛いスラッグ。
- 結果: よりシンプルな UX、より強固なセキュリティ、重複削減、モバイルでのより良いルーティング。
